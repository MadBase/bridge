// SPDX-License-Identifier: MIT-open-group
pragma solidity ^0.8.11;

import "../lib/utils/DeterministicAddress.sol";

/**
    * @notice Proxy is a delegatecall reverse proxy implementation
    * the forwarding address is stored at the slot location of not(0)
    * if not(0) has a value stored in it that is of the form 0Xca11c0de15dead10cced0000< address >
    * the proxy may no longer be upgraded using the internal mechanism. This does not prevent the implementation
    * from upgrading the proxy by changing this slot.
    * The proxy may be directly upgraded ( if the lock is not set )  
    * by calling the proxy from the factory address using the format
    * abi.encodeWithSelector(0xca11c0de, <address>);
    * All other calls will be proxied through to the implementation.
    * The implementation can not be locked using the internal upgrade mechanism due to the fact that the internal
    * mechanism zeros out the higher order bits. Therefore, the implementation itself must carry the locking mechanism that sets
    * the higher order bits to lock the upgrade capability of the proxy.
*/
contract Proxy {
    address immutable private factory_;
    constructor(address _factory) {
        factory_ = _factory;
    }

    fallback() payable external {
        // make local copy of factory since immutables
        // are not accessable in assembly as of yet
        address factory = factory_;
        assembly {
            
            // admin is the builtin logic to change the implementation
            function admin() {
                // this is an assignment to implementation
                let newImpl := shr(96, shl(96, calldataload(0x04)))
                if eq(shr(160, sload(not(returndatasize()))), 0xca11c0de15dead10cced0000) {
                    mstore(returndatasize(), "imploc")
                    revert(returndatasize(), 0x20)
                }
                // store address into slot
                sstore(not(returndatasize()), newImpl)
                stop()
            }

            // passthrough is the passthrough logic to delegate to the implementation
            function passthrough() {
                // load free memory pointer
                let _ptr := mload(0x40)
                // allocate memory proportionate to calldata
                mstore(0x40, add(_ptr, calldatasize()))
                // copy calldata into memory
                calldatacopy(_ptr, returndatasize(), calldatasize())
                let ret := delegatecall(gas(), sload(not(returndatasize())), _ptr, calldatasize(), returndatasize(), returndatasize())
                returndatacopy(_ptr, 0x00, returndatasize())
                if iszero(ret) {
                    revert(_ptr, returndatasize())
                }
                return(_ptr, returndatasize())
            }

            // if caller is factory, 
            // and has 0xca11c0de<address> as calldata
            // run admin logic and return
            if eq(caller(), factory) {
                if eq(calldatasize(), 0x24) {
                    if eq(shr(224, calldataload(0x00)), 0xca11c0de) {
                        admin()
                    }
                }
            }
            // admin logic was not run so fallthrough to delegatecall
            passthrough()
        }
    }
}

abstract contract ProxyUpgrader {
    function __upgrade(address _proxy, address _newImpl) internal {
        bytes memory cdata = abi.encodeWithSelector(0xca11c0de, _newImpl);
        assembly {
            if iszero(call(gas(), _proxy, 0, add(cdata, 0x20), mload(cdata), 0x00, 0x00)) {
                let ptr := mload(0x40)
                mstore(0x40, add(ptr, returndatasize()))
                returndatacopy(ptr, 0x00, returndatasize())
                revert(ptr, returndatasize())
            }
        }
    }
}



contract Factory is DeterministicAddress, ProxyUpgrader {

      /**
    @dev slot for storing implementation address
    */
    address public implementation_;

    /**
    @dev reference to proxy deploycode
    */
    address immutable proxyTemplate_;

    bytes8 constant universalDeployCode_ = 0x38585839386009f3;

    constructor(address selfAddr_) {
        bytes memory proxyDeployCode = abi.encodePacked(universalDeployCode_, type(Proxy).creationCode, bytes32(uint256(uint160(selfAddr_))));
        address addr;
        assembly {
            addr := create(0, add(proxyDeployCode, 0x20), mload(proxyDeployCode))
            if iszero(addr) {
                revert(0x00, 0x00)
            }
        }
        proxyTemplate_ = addr;
    }

    function deployProxy(bytes32 _salt) public returns (address contractAddr) {
        address proxyTemplate = proxyTemplate_;
        assembly {
            // store proxy template address as implementation,
            sstore(implementation_.slot, proxyTemplate)
            let ptr := mload(0x40)
            mstore(0x40, add(ptr, 0x20))
            // put metamorphic code as initcode
            //push1 20 
            mstore(ptr, shl(72, 0x6020363636335afa1536363636515af43d36363e3d36f3))
            contractAddr := create2(0, ptr, 0x17, _salt)
        }
        return contractAddr;
    }

    function upgradeProxy(bytes32 _salt, address _newImpl) public {
        address proxy = DeterministicAddress.getMetamorphicContractAddress(_salt, address(this));
        __upgrade(proxy, _newImpl);
    }

    function initializeContract(address _contract, bytes calldata _initCallData) public {
        assembly {
            if iszero(iszero(_initCallData.length)) {
                let ptr := mload(0x40)
                mstore(0x40, add(_initCallData.length, ptr))
                calldatacopy(ptr, _initCallData.offset, _initCallData.length)
                if iszero(call(gas(), _contract, 0, ptr, _initCallData.length, 0x00, 0x00)) {
                    ptr := mload(0x40)
                    mstore(0x40, add(returndatasize(), ptr))
                    returndatacopy(ptr, 0x00, returndatasize())
                    revert(ptr, returndatasize())
                }
            }
        }
    }

    function deployTemplate(bytes calldata _deployCode) public returns (address contractAddr) {
        assembly{
            //get the next free pointer
            let basePtr := mload(0x40)
            mstore(0x40, add(basePtr, add(_deployCode.length, 0x80)))
            let ptr := basePtr
            // modify runtime to contain the tail jump operation
            //codesize, pc,  pc, codecopy, codesize, push1 09, return push2 <codesize> 56 5b
            mstore(ptr, shl(152, or(0x38585839386009f3610000565b, shl(16, and(add(0x20, _deployCode.length), 0xffff)))))
            ptr := add(ptr, 0x0d)
            //copy the initialization code of the implementation contract
            calldatacopy(ptr, add(0x05, _deployCode.offset), sub(_deployCode.length, 0x05))
            // Move the ptr to the end of the code in memory
            ptr := add(ptr, sub(_deployCode.length, 0x05))
            // put address on constructor
            mstore(ptr, address())
            ptr := add(ptr, 0x20)
            // finish the code with the terminate sequence
            // jumpdest < oldhead > caller push20 <factory> eq calldatasize iszero iszero and iszero push1<04> jumpi caller selfdestruct invalid
            // 5b < old head > 33 73 <factory> 14 36 15 6004 57 33 ff fe
            mstore8(ptr, 0x5b)
            ptr := add(ptr, 0x01)
            calldatacopy(ptr, _deployCode.offset, 0x05)
            ptr := add(ptr, 0x05)
            mstore(ptr, or(0x3373000000000000000000000000000000000000000014361515161560045733, shl(80, address())))
            ptr := add(ptr, 0x20)
            mstore8(ptr, 0xff)
            ptr := add(ptr, 0x01)
            mstore8(ptr, 0xfe)
            ptr := add(ptr, 0x01)
            contractAddr := create(0, basePtr, sub(ptr, basePtr))
        }
        implementation_ = contractAddr;
        return contractAddr;      
    }

    function deployStatic(bytes32 _salt) public returns (address contractAddr) {
        assembly {
            // store proxy template address as implementation,
            //sstore(implementation_.slot, _impl)
            let ptr := mload(0x40)
            mstore(0x40, add(ptr, 0x20))
            // put metamorphic code as initcode
            mstore(ptr, shl(72, 0x6020363636335afa1536363636515af43d36363e3d36f3))
            contractAddr := create2(0, ptr, 0x17, _salt)
            if iszero(call(gas(), sload(implementation_.slot), 0, 0x00, 0x01, 0x00, 0x00)) {
                mstore(0x40, add(ptr, returndatasize()))
                returndatacopy(ptr, 0x00, returndatasize())
                revert(ptr, returndatasize())
            }
        }
         implementation_ = contractAddr;
        return contractAddr;
    }

    /**  
    * @dev fallback function returns the address of the most recent deployment of a template 
    */
    fallback() external {
        assembly {
            mstore(returndatasize(), sload(implementation_.slot))
            return(returndatasize(), 0x20)
        }
    }
}

abstract contract ProxyInternalUpgradeLock {
    function __lockImplementation(address _factory) internal {
        address factory = _factory;
        assembly{
            let implSlot := not(factory)
            sstore(implSlot, or(0xca11c0de15dead10cced00000000000000000000000000000000000000000000, sload(implSlot)))
        }
    }
}

abstract contract ProxyInternalUpgradeUnlock {
    function __unlockImplementation(address _factory) internal {
        address factory = _factory;
        assembly{
            let implSlot := not(factory)
            sstore(implSlot, and(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, sload(implSlot)))
        }
    }
}


contract Mock is ProxyInternalUpgradeLock, ProxyInternalUpgradeUnlock {
    uint256 public v;
    uint256 public immutable i;
    address factory_;
    constructor(uint256 _i) {
        i=_i;
        factory_ = msg.sender;
    }
    function setv(uint256 _v) public {
        v=_v;
    }
    function lock() public {
        __lockImplementation(factory_);
    }
    function unlock() public {
        __unlockImplementation(factory_);
    }

    function setFactory(address _factory) public {
        factory_ = _factory;
    }
}

interface MockI {
    function v() external returns(uint256);
    function i() external returns(uint256);
    function setv(uint256 _v) external;
    function lock() external;
    function unlock() external;
    function fail() external;
}
/*
contract TestProxy is ProxyUpgrader {

    Proxy immutable public proxy;
    MockI immutable mock0;
    MockI immutable mock1;

    constructor() {
        proxy  = new Proxy(address(this));
        Mock m0 = new Mock(0);
        Mock m1 = new Mock(1);
        mock0 = MockI(address(m0));
        mock1 = MockI(address(m1));
    }

    function assertMock(MockI m, uint256 i, uint256 v) internal {
        require(m.i() == i, "bad value for i");
        require(m.v() == v, "bad value for v");
        m.setv(v+1);
        require(m.i() == i, "bad value for i");
        require(m.v() == v+1, "bad value for v");
        m.setv(v);
        require(m.i() == i, "bad value for i");
        require(m.v() == v, "bad value for v");
        try m.fail() {
            require(false, "should have thrown");
        } catch {
            // do nothing
        }
    }

    function test() public {
        MockI m = MockI(address(proxy));
        //////////////////////////////////////////
        this.upgrade(address(mock0));
        assertMock(m, 0, 0);
        m.lock();
        try this.upgrade(address(mock1)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 0, 0);
            m.unlock();
        }
        //////////////////////////////////////////
        this.upgrade(address(mock1));
        assertMock(m, 1, 0);
        m.lock();
        try this.upgrade(address(mock0)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 1, 0);
            m.unlock();
        }
        //////////////////////////////////////////
        this.upgrade(address(mock0));
        assertMock(m, 0, 0);
        m.lock();
        try this.upgrade(address(mock1)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 0, 0);
            m.unlock();
        }
    }

    function upgrade(address m) public {
        require(msg.sender == address(this));
        __upgrade(address(proxy), m);
    }
        
}


contract TestProxyFactory is ProxyUpgrader {

    MockI immutable mock0;
    MockI immutable mock1;
    ProxyFactory immutable factory;

    constructor() {
        factory = new ProxyFactory();
        factory.initializeProxyTemplate();
        Mock m0 = new Mock(0);
        m0.setFactory(address(factory));
        Mock m1 = new Mock(1);
        m1.setFactory(address(factory));
        mock0 = MockI(address(m0));
        mock1 = MockI(address(m1));
    }

    function assertMock(MockI m, uint256 i, uint256 v) internal {
        require(m.i() == i, "bad value for i");
        require(m.v() == v, "bad value for v");
        m.setv(v+1);
        require(m.i() == i, "bad value for i");
        require(m.v() == v+1, "bad value for v");
        m.setv(v);
        require(m.i() == i, "bad value for i");
        require(m.v() == v, "bad value for v");
        try m.fail() {
            require(false, "should have thrown");
        } catch {
            // do nothing
        }
    }

    function test() public {
        address proxy = factory.deployProxy(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff);
        MockI m = MockI(address(proxy));
        //////////////////////////////////////////
        factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock0));
        assertMock(m, 0, 0);
        m.lock();
        try factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock1)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 0, 0);
            m.unlock();
        }
        // //////////////////////////////////////////
        factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock1));
        assertMock(m, 1, 0);
        m.lock();
        try factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock0)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 1, 0);
            m.unlock();
        }
        // //////////////////////////////////////////
        factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock0));
        assertMock(m, 0, 0);
        m.lock();
        try factory.upgrade(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff, address(mock1)) {
            require(false, "should have thrown");
        } catch {
            assertMock(m, 0, 0);
            m.unlock();
        }
    }
        
}
*/

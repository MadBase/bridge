// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package bindings

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// BasicERC20ABI is the input ABI used to generate the binding from.
const BasicERC20ABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// BasicERC20 is an auto generated Go binding around an Ethereum contract.
type BasicERC20 struct {
	BasicERC20Caller     // Read-only binding to the contract
	BasicERC20Transactor // Write-only binding to the contract
	BasicERC20Filterer   // Log filterer for contract events
}

// BasicERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type BasicERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BasicERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type BasicERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BasicERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BasicERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BasicERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BasicERC20Session struct {
	Contract     *BasicERC20       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BasicERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BasicERC20CallerSession struct {
	Contract *BasicERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// BasicERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BasicERC20TransactorSession struct {
	Contract     *BasicERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// BasicERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type BasicERC20Raw struct {
	Contract *BasicERC20 // Generic contract binding to access the raw methods on
}

// BasicERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BasicERC20CallerRaw struct {
	Contract *BasicERC20Caller // Generic read-only contract binding to access the raw methods on
}

// BasicERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BasicERC20TransactorRaw struct {
	Contract *BasicERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewBasicERC20 creates a new instance of BasicERC20, bound to a specific deployed contract.
func NewBasicERC20(address common.Address, backend bind.ContractBackend) (*BasicERC20, error) {
	contract, err := bindBasicERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BasicERC20{BasicERC20Caller: BasicERC20Caller{contract: contract}, BasicERC20Transactor: BasicERC20Transactor{contract: contract}, BasicERC20Filterer: BasicERC20Filterer{contract: contract}}, nil
}

// NewBasicERC20Caller creates a new read-only instance of BasicERC20, bound to a specific deployed contract.
func NewBasicERC20Caller(address common.Address, caller bind.ContractCaller) (*BasicERC20Caller, error) {
	contract, err := bindBasicERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BasicERC20Caller{contract: contract}, nil
}

// NewBasicERC20Transactor creates a new write-only instance of BasicERC20, bound to a specific deployed contract.
func NewBasicERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*BasicERC20Transactor, error) {
	contract, err := bindBasicERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BasicERC20Transactor{contract: contract}, nil
}

// NewBasicERC20Filterer creates a new log filterer instance of BasicERC20, bound to a specific deployed contract.
func NewBasicERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*BasicERC20Filterer, error) {
	contract, err := bindBasicERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BasicERC20Filterer{contract: contract}, nil
}

// bindBasicERC20 binds a generic wrapper to an already deployed contract.
func bindBasicERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BasicERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BasicERC20 *BasicERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BasicERC20.Contract.BasicERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BasicERC20 *BasicERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BasicERC20.Contract.BasicERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BasicERC20 *BasicERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BasicERC20.Contract.BasicERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BasicERC20 *BasicERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BasicERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BasicERC20 *BasicERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BasicERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BasicERC20 *BasicERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BasicERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_BasicERC20 *BasicERC20Caller) Allowance(opts *bind.CallOpts, src common.Address, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BasicERC20.contract.Call(opts, out, "allowance", src, who)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_BasicERC20 *BasicERC20Session) Allowance(src common.Address, who common.Address) (*big.Int, error) {
	return _BasicERC20.Contract.Allowance(&_BasicERC20.CallOpts, src, who)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_BasicERC20 *BasicERC20CallerSession) Allowance(src common.Address, who common.Address) (*big.Int, error) {
	return _BasicERC20.Contract.Allowance(&_BasicERC20.CallOpts, src, who)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_BasicERC20 *BasicERC20Caller) BalanceOf(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BasicERC20.contract.Call(opts, out, "balanceOf", who)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_BasicERC20 *BasicERC20Session) BalanceOf(who common.Address) (*big.Int, error) {
	return _BasicERC20.Contract.BalanceOf(&_BasicERC20.CallOpts, who)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_BasicERC20 *BasicERC20CallerSession) BalanceOf(who common.Address) (*big.Int, error) {
	return _BasicERC20.Contract.BalanceOf(&_BasicERC20.CallOpts, who)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_BasicERC20 *BasicERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BasicERC20.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_BasicERC20 *BasicERC20Session) TotalSupply() (*big.Int, error) {
	return _BasicERC20.Contract.TotalSupply(&_BasicERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_BasicERC20 *BasicERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _BasicERC20.Contract.TotalSupply(&_BasicERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Transactor) Approve(opts *bind.TransactOpts, who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.contract.Transact(opts, "approve", who, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Session) Approve(who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.Approve(&_BasicERC20.TransactOpts, who, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20TransactorSession) Approve(who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.Approve(&_BasicERC20.TransactOpts, who, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Transactor) Transfer(opts *bind.TransactOpts, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.contract.Transact(opts, "transfer", dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Session) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.Transfer(&_BasicERC20.TransactOpts, dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20TransactorSession) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.Transfer(&_BasicERC20.TransactOpts, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Transactor) TransferFrom(opts *bind.TransactOpts, src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.contract.Transact(opts, "transferFrom", src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20Session) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.TransferFrom(&_BasicERC20.TransactOpts, src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_BasicERC20 *BasicERC20TransactorSession) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _BasicERC20.Contract.TransferFrom(&_BasicERC20.TransactOpts, src, dst, wad)
}

// ConBaseABI is the input ABI used to generate the binding from.
const ConBaseABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"special_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ConBaseBin is the compiled bytecode used for deploying new contracts.
var ConBaseBin = "0x608060405234801561001057600080fd5b506040516103143803806103148339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600560008190555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506102778061009d6000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638381f58a1461003b578063d09de08a14610059575b600080fd5b610043610063565b6040518082815260200191505060405180910390f35b610061610069565b005b60005481565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527fd09de08a000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b6020831061015a5780518252602082019150602081019050602083039250610137565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101ba576040519150601f19603f3d011682016040523d82523d6000602084013e6101bf565b606091505b5050905080610219576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602581526020018061021d6025913960400191505060405180910390fd5b5056fe64656c6567617465642063616c6c206661696c656420666f7220696e6372656d656e742829a2646970667358221220668a96aab18264ac8548447df53cfbd02e5f7756b6f742fc5fb9724add6285a364736f6c63430006070033"

// DeployConBase deploys a new Ethereum contract, binding an instance of ConBase to it.
func DeployConBase(auth *bind.TransactOpts, backend bind.ContractBackend, special_ common.Address) (common.Address, *types.Transaction, *ConBase, error) {
	parsed, err := abi.JSON(strings.NewReader(ConBaseABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ConBaseBin), backend, special_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ConBase{ConBaseCaller: ConBaseCaller{contract: contract}, ConBaseTransactor: ConBaseTransactor{contract: contract}, ConBaseFilterer: ConBaseFilterer{contract: contract}}, nil
}

// ConBase is an auto generated Go binding around an Ethereum contract.
type ConBase struct {
	ConBaseCaller     // Read-only binding to the contract
	ConBaseTransactor // Write-only binding to the contract
	ConBaseFilterer   // Log filterer for contract events
}

// ConBaseCaller is an auto generated read-only Go binding around an Ethereum contract.
type ConBaseCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConBaseTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ConBaseTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConBaseFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ConBaseFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConBaseSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ConBaseSession struct {
	Contract     *ConBase          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ConBaseCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ConBaseCallerSession struct {
	Contract *ConBaseCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ConBaseTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ConBaseTransactorSession struct {
	Contract     *ConBaseTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ConBaseRaw is an auto generated low-level Go binding around an Ethereum contract.
type ConBaseRaw struct {
	Contract *ConBase // Generic contract binding to access the raw methods on
}

// ConBaseCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ConBaseCallerRaw struct {
	Contract *ConBaseCaller // Generic read-only contract binding to access the raw methods on
}

// ConBaseTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ConBaseTransactorRaw struct {
	Contract *ConBaseTransactor // Generic write-only contract binding to access the raw methods on
}

// NewConBase creates a new instance of ConBase, bound to a specific deployed contract.
func NewConBase(address common.Address, backend bind.ContractBackend) (*ConBase, error) {
	contract, err := bindConBase(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ConBase{ConBaseCaller: ConBaseCaller{contract: contract}, ConBaseTransactor: ConBaseTransactor{contract: contract}, ConBaseFilterer: ConBaseFilterer{contract: contract}}, nil
}

// NewConBaseCaller creates a new read-only instance of ConBase, bound to a specific deployed contract.
func NewConBaseCaller(address common.Address, caller bind.ContractCaller) (*ConBaseCaller, error) {
	contract, err := bindConBase(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ConBaseCaller{contract: contract}, nil
}

// NewConBaseTransactor creates a new write-only instance of ConBase, bound to a specific deployed contract.
func NewConBaseTransactor(address common.Address, transactor bind.ContractTransactor) (*ConBaseTransactor, error) {
	contract, err := bindConBase(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ConBaseTransactor{contract: contract}, nil
}

// NewConBaseFilterer creates a new log filterer instance of ConBase, bound to a specific deployed contract.
func NewConBaseFilterer(address common.Address, filterer bind.ContractFilterer) (*ConBaseFilterer, error) {
	contract, err := bindConBase(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ConBaseFilterer{contract: contract}, nil
}

// bindConBase binds a generic wrapper to an already deployed contract.
func bindConBase(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ConBaseABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConBase *ConBaseRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConBase.Contract.ConBaseCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConBase *ConBaseRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConBase.Contract.ConBaseTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConBase *ConBaseRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConBase.Contract.ConBaseTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConBase *ConBaseCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConBase.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConBase *ConBaseTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConBase.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConBase *ConBaseTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConBase.Contract.contract.Transact(opts, method, params...)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConBase *ConBaseCaller) Number(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ConBase.contract.Call(opts, out, "number")
	return *ret0, err
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConBase *ConBaseSession) Number() (*big.Int, error) {
	return _ConBase.Contract.Number(&_ConBase.CallOpts)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConBase *ConBaseCallerSession) Number() (*big.Int, error) {
	return _ConBase.Contract.Number(&_ConBase.CallOpts)
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConBase *ConBaseTransactor) Increment(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConBase.contract.Transact(opts, "increment")
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConBase *ConBaseSession) Increment() (*types.Transaction, error) {
	return _ConBase.Contract.Increment(&_ConBase.TransactOpts)
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConBase *ConBaseTransactorSession) Increment() (*types.Transaction, error) {
	return _ConBase.Contract.Increment(&_ConBase.TransactOpts)
}

// ConSpecialABI is the input ABI used to generate the binding from.
const ConSpecialABI = "[{\"inputs\":[],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ConSpecialBin is the compiled bytecode used for deploying new contracts.
var ConSpecialBin = "0x6080604052600560008190555060aa8061001a6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80638381f58a146037578063d09de08a146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600080815480929190600101919050555056fea2646970667358221220e54988f595abbff45881d9331832105fdbfc3c2c3afb5407f1fb3b4bdc2db36964736f6c63430006070033"

// DeployConSpecial deploys a new Ethereum contract, binding an instance of ConSpecial to it.
func DeployConSpecial(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ConSpecial, error) {
	parsed, err := abi.JSON(strings.NewReader(ConSpecialABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ConSpecialBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ConSpecial{ConSpecialCaller: ConSpecialCaller{contract: contract}, ConSpecialTransactor: ConSpecialTransactor{contract: contract}, ConSpecialFilterer: ConSpecialFilterer{contract: contract}}, nil
}

// ConSpecial is an auto generated Go binding around an Ethereum contract.
type ConSpecial struct {
	ConSpecialCaller     // Read-only binding to the contract
	ConSpecialTransactor // Write-only binding to the contract
	ConSpecialFilterer   // Log filterer for contract events
}

// ConSpecialCaller is an auto generated read-only Go binding around an Ethereum contract.
type ConSpecialCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConSpecialTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ConSpecialTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConSpecialFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ConSpecialFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConSpecialSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ConSpecialSession struct {
	Contract     *ConSpecial       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ConSpecialCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ConSpecialCallerSession struct {
	Contract *ConSpecialCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ConSpecialTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ConSpecialTransactorSession struct {
	Contract     *ConSpecialTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ConSpecialRaw is an auto generated low-level Go binding around an Ethereum contract.
type ConSpecialRaw struct {
	Contract *ConSpecial // Generic contract binding to access the raw methods on
}

// ConSpecialCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ConSpecialCallerRaw struct {
	Contract *ConSpecialCaller // Generic read-only contract binding to access the raw methods on
}

// ConSpecialTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ConSpecialTransactorRaw struct {
	Contract *ConSpecialTransactor // Generic write-only contract binding to access the raw methods on
}

// NewConSpecial creates a new instance of ConSpecial, bound to a specific deployed contract.
func NewConSpecial(address common.Address, backend bind.ContractBackend) (*ConSpecial, error) {
	contract, err := bindConSpecial(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ConSpecial{ConSpecialCaller: ConSpecialCaller{contract: contract}, ConSpecialTransactor: ConSpecialTransactor{contract: contract}, ConSpecialFilterer: ConSpecialFilterer{contract: contract}}, nil
}

// NewConSpecialCaller creates a new read-only instance of ConSpecial, bound to a specific deployed contract.
func NewConSpecialCaller(address common.Address, caller bind.ContractCaller) (*ConSpecialCaller, error) {
	contract, err := bindConSpecial(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ConSpecialCaller{contract: contract}, nil
}

// NewConSpecialTransactor creates a new write-only instance of ConSpecial, bound to a specific deployed contract.
func NewConSpecialTransactor(address common.Address, transactor bind.ContractTransactor) (*ConSpecialTransactor, error) {
	contract, err := bindConSpecial(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ConSpecialTransactor{contract: contract}, nil
}

// NewConSpecialFilterer creates a new log filterer instance of ConSpecial, bound to a specific deployed contract.
func NewConSpecialFilterer(address common.Address, filterer bind.ContractFilterer) (*ConSpecialFilterer, error) {
	contract, err := bindConSpecial(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ConSpecialFilterer{contract: contract}, nil
}

// bindConSpecial binds a generic wrapper to an already deployed contract.
func bindConSpecial(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ConSpecialABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConSpecial *ConSpecialRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConSpecial.Contract.ConSpecialCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConSpecial *ConSpecialRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConSpecial.Contract.ConSpecialTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConSpecial *ConSpecialRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConSpecial.Contract.ConSpecialTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConSpecial *ConSpecialCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConSpecial.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConSpecial *ConSpecialTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConSpecial.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConSpecial *ConSpecialTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConSpecial.Contract.contract.Transact(opts, method, params...)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConSpecial *ConSpecialCaller) Number(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ConSpecial.contract.Call(opts, out, "number")
	return *ret0, err
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConSpecial *ConSpecialSession) Number() (*big.Int, error) {
	return _ConSpecial.Contract.Number(&_ConSpecial.CallOpts)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConSpecial *ConSpecialCallerSession) Number() (*big.Int, error) {
	return _ConSpecial.Contract.Number(&_ConSpecial.CallOpts)
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConSpecial *ConSpecialTransactor) Increment(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConSpecial.contract.Transact(opts, "increment")
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConSpecial *ConSpecialSession) Increment() (*types.Transaction, error) {
	return _ConSpecial.Contract.Increment(&_ConSpecial.TransactOpts)
}

// Increment is a paid mutator transaction binding the contract method 0xd09de08a.
//
// Solidity: function increment() returns()
func (_ConSpecial *ConSpecialTransactorSession) Increment() (*types.Transaction, error) {
	return _ConSpecial.Contract.Increment(&_ConSpecial.TransactOpts)
}

// ConStorageABI is the input ABI used to generate the binding from.
const ConStorageABI = "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ConStorageBin is the compiled bytecode used for deploying new contracts.
var ConStorageBin = "0x6080604052348015600f57600080fd5b5060056000819055506085806100266000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638381f58a14602d575b600080fd5b60336049565b6040518082815260200191505060405180910390f35b6000548156fea2646970667358221220d59b8f33e2953677e3ee29e350bda117038189e9a95c57620283a0c0620a832564736f6c63430006070033"

// DeployConStorage deploys a new Ethereum contract, binding an instance of ConStorage to it.
func DeployConStorage(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ConStorage, error) {
	parsed, err := abi.JSON(strings.NewReader(ConStorageABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ConStorageBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ConStorage{ConStorageCaller: ConStorageCaller{contract: contract}, ConStorageTransactor: ConStorageTransactor{contract: contract}, ConStorageFilterer: ConStorageFilterer{contract: contract}}, nil
}

// ConStorage is an auto generated Go binding around an Ethereum contract.
type ConStorage struct {
	ConStorageCaller     // Read-only binding to the contract
	ConStorageTransactor // Write-only binding to the contract
	ConStorageFilterer   // Log filterer for contract events
}

// ConStorageCaller is an auto generated read-only Go binding around an Ethereum contract.
type ConStorageCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConStorageTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ConStorageTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConStorageFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ConStorageFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConStorageSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ConStorageSession struct {
	Contract     *ConStorage       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ConStorageCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ConStorageCallerSession struct {
	Contract *ConStorageCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ConStorageTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ConStorageTransactorSession struct {
	Contract     *ConStorageTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ConStorageRaw is an auto generated low-level Go binding around an Ethereum contract.
type ConStorageRaw struct {
	Contract *ConStorage // Generic contract binding to access the raw methods on
}

// ConStorageCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ConStorageCallerRaw struct {
	Contract *ConStorageCaller // Generic read-only contract binding to access the raw methods on
}

// ConStorageTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ConStorageTransactorRaw struct {
	Contract *ConStorageTransactor // Generic write-only contract binding to access the raw methods on
}

// NewConStorage creates a new instance of ConStorage, bound to a specific deployed contract.
func NewConStorage(address common.Address, backend bind.ContractBackend) (*ConStorage, error) {
	contract, err := bindConStorage(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ConStorage{ConStorageCaller: ConStorageCaller{contract: contract}, ConStorageTransactor: ConStorageTransactor{contract: contract}, ConStorageFilterer: ConStorageFilterer{contract: contract}}, nil
}

// NewConStorageCaller creates a new read-only instance of ConStorage, bound to a specific deployed contract.
func NewConStorageCaller(address common.Address, caller bind.ContractCaller) (*ConStorageCaller, error) {
	contract, err := bindConStorage(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ConStorageCaller{contract: contract}, nil
}

// NewConStorageTransactor creates a new write-only instance of ConStorage, bound to a specific deployed contract.
func NewConStorageTransactor(address common.Address, transactor bind.ContractTransactor) (*ConStorageTransactor, error) {
	contract, err := bindConStorage(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ConStorageTransactor{contract: contract}, nil
}

// NewConStorageFilterer creates a new log filterer instance of ConStorage, bound to a specific deployed contract.
func NewConStorageFilterer(address common.Address, filterer bind.ContractFilterer) (*ConStorageFilterer, error) {
	contract, err := bindConStorage(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ConStorageFilterer{contract: contract}, nil
}

// bindConStorage binds a generic wrapper to an already deployed contract.
func bindConStorage(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ConStorageABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConStorage *ConStorageRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConStorage.Contract.ConStorageCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConStorage *ConStorageRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConStorage.Contract.ConStorageTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConStorage *ConStorageRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConStorage.Contract.ConStorageTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConStorage *ConStorageCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConStorage.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConStorage *ConStorageTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConStorage.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConStorage *ConStorageTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConStorage.Contract.contract.Transact(opts, method, params...)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConStorage *ConStorageCaller) Number(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ConStorage.contract.Call(opts, out, "number")
	return *ret0, err
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConStorage *ConStorageSession) Number() (*big.Int, error) {
	return _ConStorage.Contract.Number(&_ConStorage.CallOpts)
}

// Number is a free data retrieval call binding the contract method 0x8381f58a.
//
// Solidity: function number() view returns(uint256)
func (_ConStorage *ConStorageCallerSession) Number() (*big.Int, error) {
	return _ConStorage.Contract.Number(&_ConStorage.CallOpts)
}

// ConbaseTestABI is the input ABI used to generate the binding from.
const ConbaseTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testWeird\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ConbaseTestBin is the compiled bytecode used for deploying new contracts.
var ConbaseTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b5061091b8061003a6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80630957af15146100515780630a9254e41461005b578063ba414fa614610065578063fa7626d414610087575b600080fd5b6100596100a9565b005b610063610287565b005b61006d610351565b604051808215151515815260200191505060405180910390f35b61008f610364565b604051808215151515815260200191505060405180910390f35b610156600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638381f58a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561011457600080fd5b505afa158015610128573d6000803e3d6000fd5b505050506040513d602081101561013e57600080fd5b81019080805190602001909291905050506005610376565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d09de08a6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156101c057600080fd5b505af11580156101d4573d6000803e3d6000fd5b50505050610285600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638381f58a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561024357600080fd5b505afa158015610257573d6000803e3d6000fd5b505050506040513d602081101561026d57600080fd5b81019080805190602001909291905050506006610376565b565b604051610293906104d2565b604051809103906000f0801580156102af573d6000803e3d6000fd5b506040516102bc906104de565b808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050604051809103906000f08015801561030e573d6000803e3d6000fd5b50600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b8082146104b1577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040518080602001828103825260228152602001806108c46022913960400191505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88160405180806020018381526020018281038252600a8152602001807f20204578706563746564000000000000000000000000000000000000000000008152506020019250505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88260405180806020018381526020018281038252600a8152602001807f2020202041637475616c000000000000000000000000000000000000000000008152506020019250505060405180910390a16104b06104b5565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b60c4806104ec83390190565b610314806105b08339019056fe6080604052600560008190555060aa8061001a6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80638381f58a146037578063d09de08a146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600080815480929190600101919050555056fea2646970667358221220e54988f595abbff45881d9331832105fdbfc3c2c3afb5407f1fb3b4bdc2db36964736f6c63430006070033608060405234801561001057600080fd5b506040516103143803806103148339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600560008190555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506102778061009d6000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638381f58a1461003b578063d09de08a14610059575b600080fd5b610043610063565b6040518082815260200191505060405180910390f35b610061610069565b005b60005481565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527fd09de08a000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b6020831061015a5780518252602082019150602081019050602083039250610137565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101ba576040519150601f19603f3d011682016040523d82523d6000602084013e6101bf565b606091505b5050905080610219576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602581526020018061021d6025913960400191505060405180910390fd5b5056fe64656c6567617465642063616c6c206661696c656420666f7220696e6372656d656e742829a2646970667358221220668a96aab18264ac8548447df53cfbd02e5f7756b6f742fc5fb9724add6285a364736f6c634300060700334572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e745da264697066735822122056e235f6b50c5f8dfa6bd226f5dc4941b30762485435b5f5bb8b6db7658a559864736f6c63430006070033"

// DeployConbaseTest deploys a new Ethereum contract, binding an instance of ConbaseTest to it.
func DeployConbaseTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ConbaseTest, error) {
	parsed, err := abi.JSON(strings.NewReader(ConbaseTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ConbaseTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ConbaseTest{ConbaseTestCaller: ConbaseTestCaller{contract: contract}, ConbaseTestTransactor: ConbaseTestTransactor{contract: contract}, ConbaseTestFilterer: ConbaseTestFilterer{contract: contract}}, nil
}

// ConbaseTest is an auto generated Go binding around an Ethereum contract.
type ConbaseTest struct {
	ConbaseTestCaller     // Read-only binding to the contract
	ConbaseTestTransactor // Write-only binding to the contract
	ConbaseTestFilterer   // Log filterer for contract events
}

// ConbaseTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ConbaseTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConbaseTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ConbaseTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConbaseTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ConbaseTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConbaseTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ConbaseTestSession struct {
	Contract     *ConbaseTest      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ConbaseTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ConbaseTestCallerSession struct {
	Contract *ConbaseTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ConbaseTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ConbaseTestTransactorSession struct {
	Contract     *ConbaseTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ConbaseTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ConbaseTestRaw struct {
	Contract *ConbaseTest // Generic contract binding to access the raw methods on
}

// ConbaseTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ConbaseTestCallerRaw struct {
	Contract *ConbaseTestCaller // Generic read-only contract binding to access the raw methods on
}

// ConbaseTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ConbaseTestTransactorRaw struct {
	Contract *ConbaseTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewConbaseTest creates a new instance of ConbaseTest, bound to a specific deployed contract.
func NewConbaseTest(address common.Address, backend bind.ContractBackend) (*ConbaseTest, error) {
	contract, err := bindConbaseTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ConbaseTest{ConbaseTestCaller: ConbaseTestCaller{contract: contract}, ConbaseTestTransactor: ConbaseTestTransactor{contract: contract}, ConbaseTestFilterer: ConbaseTestFilterer{contract: contract}}, nil
}

// NewConbaseTestCaller creates a new read-only instance of ConbaseTest, bound to a specific deployed contract.
func NewConbaseTestCaller(address common.Address, caller bind.ContractCaller) (*ConbaseTestCaller, error) {
	contract, err := bindConbaseTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ConbaseTestCaller{contract: contract}, nil
}

// NewConbaseTestTransactor creates a new write-only instance of ConbaseTest, bound to a specific deployed contract.
func NewConbaseTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ConbaseTestTransactor, error) {
	contract, err := bindConbaseTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ConbaseTestTransactor{contract: contract}, nil
}

// NewConbaseTestFilterer creates a new log filterer instance of ConbaseTest, bound to a specific deployed contract.
func NewConbaseTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ConbaseTestFilterer, error) {
	contract, err := bindConbaseTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ConbaseTestFilterer{contract: contract}, nil
}

// bindConbaseTest binds a generic wrapper to an already deployed contract.
func bindConbaseTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ConbaseTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConbaseTest *ConbaseTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConbaseTest.Contract.ConbaseTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConbaseTest *ConbaseTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConbaseTest.Contract.ConbaseTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConbaseTest *ConbaseTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConbaseTest.Contract.ConbaseTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ConbaseTest *ConbaseTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ConbaseTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ConbaseTest *ConbaseTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConbaseTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ConbaseTest *ConbaseTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ConbaseTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ConbaseTest *ConbaseTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ConbaseTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ConbaseTest *ConbaseTestSession) ISTEST() (bool, error) {
	return _ConbaseTest.Contract.ISTEST(&_ConbaseTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ConbaseTest *ConbaseTestCallerSession) ISTEST() (bool, error) {
	return _ConbaseTest.Contract.ISTEST(&_ConbaseTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ConbaseTest *ConbaseTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ConbaseTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ConbaseTest *ConbaseTestSession) Failed() (bool, error) {
	return _ConbaseTest.Contract.Failed(&_ConbaseTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ConbaseTest *ConbaseTestCallerSession) Failed() (bool, error) {
	return _ConbaseTest.Contract.Failed(&_ConbaseTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ConbaseTest *ConbaseTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConbaseTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ConbaseTest *ConbaseTestSession) SetUp() (*types.Transaction, error) {
	return _ConbaseTest.Contract.SetUp(&_ConbaseTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ConbaseTest *ConbaseTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ConbaseTest.Contract.SetUp(&_ConbaseTest.TransactOpts)
}

// TestWeird is a paid mutator transaction binding the contract method 0x0957af15.
//
// Solidity: function testWeird() returns()
func (_ConbaseTest *ConbaseTestTransactor) TestWeird(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ConbaseTest.contract.Transact(opts, "testWeird")
}

// TestWeird is a paid mutator transaction binding the contract method 0x0957af15.
//
// Solidity: function testWeird() returns()
func (_ConbaseTest *ConbaseTestSession) TestWeird() (*types.Transaction, error) {
	return _ConbaseTest.Contract.TestWeird(&_ConbaseTest.TransactOpts)
}

// TestWeird is a paid mutator transaction binding the contract method 0x0957af15.
//
// Solidity: function testWeird() returns()
func (_ConbaseTest *ConbaseTestTransactorSession) TestWeird() (*types.Transaction, error) {
	return _ConbaseTest.Contract.TestWeird(&_ConbaseTest.TransactOpts)
}

// ConbaseTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ConbaseTest contract.
type ConbaseTestLogIterator struct {
	Event *ConbaseTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLog represents a Log event raised by the ConbaseTest contract.
type ConbaseTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLog(opts *bind.FilterOpts) (*ConbaseTestLogIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogIterator{contract: _ConbaseTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ConbaseTestLog) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLog)
				if err := _ConbaseTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLog(log types.Log) (*ConbaseTestLog, error) {
	event := new(ConbaseTestLog)
	if err := _ConbaseTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ConbaseTest contract.
type ConbaseTestLogAddressIterator struct {
	Event *ConbaseTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogAddress represents a LogAddress event raised by the ConbaseTest contract.
type ConbaseTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ConbaseTestLogAddressIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogAddressIterator{contract: _ConbaseTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogAddress)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogAddress(log types.Log) (*ConbaseTestLogAddress, error) {
	event := new(ConbaseTestLogAddress)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ConbaseTest contract.
type ConbaseTestLogBytesIterator struct {
	Event *ConbaseTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogBytes represents a LogBytes event raised by the ConbaseTest contract.
type ConbaseTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ConbaseTestLogBytesIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogBytesIterator{contract: _ConbaseTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogBytes)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogBytes(log types.Log) (*ConbaseTestLogBytes, error) {
	event := new(ConbaseTestLogBytes)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ConbaseTest contract.
type ConbaseTestLogBytes32Iterator struct {
	Event *ConbaseTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogBytes32 represents a LogBytes32 event raised by the ConbaseTest contract.
type ConbaseTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ConbaseTestLogBytes32Iterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogBytes32Iterator{contract: _ConbaseTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogBytes32)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogBytes32(log types.Log) (*ConbaseTestLogBytes32, error) {
	event := new(ConbaseTestLogBytes32)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ConbaseTest contract.
type ConbaseTestLogIntIterator struct {
	Event *ConbaseTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogInt represents a LogInt event raised by the ConbaseTest contract.
type ConbaseTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ConbaseTestLogIntIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogIntIterator{contract: _ConbaseTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogInt)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogInt(log types.Log) (*ConbaseTestLogInt, error) {
	event := new(ConbaseTestLogInt)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ConbaseTest contract.
type ConbaseTestLogNamedAddressIterator struct {
	Event *ConbaseTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedAddress represents a LogNamedAddress event raised by the ConbaseTest contract.
type ConbaseTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ConbaseTestLogNamedAddressIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedAddressIterator{contract: _ConbaseTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedAddress)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedAddress(log types.Log) (*ConbaseTestLogNamedAddress, error) {
	event := new(ConbaseTestLogNamedAddress)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ConbaseTest contract.
type ConbaseTestLogNamedBytesIterator struct {
	Event *ConbaseTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedBytes represents a LogNamedBytes event raised by the ConbaseTest contract.
type ConbaseTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ConbaseTestLogNamedBytesIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedBytesIterator{contract: _ConbaseTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedBytes)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedBytes(log types.Log) (*ConbaseTestLogNamedBytes, error) {
	event := new(ConbaseTestLogNamedBytes)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ConbaseTest contract.
type ConbaseTestLogNamedBytes32Iterator struct {
	Event *ConbaseTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ConbaseTest contract.
type ConbaseTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ConbaseTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedBytes32Iterator{contract: _ConbaseTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedBytes32)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedBytes32(log types.Log) (*ConbaseTestLogNamedBytes32, error) {
	event := new(ConbaseTestLogNamedBytes32)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ConbaseTest contract.
type ConbaseTestLogNamedDecimalIntIterator struct {
	Event *ConbaseTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ConbaseTest contract.
type ConbaseTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ConbaseTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedDecimalIntIterator{contract: _ConbaseTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedDecimalInt)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ConbaseTestLogNamedDecimalInt, error) {
	event := new(ConbaseTestLogNamedDecimalInt)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ConbaseTest contract.
type ConbaseTestLogNamedDecimalUintIterator struct {
	Event *ConbaseTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ConbaseTest contract.
type ConbaseTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ConbaseTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedDecimalUintIterator{contract: _ConbaseTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedDecimalUint)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ConbaseTestLogNamedDecimalUint, error) {
	event := new(ConbaseTestLogNamedDecimalUint)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ConbaseTest contract.
type ConbaseTestLogNamedIntIterator struct {
	Event *ConbaseTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedInt represents a LogNamedInt event raised by the ConbaseTest contract.
type ConbaseTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ConbaseTestLogNamedIntIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedIntIterator{contract: _ConbaseTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedInt)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedInt(log types.Log) (*ConbaseTestLogNamedInt, error) {
	event := new(ConbaseTestLogNamedInt)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ConbaseTest contract.
type ConbaseTestLogNamedStringIterator struct {
	Event *ConbaseTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedString represents a LogNamedString event raised by the ConbaseTest contract.
type ConbaseTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ConbaseTestLogNamedStringIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedStringIterator{contract: _ConbaseTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedString)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedString(log types.Log) (*ConbaseTestLogNamedString, error) {
	event := new(ConbaseTestLogNamedString)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ConbaseTest contract.
type ConbaseTestLogNamedUintIterator struct {
	Event *ConbaseTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogNamedUint represents a LogNamedUint event raised by the ConbaseTest contract.
type ConbaseTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ConbaseTestLogNamedUintIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogNamedUintIterator{contract: _ConbaseTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogNamedUint)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogNamedUint(log types.Log) (*ConbaseTestLogNamedUint, error) {
	event := new(ConbaseTestLogNamedUint)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ConbaseTest contract.
type ConbaseTestLogStringIterator struct {
	Event *ConbaseTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogString represents a LogString event raised by the ConbaseTest contract.
type ConbaseTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ConbaseTestLogStringIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogStringIterator{contract: _ConbaseTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogString) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogString)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogString(log types.Log) (*ConbaseTestLogString, error) {
	event := new(ConbaseTestLogString)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ConbaseTest contract.
type ConbaseTestLogUintIterator struct {
	Event *ConbaseTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogUint represents a LogUint event raised by the ConbaseTest contract.
type ConbaseTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ConbaseTestLogUintIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogUintIterator{contract: _ConbaseTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogUint)
				if err := _ConbaseTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogUint(log types.Log) (*ConbaseTestLogUint, error) {
	event := new(ConbaseTestLogUint)
	if err := _ConbaseTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConbaseTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ConbaseTest contract.
type ConbaseTestLogsIterator struct {
	Event *ConbaseTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ConbaseTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ConbaseTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ConbaseTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ConbaseTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ConbaseTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ConbaseTestLogs represents a Logs event raised by the ConbaseTest contract.
type ConbaseTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ConbaseTestLogsIterator, error) {

	logs, sub, err := _ConbaseTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ConbaseTestLogsIterator{contract: _ConbaseTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ConbaseTestLogs) (event.Subscription, error) {

	logs, sub, err := _ConbaseTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ConbaseTestLogs)
				if err := _ConbaseTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ConbaseTest *ConbaseTestFilterer) ParseLogs(log types.Log) (*ConbaseTestLogs, error) {
	event := new(ConbaseTestLogs)
	if err := _ConbaseTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ConstantsABI is the input ABI used to generate the binding from.
const ConstantsABI = "[]"

// ConstantsBin is the compiled bytecode used for deploying new contracts.
var ConstantsBin = "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122041240837cb4cf304472b05c9b5e06da0629d3768f83dbf32e68a9f5df8b9786364736f6c63430006070033"

// DeployConstants deploys a new Ethereum contract, binding an instance of Constants to it.
func DeployConstants(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Constants, error) {
	parsed, err := abi.JSON(strings.NewReader(ConstantsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ConstantsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Constants{ConstantsCaller: ConstantsCaller{contract: contract}, ConstantsTransactor: ConstantsTransactor{contract: contract}, ConstantsFilterer: ConstantsFilterer{contract: contract}}, nil
}

// Constants is an auto generated Go binding around an Ethereum contract.
type Constants struct {
	ConstantsCaller     // Read-only binding to the contract
	ConstantsTransactor // Write-only binding to the contract
	ConstantsFilterer   // Log filterer for contract events
}

// ConstantsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ConstantsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConstantsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ConstantsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConstantsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ConstantsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ConstantsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ConstantsSession struct {
	Contract     *Constants        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ConstantsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ConstantsCallerSession struct {
	Contract *ConstantsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ConstantsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ConstantsTransactorSession struct {
	Contract     *ConstantsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ConstantsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ConstantsRaw struct {
	Contract *Constants // Generic contract binding to access the raw methods on
}

// ConstantsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ConstantsCallerRaw struct {
	Contract *ConstantsCaller // Generic read-only contract binding to access the raw methods on
}

// ConstantsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ConstantsTransactorRaw struct {
	Contract *ConstantsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewConstants creates a new instance of Constants, bound to a specific deployed contract.
func NewConstants(address common.Address, backend bind.ContractBackend) (*Constants, error) {
	contract, err := bindConstants(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Constants{ConstantsCaller: ConstantsCaller{contract: contract}, ConstantsTransactor: ConstantsTransactor{contract: contract}, ConstantsFilterer: ConstantsFilterer{contract: contract}}, nil
}

// NewConstantsCaller creates a new read-only instance of Constants, bound to a specific deployed contract.
func NewConstantsCaller(address common.Address, caller bind.ContractCaller) (*ConstantsCaller, error) {
	contract, err := bindConstants(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ConstantsCaller{contract: contract}, nil
}

// NewConstantsTransactor creates a new write-only instance of Constants, bound to a specific deployed contract.
func NewConstantsTransactor(address common.Address, transactor bind.ContractTransactor) (*ConstantsTransactor, error) {
	contract, err := bindConstants(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ConstantsTransactor{contract: contract}, nil
}

// NewConstantsFilterer creates a new log filterer instance of Constants, bound to a specific deployed contract.
func NewConstantsFilterer(address common.Address, filterer bind.ContractFilterer) (*ConstantsFilterer, error) {
	contract, err := bindConstants(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ConstantsFilterer{contract: contract}, nil
}

// bindConstants binds a generic wrapper to an already deployed contract.
func bindConstants(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ConstantsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Constants *ConstantsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Constants.Contract.ConstantsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Constants *ConstantsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Constants.Contract.ConstantsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Constants *ConstantsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Constants.Contract.ConstantsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Constants *ConstantsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Constants.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Constants *ConstantsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Constants.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Constants *ConstantsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Constants.Contract.contract.Transact(opts, method, params...)
}

// CryptoABI is the input ABI used to generate the binding from.
const CryptoABI = "[{\"inputs\":[{\"internalType\":\"uint256[2][]\",\"name\":\"sigs\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[]\",\"name\":\"indices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"invArray\",\"type\":\"uint256[]\"}],\"name\":\"AggregateSignatures\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"HashToG1\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"h\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"privK\",\"type\":\"uint256\"}],\"name\":\"Sign\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"sig\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256[2]\",\"name\":\"sig\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[4]\",\"name\":\"pubK\",\"type\":\"uint256[4]\"}],\"name\":\"Verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"v\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"input\",\"type\":\"uint256[4]\"}],\"name\":\"bn128_add\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"result\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"point\",\"type\":\"uint256[2]\"}],\"name\":\"bn128_is_on_curve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"input\",\"type\":\"uint256[3]\"}],\"name\":\"bn128_multiply\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"result\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"honestIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dishonestIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"checkIndices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validIndices\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"invArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"checkInverses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"x1\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"y1\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"x2\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"y2\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"proof\",\"type\":\"uint256[2]\"}],\"name\":\"dleq_verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"proof_is_valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"input\",\"type\":\"uint256[2]\"}],\"name\":\"safeSigningPoint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]"

// CryptoBin is the compiled bytecode used for deploying new contracts.
var CryptoBin = "0x608060405234801561001057600080fd5b50612a61806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806396d95a6f1161007157806396d95a6f1461060a578063e480a92e14610687578063e664725b14610761578063e81ee0e314610802578063f022e06114610984578063f4d7d33d14610be6576100a9565b806306367587146100ae5780636bdf477c1461020357806380f4a9221461030457806382688f141461047257806395add79c14610513575b600080fd5b6101e9600480360360e08110156100c457600080fd5b81019080803590602001906401000000008111156100e157600080fd5b8201836020820111156100f357600080fd5b8035906020019184600183028401116401000000008311171561011557600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f8201169050808301925050505050509192919290505050610c63565b604051808215151515815260200191505060405180910390f35b6102c66004803603604081101561021957600080fd5b810190808035906020019064010000000081111561023657600080fd5b82018360208201111561024857600080fd5b8035906020019184600183028401116401000000008311171561026a57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050610de4565b6040518082600260200280838360005b838110156102f15780820151818401526020810190506102d6565b5050505090500191505060405180910390f35b6104586004803603606081101561031a57600080fd5b810190808035906020019064010000000081111561033757600080fd5b82018360208201111561034957600080fd5b8035906020019184602083028401116401000000008311171561036b57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050509192919290803590602001906401000000008111156103cb57600080fd5b8201836020820111156103dd57600080fd5b803590602001918460208302840111640100000000831117156103ff57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050610e4d565b604051808215151515815260200191505060405180910390f35b6104d56004803603606081101561048857600080fd5b8101908080606001906003806020026040519081016040528092919082600360200280828437600081840152601f19601f8201169050808301925050505050509192919290505050610f70565b6040518082600260200280838360005b838110156105005780820151818401526020810190506104e5565b5050505090500191505060405180910390f35b6105cc6004803603602081101561052957600080fd5b810190808035906020019064010000000081111561054657600080fd5b82018360208201111561055857600080fd5b8035906020019184600183028401116401000000008311171561057a57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050610fe4565b6040518082600260200280838360005b838110156105f75780820151818401526020810190506105dc565b5050505090500191505060405180910390f35b61066d6004803603604081101561062057600080fd5b8101908080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f8201169050808301925050505050509192919290505050611174565b604051808215151515815260200191505060405180910390f35b6107476004803603604081101561069d57600080fd5b81019080803590602001906401000000008111156106ba57600080fd5b8201836020820111156106cc57600080fd5b803590602001918460208302840111640100000000831117156106ee57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050509192919290803590602001909291905050506111be565b604051808215151515815260200191505060405180910390f35b6107c46004803603608081101561077757600080fd5b8101908080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f82011690508083019250505050505091929192905050506112a5565b6040518082600260200280838360005b838110156107ef5780820151818401526020810190506107d4565b5050505090500191505060405180910390f35b61096a600480360361014081101561081957600080fd5b8101908080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f8201169050808301925050505050509192919290505050611336565b604051808215151515815260200191505060405180910390f35b610ba86004803603608081101561099a57600080fd5b81019080803590602001906401000000008111156109b757600080fd5b8201836020820111156109c957600080fd5b803590602001918460408302840111640100000000831117156109eb57600080fd5b9190808060200260200160405190810160405280939291908181526020016000905b82821015610a64578484839050604002016002806020026040519081016040528092919082600260200280828437600081840152601f19601f82011690508083019250505050505081526020019060010190610a0d565b5050505050919291929080359060200190640100000000811115610a8757600080fd5b820183602082011115610a9957600080fd5b80359060200191846020830284011164010000000083111715610abb57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019092919080359060200190640100000000811115610b2557600080fd5b820183602082011115610b3757600080fd5b80359060200191846020830284011164010000000083111715610b5957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050509192919290505050611700565b6040518082600260200280838360005b83811015610bd3578082015181840152602081019050610bb8565b5050505090500191505060405180910390f35b610c4960048036036040811015610bfc57600080fd5b8101908080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929050505061184a565b604051808215151515815260200191505060405180910390f35b6000610c6d61280f565b610c7685610fe4565b9050610dda60405180610180016040528086600060028110610c9457fe5b6020020151815260200186600160028110610cab57fe5b602002015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d815260200183600060028110610d5a57fe5b6020020151815260200183600160028110610d7157fe5b6020020151815260200185600060048110610d8857fe5b6020020151815260200185600160048110610d9f57fe5b6020020151815260200185600260048110610db657fe5b6020020151815260200185600360048110610dcd57fe5b6020020151815250611954565b9150509392505050565b610dec61280f565b610df461280f565b610dfd84610fe4565b9050610e44604051806060016040528083600060028110610e1a57fe5b6020020151815260200183600160028110610e3157fe5b6020020151815260200185815250610f70565b91505092915050565b6000600190506000806000808511610e6157fe5b6101008510610e6c57fe5b600092505b8651831015610edf57868381518110610e8657fe5b602002602001015190506000811480610e9e57508481115b15610eac5760009350610edf565b6000816001901b83161415610ec957806001901b82179150610ed2565b60009350610edf565b8280600101935050610e71565b83610eef57839350505050610f69565b600092505b8551831015610f6257858381518110610f0957fe5b602002602001015190506000811480610f2157508481115b15610f2f5760009350610f62565b6000816001901b83161415610f4c57806001901b82179150610f55565b60009350610f62565b8280600101935050610ef4565b8393505050505b9392505050565b610f7861280f565b60006040826060856007600019fa905080610fde576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526024815260200180612a086024913960400191505060405180910390fd5b50919050565b610fec61280f565b600061100183600060f81b600160f81b611a00565b9050600061101884600260f81b600360f81b611a00565b905061102261280f565b61102b83611c0b565b905061103561280f565b61103e83611c0b565b90506110ad60405180608001604052808460006002811061105b57fe5b602002015181526020018460016002811061107257fe5b602002015181526020018360006002811061108957fe5b60200201518152602001836001600281106110a057fe5b60200201518152506112a5565b94506110b88561184a565b61110d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260298152602001806128546029913960400191505060405180910390fd5b61111685611174565b61116b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180612975602a913960400191505060405180910390fd5b50505050919050565b6000808260006002811061118457fe5b602002015114806111a6575060018260006002811061119f57fe5b6020020151145b156111b457600090506111b9565b600190505b919050565b6000806000806000600190508651600187031115611227576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252604481526020018061287d6044913960600191505060405180910390fd5b600193505b858410156112985786600185038151811061124357fe5b602002602001015192507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061127557fe5b83850991506001821461128b5760009050611298565b838060010194505061122c565b8094505050505092915050565b6112ad61280f565b60006040826080856006600019fa905080611330576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f656c6c6970746963206375727665206164646974696f6e206661696c6564000081525060200191505060405180910390fd5b50919050565b600061134061280f565b61134861280f565b61139e60405180606001604052808a60006002811061136357fe5b602002015181526020018a60016002811061137a57fe5b602002015181526020018660016002811061139157fe5b6020020151815250610f70565b91506113f66040518060600160405280896000600281106113bb57fe5b60200201518152602001896001600281106113d257fe5b60200201518152602001866000600281106113e957fe5b6020020151815250610f70565b905061140061280f565b61146d60405180608001604052808560006002811061141b57fe5b602002015181526020018560016002811061143257fe5b602002015181526020018460006002811061144957fe5b602002015181526020018460016002811061146057fe5b60200201518152506112a5565b90506114c560405180606001604052808960006002811061148a57fe5b60200201518152602001896001600281106114a157fe5b60200201518152602001876001600281106114b857fe5b6020020151815250610f70565b925061151d6040518060600160405280886000600281106114e257fe5b60200201518152602001886001600281106114f957fe5b602002015181526020018760006002811061151057fe5b6020020151815250610f70565b915061152761280f565b61159460405180608001604052808660006002811061154257fe5b602002015181526020018660016002811061155957fe5b602002015181526020018560006002811061157057fe5b602002015181526020018560016002811061158757fe5b60200201518152506112a5565b905060008a8a8a8a86866040516020018087600260200280838360005b838110156115cc5780820151818401526020810190506115b1565b5050505090500186600260200280838360005b838110156115fa5780820151818401526020810190506115df565b5050505090500185600260200280838360005b8381101561162857808201518184015260208101905061160d565b5050505090500184600260200280838360005b8381101561165657808201518184015260208101905061163b565b5050505090500183600260200280838360005b83811015611684578082015181840152602081019050611669565b5050505090500182600260200280838360005b838110156116b2578082015181840152602081019050611697565b5050505090500196505050505050506040516020818303038152906040528051906020012060001c9050866000600281106116e957fe5b602002015181149550505050505095945050505050565b61170861280f565b8351855114611762576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603581526020018061299f6035913960400191505060405180910390fd5b828551116117bb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603a8152602001806128e5603a913960400191505060405180910390fd5b60006117c6856121d6565b90506117d283826111be565b611827576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a81526020018061291f602a913960400191505060405180910390fd5b61182f61280f565b61183b8787878761223c565b90508092505050949350505050565b60007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061187457fe5b60037f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061189e57fe5b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47806118c657fe5b856000600281106118d357fe5b6020020151866000600281106118e557fe5b602002015109856000600281106118f857fe5b602002015109087f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061192757fe5b8360016002811061193457fe5b60200201518460016002811061194657fe5b602002015109149050919050565b600061195e612831565b6000602082610180866008600019fa9050806119e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f656c6c69707469632063757276652070616972696e67206661696c656400000081525060200191505060405180910390fd5b6001826000600181106119f157fe5b60200201511492505050919050565b600080838560405160200180837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260010182805190602001908083835b60208310611a855780518252602082019150602081019050602083039250611a62565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040528051906020012060001c90506000838660405160200180837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260010182805190602001908083835b60208310611b4a5780518252602082019150602081019050602083039250611b27565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040528051906020012060001c90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611bb357fe5b817f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611bdc57fe5b7f0e0a77c19a07df2f666ea36f7879462c0a78eb28f5c70b3dd35d438dc58f0d9d850908925050509392505050565b611c1361280f565b60008060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611c4057fe5b85860992507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611c6d57fe5b6004840891507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611c9b57fe5b8284099050611ca98161248e565b905060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611cd557fe5b83840990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611d0257fe5b83820990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611d2f57fe5b848509935060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611d5e57fe5b8577b3c4d79d41a91759a9e4c7e359b6b89eaec68e62effffffd0990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611da357fe5b8382099050611db1816124e2565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611ddb57fe5b7759e26bcea0d48bacd4f263f1acdb5c4f5763473177fffffe8208905060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611e2257fe5b600183089050611e31816124e2565b905060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611e5d57fe5b847f2042def740cbc01bd03583cf0100e593ba56470b9af68708d2c05d64905353850990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611eaa57fe5b8582099050611eb8816124e2565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611ee257fe5b60018208905060007f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611f1257fe5b84850990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611f3f57fe5b84820990507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611f6c57fe5b6003820890506000611f7d82612520565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611fa757fe5b84850991507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780611fd457fe5b84830991507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061200157fe5b600383089150600061201283612520565b90506000600160046003840360018603028161202a57fe5b050190506000600182141561204157879050612057565b600282141561205257869050612056565b8590505b5b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061207f57fe5b81820994507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47806120ac57fe5b81860994507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47806120d957fe5b6003860894506120e885612593565b945060006120f58f6125e7565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478061211f57fe5b818709955061214160405180604001604052808481526020018881525061184a565b612196576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806128c16024913960400191505060405180910390fd5b818e6000600281106121a457fe5b602002018181525050858e6001600281106121bb57fe5b60200201818152505050505050505050505050505050919050565b6000806000836000815181106121e857fe5b602002602001015190506000600190505b84518110156122315784818151811061220e57fe5b6020026020010151925081831115612224578291505b80806001019150506121f9565b508092505050919050565b61224461280f565b835185511461229e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602c815260200180612949602c913960400191505060405180910390fd5b6122a661280f565b6000816000600281106122b557fe5b6020020181815250506000816001600281106122cd57fe5b6020020181815250506000806000806000806122e761280f565b600096505b8b5187101561247b578b878151811061230157fe5b602002602001015194508a8711156123185761247b565b60019250600095505b8b518610156123a2578b868151811061233657fe5b602002602001015193508a86111561234d576123a2565b8484141561235a57612395565b61236584868c61263e565b91507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061238f57fe5b82840992505b8580600101965050612321565b8c87815181106123ae57fe5b602002602001015190506123fd6040518060600160405280836000600281106123d357fe5b60200201518152602001836001600281106123ea57fe5b6020020151815260200185815250610f70565b905061246c60405180608001604052808a60006002811061241a57fe5b602002015181526020018a60016002811061243157fe5b602002015181526020018360006002811061244857fe5b602002015181526020018360016002811061245f57fe5b60200201518152506112a5565b975086806001019750506122ec565b8798505050505050505050949350505050565b60006124db827f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd457f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4761275a565b9050919050565b6000808214156124f5576000905061251b565b817f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd470390505b919050565b60008061256e837f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea37f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4761275a565b90506000811461258857600180821660020203915061258d565b600091505b50919050565b60006125e0827f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4761275a565b9050919050565b6000600190507f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea3821115612639577f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4690505b919050565b600082841415612699576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260348152602001806129d46034913960400191505060405180910390fd5b60008490506000848611156126b2578486039050612708565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001806126da57fe5b60017f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001038309915085850390505b83600182038151811061271757fe5b602002602001015190507f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061274957fe5b818309905080925050509392505050565b60008060405160208152602080820152602060408201528560608201528460808201528360a082015260208160c08360055afa9150805192505080612807576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f6d6f64756c6172206578706f6e656e74696174696f6e2066616c69656400000081525060200191505060405180910390fd5b509392505050565b6040518060400160405280600290602082028036833780820191505090505090565b604051806020016040528060019060208202803683378082019150509050509056fe496e76616c6964206861736820706f696e743a206e6f74206f6e20656c6c6970746963206375727665636865636b496e7665727365733a20696e73756666696369656e7420696e76657273657320666f722067726f7570207369676e61747572652063616c63756c6174696f6e496e76616c696420706f696e743a206e6f74206f6e20656c6c69707469632063757276654661696c656420746f206d656574207265717569726564206e756d626572206f66207369676e61747572657320666f72207468726573686f6c64696e76417272617920646f6573206e6f7420696e636c75646520636f727265637420696e7665727365734d69736d61746368206265747765656e20706f696e7473473120616e6420696e64696365732061727261797344616e6765726f7573206861736820706f696e743a206e6f74207361666520666f72207369676e696e674d69736d61746368206265747765656e206c656e677468206f66207369676e61747572657320616e6420696e6465782061727261794d7573742068617665206b20213d206a207768656e20636f6d707574696e6720526a207061727469616c20636f6e7374616e7473656c6c6970746963206375727665206d756c7469706c69636174696f6e206661696c6564a264697066735822122054a5530d2b444eab6f6bc9ce3d4dbef60bb49061f05489048daf907ac76ece1a64736f6c63430006070033"

// DeployCrypto deploys a new Ethereum contract, binding an instance of Crypto to it.
func DeployCrypto(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Crypto, error) {
	parsed, err := abi.JSON(strings.NewReader(CryptoABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CryptoBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Crypto{CryptoCaller: CryptoCaller{contract: contract}, CryptoTransactor: CryptoTransactor{contract: contract}, CryptoFilterer: CryptoFilterer{contract: contract}}, nil
}

// Crypto is an auto generated Go binding around an Ethereum contract.
type Crypto struct {
	CryptoCaller     // Read-only binding to the contract
	CryptoTransactor // Write-only binding to the contract
	CryptoFilterer   // Log filterer for contract events
}

// CryptoCaller is an auto generated read-only Go binding around an Ethereum contract.
type CryptoCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CryptoTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CryptoTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CryptoFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CryptoFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CryptoSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CryptoSession struct {
	Contract     *Crypto           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CryptoCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CryptoCallerSession struct {
	Contract *CryptoCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// CryptoTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CryptoTransactorSession struct {
	Contract     *CryptoTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CryptoRaw is an auto generated low-level Go binding around an Ethereum contract.
type CryptoRaw struct {
	Contract *Crypto // Generic contract binding to access the raw methods on
}

// CryptoCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CryptoCallerRaw struct {
	Contract *CryptoCaller // Generic read-only contract binding to access the raw methods on
}

// CryptoTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CryptoTransactorRaw struct {
	Contract *CryptoTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCrypto creates a new instance of Crypto, bound to a specific deployed contract.
func NewCrypto(address common.Address, backend bind.ContractBackend) (*Crypto, error) {
	contract, err := bindCrypto(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Crypto{CryptoCaller: CryptoCaller{contract: contract}, CryptoTransactor: CryptoTransactor{contract: contract}, CryptoFilterer: CryptoFilterer{contract: contract}}, nil
}

// NewCryptoCaller creates a new read-only instance of Crypto, bound to a specific deployed contract.
func NewCryptoCaller(address common.Address, caller bind.ContractCaller) (*CryptoCaller, error) {
	contract, err := bindCrypto(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CryptoCaller{contract: contract}, nil
}

// NewCryptoTransactor creates a new write-only instance of Crypto, bound to a specific deployed contract.
func NewCryptoTransactor(address common.Address, transactor bind.ContractTransactor) (*CryptoTransactor, error) {
	contract, err := bindCrypto(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CryptoTransactor{contract: contract}, nil
}

// NewCryptoFilterer creates a new log filterer instance of Crypto, bound to a specific deployed contract.
func NewCryptoFilterer(address common.Address, filterer bind.ContractFilterer) (*CryptoFilterer, error) {
	contract, err := bindCrypto(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CryptoFilterer{contract: contract}, nil
}

// bindCrypto binds a generic wrapper to an already deployed contract.
func bindCrypto(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CryptoABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Crypto *CryptoRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Crypto.Contract.CryptoCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Crypto *CryptoRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Crypto.Contract.CryptoTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Crypto *CryptoRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Crypto.Contract.CryptoTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Crypto *CryptoCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Crypto.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Crypto *CryptoTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Crypto.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Crypto *CryptoTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Crypto.Contract.contract.Transact(opts, method, params...)
}

// AggregateSignatures is a free data retrieval call binding the contract method 0xf022e061.
//
// Solidity: function AggregateSignatures(uint256[2][] sigs, uint256[] indices, uint256 threshold, uint256[] invArray) view returns(uint256[2])
func (_Crypto *CryptoCaller) AggregateSignatures(opts *bind.CallOpts, sigs [][2]*big.Int, indices []*big.Int, threshold *big.Int, invArray []*big.Int) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "AggregateSignatures", sigs, indices, threshold, invArray)
	return *ret0, err
}

// AggregateSignatures is a free data retrieval call binding the contract method 0xf022e061.
//
// Solidity: function AggregateSignatures(uint256[2][] sigs, uint256[] indices, uint256 threshold, uint256[] invArray) view returns(uint256[2])
func (_Crypto *CryptoSession) AggregateSignatures(sigs [][2]*big.Int, indices []*big.Int, threshold *big.Int, invArray []*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.AggregateSignatures(&_Crypto.CallOpts, sigs, indices, threshold, invArray)
}

// AggregateSignatures is a free data retrieval call binding the contract method 0xf022e061.
//
// Solidity: function AggregateSignatures(uint256[2][] sigs, uint256[] indices, uint256 threshold, uint256[] invArray) view returns(uint256[2])
func (_Crypto *CryptoCallerSession) AggregateSignatures(sigs [][2]*big.Int, indices []*big.Int, threshold *big.Int, invArray []*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.AggregateSignatures(&_Crypto.CallOpts, sigs, indices, threshold, invArray)
}

// HashToG1 is a free data retrieval call binding the contract method 0x95add79c.
//
// Solidity: function HashToG1(bytes message) view returns(uint256[2] h)
func (_Crypto *CryptoCaller) HashToG1(opts *bind.CallOpts, message []byte) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "HashToG1", message)
	return *ret0, err
}

// HashToG1 is a free data retrieval call binding the contract method 0x95add79c.
//
// Solidity: function HashToG1(bytes message) view returns(uint256[2] h)
func (_Crypto *CryptoSession) HashToG1(message []byte) ([2]*big.Int, error) {
	return _Crypto.Contract.HashToG1(&_Crypto.CallOpts, message)
}

// HashToG1 is a free data retrieval call binding the contract method 0x95add79c.
//
// Solidity: function HashToG1(bytes message) view returns(uint256[2] h)
func (_Crypto *CryptoCallerSession) HashToG1(message []byte) ([2]*big.Int, error) {
	return _Crypto.Contract.HashToG1(&_Crypto.CallOpts, message)
}

// Sign is a free data retrieval call binding the contract method 0x6bdf477c.
//
// Solidity: function Sign(bytes message, uint256 privK) view returns(uint256[2] sig)
func (_Crypto *CryptoCaller) Sign(opts *bind.CallOpts, message []byte, privK *big.Int) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "Sign", message, privK)
	return *ret0, err
}

// Sign is a free data retrieval call binding the contract method 0x6bdf477c.
//
// Solidity: function Sign(bytes message, uint256 privK) view returns(uint256[2] sig)
func (_Crypto *CryptoSession) Sign(message []byte, privK *big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Sign(&_Crypto.CallOpts, message, privK)
}

// Sign is a free data retrieval call binding the contract method 0x6bdf477c.
//
// Solidity: function Sign(bytes message, uint256 privK) view returns(uint256[2] sig)
func (_Crypto *CryptoCallerSession) Sign(message []byte, privK *big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Sign(&_Crypto.CallOpts, message, privK)
}

// Verify is a free data retrieval call binding the contract method 0x06367587.
//
// Solidity: function Verify(bytes message, uint256[2] sig, uint256[4] pubK) view returns(bool v)
func (_Crypto *CryptoCaller) Verify(opts *bind.CallOpts, message []byte, sig [2]*big.Int, pubK [4]*big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "Verify", message, sig, pubK)
	return *ret0, err
}

// Verify is a free data retrieval call binding the contract method 0x06367587.
//
// Solidity: function Verify(bytes message, uint256[2] sig, uint256[4] pubK) view returns(bool v)
func (_Crypto *CryptoSession) Verify(message []byte, sig [2]*big.Int, pubK [4]*big.Int) (bool, error) {
	return _Crypto.Contract.Verify(&_Crypto.CallOpts, message, sig, pubK)
}

// Verify is a free data retrieval call binding the contract method 0x06367587.
//
// Solidity: function Verify(bytes message, uint256[2] sig, uint256[4] pubK) view returns(bool v)
func (_Crypto *CryptoCallerSession) Verify(message []byte, sig [2]*big.Int, pubK [4]*big.Int) (bool, error) {
	return _Crypto.Contract.Verify(&_Crypto.CallOpts, message, sig, pubK)
}

// Bn128Add is a free data retrieval call binding the contract method 0xe664725b.
//
// Solidity: function bn128_add(uint256[4] input) view returns(uint256[2] result)
func (_Crypto *CryptoCaller) Bn128Add(opts *bind.CallOpts, input [4]*big.Int) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "bn128_add", input)
	return *ret0, err
}

// Bn128Add is a free data retrieval call binding the contract method 0xe664725b.
//
// Solidity: function bn128_add(uint256[4] input) view returns(uint256[2] result)
func (_Crypto *CryptoSession) Bn128Add(input [4]*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Bn128Add(&_Crypto.CallOpts, input)
}

// Bn128Add is a free data retrieval call binding the contract method 0xe664725b.
//
// Solidity: function bn128_add(uint256[4] input) view returns(uint256[2] result)
func (_Crypto *CryptoCallerSession) Bn128Add(input [4]*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Bn128Add(&_Crypto.CallOpts, input)
}

// Bn128IsOnCurve is a free data retrieval call binding the contract method 0xf4d7d33d.
//
// Solidity: function bn128_is_on_curve(uint256[2] point) pure returns(bool)
func (_Crypto *CryptoCaller) Bn128IsOnCurve(opts *bind.CallOpts, point [2]*big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "bn128_is_on_curve", point)
	return *ret0, err
}

// Bn128IsOnCurve is a free data retrieval call binding the contract method 0xf4d7d33d.
//
// Solidity: function bn128_is_on_curve(uint256[2] point) pure returns(bool)
func (_Crypto *CryptoSession) Bn128IsOnCurve(point [2]*big.Int) (bool, error) {
	return _Crypto.Contract.Bn128IsOnCurve(&_Crypto.CallOpts, point)
}

// Bn128IsOnCurve is a free data retrieval call binding the contract method 0xf4d7d33d.
//
// Solidity: function bn128_is_on_curve(uint256[2] point) pure returns(bool)
func (_Crypto *CryptoCallerSession) Bn128IsOnCurve(point [2]*big.Int) (bool, error) {
	return _Crypto.Contract.Bn128IsOnCurve(&_Crypto.CallOpts, point)
}

// Bn128Multiply is a free data retrieval call binding the contract method 0x82688f14.
//
// Solidity: function bn128_multiply(uint256[3] input) view returns(uint256[2] result)
func (_Crypto *CryptoCaller) Bn128Multiply(opts *bind.CallOpts, input [3]*big.Int) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "bn128_multiply", input)
	return *ret0, err
}

// Bn128Multiply is a free data retrieval call binding the contract method 0x82688f14.
//
// Solidity: function bn128_multiply(uint256[3] input) view returns(uint256[2] result)
func (_Crypto *CryptoSession) Bn128Multiply(input [3]*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Bn128Multiply(&_Crypto.CallOpts, input)
}

// Bn128Multiply is a free data retrieval call binding the contract method 0x82688f14.
//
// Solidity: function bn128_multiply(uint256[3] input) view returns(uint256[2] result)
func (_Crypto *CryptoCallerSession) Bn128Multiply(input [3]*big.Int) ([2]*big.Int, error) {
	return _Crypto.Contract.Bn128Multiply(&_Crypto.CallOpts, input)
}

// CheckIndices is a free data retrieval call binding the contract method 0x80f4a922.
//
// Solidity: function checkIndices(uint256[] honestIndices, uint256[] dishonestIndices, uint256 n) pure returns(bool validIndices)
func (_Crypto *CryptoCaller) CheckIndices(opts *bind.CallOpts, honestIndices []*big.Int, dishonestIndices []*big.Int, n *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "checkIndices", honestIndices, dishonestIndices, n)
	return *ret0, err
}

// CheckIndices is a free data retrieval call binding the contract method 0x80f4a922.
//
// Solidity: function checkIndices(uint256[] honestIndices, uint256[] dishonestIndices, uint256 n) pure returns(bool validIndices)
func (_Crypto *CryptoSession) CheckIndices(honestIndices []*big.Int, dishonestIndices []*big.Int, n *big.Int) (bool, error) {
	return _Crypto.Contract.CheckIndices(&_Crypto.CallOpts, honestIndices, dishonestIndices, n)
}

// CheckIndices is a free data retrieval call binding the contract method 0x80f4a922.
//
// Solidity: function checkIndices(uint256[] honestIndices, uint256[] dishonestIndices, uint256 n) pure returns(bool validIndices)
func (_Crypto *CryptoCallerSession) CheckIndices(honestIndices []*big.Int, dishonestIndices []*big.Int, n *big.Int) (bool, error) {
	return _Crypto.Contract.CheckIndices(&_Crypto.CallOpts, honestIndices, dishonestIndices, n)
}

// CheckInverses is a free data retrieval call binding the contract method 0xe480a92e.
//
// Solidity: function checkInverses(uint256[] invArray, uint256 maxIndex) pure returns(bool)
func (_Crypto *CryptoCaller) CheckInverses(opts *bind.CallOpts, invArray []*big.Int, maxIndex *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "checkInverses", invArray, maxIndex)
	return *ret0, err
}

// CheckInverses is a free data retrieval call binding the contract method 0xe480a92e.
//
// Solidity: function checkInverses(uint256[] invArray, uint256 maxIndex) pure returns(bool)
func (_Crypto *CryptoSession) CheckInverses(invArray []*big.Int, maxIndex *big.Int) (bool, error) {
	return _Crypto.Contract.CheckInverses(&_Crypto.CallOpts, invArray, maxIndex)
}

// CheckInverses is a free data retrieval call binding the contract method 0xe480a92e.
//
// Solidity: function checkInverses(uint256[] invArray, uint256 maxIndex) pure returns(bool)
func (_Crypto *CryptoCallerSession) CheckInverses(invArray []*big.Int, maxIndex *big.Int) (bool, error) {
	return _Crypto.Contract.CheckInverses(&_Crypto.CallOpts, invArray, maxIndex)
}

// DleqVerify is a free data retrieval call binding the contract method 0xe81ee0e3.
//
// Solidity: function dleq_verify(uint256[2] x1, uint256[2] y1, uint256[2] x2, uint256[2] y2, uint256[2] proof) view returns(bool proof_is_valid)
func (_Crypto *CryptoCaller) DleqVerify(opts *bind.CallOpts, x1 [2]*big.Int, y1 [2]*big.Int, x2 [2]*big.Int, y2 [2]*big.Int, proof [2]*big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "dleq_verify", x1, y1, x2, y2, proof)
	return *ret0, err
}

// DleqVerify is a free data retrieval call binding the contract method 0xe81ee0e3.
//
// Solidity: function dleq_verify(uint256[2] x1, uint256[2] y1, uint256[2] x2, uint256[2] y2, uint256[2] proof) view returns(bool proof_is_valid)
func (_Crypto *CryptoSession) DleqVerify(x1 [2]*big.Int, y1 [2]*big.Int, x2 [2]*big.Int, y2 [2]*big.Int, proof [2]*big.Int) (bool, error) {
	return _Crypto.Contract.DleqVerify(&_Crypto.CallOpts, x1, y1, x2, y2, proof)
}

// DleqVerify is a free data retrieval call binding the contract method 0xe81ee0e3.
//
// Solidity: function dleq_verify(uint256[2] x1, uint256[2] y1, uint256[2] x2, uint256[2] y2, uint256[2] proof) view returns(bool proof_is_valid)
func (_Crypto *CryptoCallerSession) DleqVerify(x1 [2]*big.Int, y1 [2]*big.Int, x2 [2]*big.Int, y2 [2]*big.Int, proof [2]*big.Int) (bool, error) {
	return _Crypto.Contract.DleqVerify(&_Crypto.CallOpts, x1, y1, x2, y2, proof)
}

// SafeSigningPoint is a free data retrieval call binding the contract method 0x96d95a6f.
//
// Solidity: function safeSigningPoint(uint256[2] input) pure returns(bool)
func (_Crypto *CryptoCaller) SafeSigningPoint(opts *bind.CallOpts, input [2]*big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Crypto.contract.Call(opts, out, "safeSigningPoint", input)
	return *ret0, err
}

// SafeSigningPoint is a free data retrieval call binding the contract method 0x96d95a6f.
//
// Solidity: function safeSigningPoint(uint256[2] input) pure returns(bool)
func (_Crypto *CryptoSession) SafeSigningPoint(input [2]*big.Int) (bool, error) {
	return _Crypto.Contract.SafeSigningPoint(&_Crypto.CallOpts, input)
}

// SafeSigningPoint is a free data retrieval call binding the contract method 0x96d95a6f.
//
// Solidity: function safeSigningPoint(uint256[2] input) pure returns(bool)
func (_Crypto *CryptoCallerSession) SafeSigningPoint(input [2]*big.Int) (bool, error) {
	return _Crypto.Contract.SafeSigningPoint(&_Crypto.CallOpts, input)
}

// DepositABI is the input ABI used to generate the binding from.
const DepositABI = "[{\"inputs\":[{\"internalType\":\"contractRegistry\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositReceived\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reloadRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contractBasicERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// DepositBin is the compiled bytecode used for deploying new contracts.
var DepositBin = "0x6080604052600160085534801561001557600080fd5b50604051611a7f380380611a7f8339818101604052602081101561003857600080fd5b810190808051906020019092919050505033600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a233600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061013f600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661018660201b60201c565b80600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506102ed565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061022b5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610280576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180611a4e6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b611752806102fc6000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c8063b311744611610097578063e348da1311610066578063e348da1314610351578063fad8b32a14610395578063fc0c546a146103d9578063ff50abdc1461042357610100565b8063b311744614610299578063b6b55f25146102b7578063be9a6555146102fd578063bf7e214f1461030757610100565b80637a9e5e4b116100d35780637a9e5e4b1461017f5780637b103999146101c35780638da5cb5b1461020d578063b02c43d01461025757610100565b806307da68f51461010557806313af40351461010f5780631476601d1461015357806375f12b211461015d575b600080fd5b61010d610441565b005b6101516004803603602081101561012557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506105ba565b005b61015b610703565b005b610165610a4c565b604051808215151515815260200191505060405180910390f35b6101c16004803603602081101561019557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610a5f565b005b6101cb610ba6565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610215610bcc565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6102836004803603602081101561026d57600080fd5b8101908080359060200190929190505050610bf2565b6040518082815260200191505060405180910390f35b6102a1610c10565b6040518082815260200191505060405180910390f35b6102e3600480360360208110156102cd57600080fd5b8101908080359060200190929190505050610c16565b604051808215151515815260200191505060405180910390f35b610305610cac565b005b61030f610e26565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6103936004803603602081101561036757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610e4b565b005b6103d7600480360360208110156103ab57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610fb2565b005b6103e1611189565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61042b6111af565b6040518082815260200191505060405180910390f35b61046f336000357fffffffff00000000000000000000000000000000000000000000000000000000166111b5565b6104e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60008060006004359250602435915034905060018060146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6105e8336000357fffffffff00000000000000000000000000000000000000000000000000000000166111b5565b61065a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806107a85750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6107fd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806116ec6031913960400191505060405180910390fd5b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600f81526020017f7574696c697479546f6b656e2f763100000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156108c05780820151818401526020810190506108a5565b50505050905090810190601f1680156108ed5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561090a57600080fd5b505afa15801561091e573d6000803e3d6000fd5b505050506040513d602081101561093457600080fd5b8101908080519060200190929190505050600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff16600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415610a4a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f696e76616c6964206164647265737320666f7220746f6b656e0000000000000081525060200191505060405180910390fd5b565b600160149054906101000a900460ff1681565b610a8d336000357fffffffff00000000000000000000000000000000000000000000000000000000166111b5565b610aff576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60096020528060005260406000206000915090508060000154905081565b60085481565b6000600160149054906101000a900460ff1615610c9b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b610ca5338361140e565b9050919050565b610cda336000357fffffffff00000000000000000000000000000000000000000000000000000000166111b5565b610d4c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506000600160146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610ef05750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610f45576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806116ec6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806110575750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6110ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806116ec6031913960400191505060405180910390fd5b600160035411611124576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556003600081548092919060019003919050555050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60075481565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156111f45760019050611408565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156112535760019050611408565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614156112b25760009050611408565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b1580156113ca57600080fd5b505afa1580156113de573d6000803e3d6000fd5b505050506040513d60208110156113f457600080fd5b810190808051906020019092919050505090505b92915050565b60008060096000600854815260200190815260200160002090508281600001819055506114468360075461166890919063ffffffff16565b6007819055507f5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f085416008548585604051808481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001935050505060405180910390a1600860008154809291906001019190505550600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8530866040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b1580156115b057600080fd5b505af11580156115c4573d6000803e3d6000fd5b505050506040513d60208110156115da57600080fd5b810190808051906020019092919050505061165d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f5472616e73666572206661696c6564000000000000000000000000000000000081525060200191505060405180910390fd5b600191505092915050565b60008282840191508110156116e5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b9291505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220acb808dd4c2d1f4eeae95206515a6f0686aaded626aa2036039433a3f5a99fd664736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployDeposit deploys a new Ethereum contract, binding an instance of Deposit to it.
func DeployDeposit(auth *bind.TransactOpts, backend bind.ContractBackend, registry_ common.Address) (common.Address, *types.Transaction, *Deposit, error) {
	parsed, err := abi.JSON(strings.NewReader(DepositABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(DepositBin), backend, registry_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Deposit{DepositCaller: DepositCaller{contract: contract}, DepositTransactor: DepositTransactor{contract: contract}, DepositFilterer: DepositFilterer{contract: contract}}, nil
}

// Deposit is an auto generated Go binding around an Ethereum contract.
type Deposit struct {
	DepositCaller     // Read-only binding to the contract
	DepositTransactor // Write-only binding to the contract
	DepositFilterer   // Log filterer for contract events
}

// DepositCaller is an auto generated read-only Go binding around an Ethereum contract.
type DepositCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DepositTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DepositFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DepositSession struct {
	Contract     *Deposit          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DepositCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DepositCallerSession struct {
	Contract *DepositCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// DepositTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DepositTransactorSession struct {
	Contract     *DepositTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// DepositRaw is an auto generated low-level Go binding around an Ethereum contract.
type DepositRaw struct {
	Contract *Deposit // Generic contract binding to access the raw methods on
}

// DepositCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DepositCallerRaw struct {
	Contract *DepositCaller // Generic read-only contract binding to access the raw methods on
}

// DepositTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DepositTransactorRaw struct {
	Contract *DepositTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDeposit creates a new instance of Deposit, bound to a specific deployed contract.
func NewDeposit(address common.Address, backend bind.ContractBackend) (*Deposit, error) {
	contract, err := bindDeposit(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Deposit{DepositCaller: DepositCaller{contract: contract}, DepositTransactor: DepositTransactor{contract: contract}, DepositFilterer: DepositFilterer{contract: contract}}, nil
}

// NewDepositCaller creates a new read-only instance of Deposit, bound to a specific deployed contract.
func NewDepositCaller(address common.Address, caller bind.ContractCaller) (*DepositCaller, error) {
	contract, err := bindDeposit(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DepositCaller{contract: contract}, nil
}

// NewDepositTransactor creates a new write-only instance of Deposit, bound to a specific deployed contract.
func NewDepositTransactor(address common.Address, transactor bind.ContractTransactor) (*DepositTransactor, error) {
	contract, err := bindDeposit(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DepositTransactor{contract: contract}, nil
}

// NewDepositFilterer creates a new log filterer instance of Deposit, bound to a specific deployed contract.
func NewDepositFilterer(address common.Address, filterer bind.ContractFilterer) (*DepositFilterer, error) {
	contract, err := bindDeposit(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DepositFilterer{contract: contract}, nil
}

// bindDeposit binds a generic wrapper to an already deployed contract.
func bindDeposit(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DepositABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Deposit *DepositRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Deposit.Contract.DepositCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Deposit *DepositRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Deposit.Contract.DepositTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Deposit *DepositRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Deposit.Contract.DepositTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Deposit *DepositCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Deposit.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Deposit *DepositTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Deposit.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Deposit *DepositTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Deposit.Contract.contract.Transact(opts, method, params...)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Deposit *DepositCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Deposit *DepositSession) Authority() (common.Address, error) {
	return _Deposit.Contract.Authority(&_Deposit.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Deposit *DepositCallerSession) Authority() (common.Address, error) {
	return _Deposit.Contract.Authority(&_Deposit.CallOpts)
}

// DepositID is a free data retrieval call binding the contract method 0xb3117446.
//
// Solidity: function depositID() view returns(uint256)
func (_Deposit *DepositCaller) DepositID(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "depositID")
	return *ret0, err
}

// DepositID is a free data retrieval call binding the contract method 0xb3117446.
//
// Solidity: function depositID() view returns(uint256)
func (_Deposit *DepositSession) DepositID() (*big.Int, error) {
	return _Deposit.Contract.DepositID(&_Deposit.CallOpts)
}

// DepositID is a free data retrieval call binding the contract method 0xb3117446.
//
// Solidity: function depositID() view returns(uint256)
func (_Deposit *DepositCallerSession) DepositID() (*big.Int, error) {
	return _Deposit.Contract.DepositID(&_Deposit.CallOpts)
}

// Deposits is a free data retrieval call binding the contract method 0xb02c43d0.
//
// Solidity: function deposits(uint256 ) view returns(uint256 amount)
func (_Deposit *DepositCaller) Deposits(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "deposits", arg0)
	return *ret0, err
}

// Deposits is a free data retrieval call binding the contract method 0xb02c43d0.
//
// Solidity: function deposits(uint256 ) view returns(uint256 amount)
func (_Deposit *DepositSession) Deposits(arg0 *big.Int) (*big.Int, error) {
	return _Deposit.Contract.Deposits(&_Deposit.CallOpts, arg0)
}

// Deposits is a free data retrieval call binding the contract method 0xb02c43d0.
//
// Solidity: function deposits(uint256 ) view returns(uint256 amount)
func (_Deposit *DepositCallerSession) Deposits(arg0 *big.Int) (*big.Int, error) {
	return _Deposit.Contract.Deposits(&_Deposit.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Deposit *DepositCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Deposit *DepositSession) Owner() (common.Address, error) {
	return _Deposit.Contract.Owner(&_Deposit.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Deposit *DepositCallerSession) Owner() (common.Address, error) {
	return _Deposit.Contract.Owner(&_Deposit.CallOpts)
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() view returns(address)
func (_Deposit *DepositCaller) Registry(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "registry")
	return *ret0, err
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() view returns(address)
func (_Deposit *DepositSession) Registry() (common.Address, error) {
	return _Deposit.Contract.Registry(&_Deposit.CallOpts)
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() view returns(address)
func (_Deposit *DepositCallerSession) Registry() (common.Address, error) {
	return _Deposit.Contract.Registry(&_Deposit.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Deposit *DepositCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Deposit *DepositSession) Stopped() (bool, error) {
	return _Deposit.Contract.Stopped(&_Deposit.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Deposit *DepositCallerSession) Stopped() (bool, error) {
	return _Deposit.Contract.Stopped(&_Deposit.CallOpts)
}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_Deposit *DepositCaller) Token(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "token")
	return *ret0, err
}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_Deposit *DepositSession) Token() (common.Address, error) {
	return _Deposit.Contract.Token(&_Deposit.CallOpts)
}

// Token is a free data retrieval call binding the contract method 0xfc0c546a.
//
// Solidity: function token() view returns(address)
func (_Deposit *DepositCallerSession) Token() (common.Address, error) {
	return _Deposit.Contract.Token(&_Deposit.CallOpts)
}

// TotalDeposited is a free data retrieval call binding the contract method 0xff50abdc.
//
// Solidity: function totalDeposited() view returns(uint256)
func (_Deposit *DepositCaller) TotalDeposited(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Deposit.contract.Call(opts, out, "totalDeposited")
	return *ret0, err
}

// TotalDeposited is a free data retrieval call binding the contract method 0xff50abdc.
//
// Solidity: function totalDeposited() view returns(uint256)
func (_Deposit *DepositSession) TotalDeposited() (*big.Int, error) {
	return _Deposit.Contract.TotalDeposited(&_Deposit.CallOpts)
}

// TotalDeposited is a free data retrieval call binding the contract method 0xff50abdc.
//
// Solidity: function totalDeposited() view returns(uint256)
func (_Deposit *DepositCallerSession) TotalDeposited() (*big.Int, error) {
	return _Deposit.Contract.TotalDeposited(&_Deposit.CallOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 amount) returns(bool)
func (_Deposit *DepositTransactor) Deposit(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "deposit", amount)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 amount) returns(bool)
func (_Deposit *DepositSession) Deposit(amount *big.Int) (*types.Transaction, error) {
	return _Deposit.Contract.Deposit(&_Deposit.TransactOpts, amount)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 amount) returns(bool)
func (_Deposit *DepositTransactorSession) Deposit(amount *big.Int) (*types.Transaction, error) {
	return _Deposit.Contract.Deposit(&_Deposit.TransactOpts, amount)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Deposit *DepositTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Deposit *DepositSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.GrantOperator(&_Deposit.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Deposit *DepositTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.GrantOperator(&_Deposit.TransactOpts, _operator)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Deposit *DepositTransactor) ReloadRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "reloadRegistry")
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Deposit *DepositSession) ReloadRegistry() (*types.Transaction, error) {
	return _Deposit.Contract.ReloadRegistry(&_Deposit.TransactOpts)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Deposit *DepositTransactorSession) ReloadRegistry() (*types.Transaction, error) {
	return _Deposit.Contract.ReloadRegistry(&_Deposit.TransactOpts)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Deposit *DepositTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Deposit *DepositSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.RevokeOperator(&_Deposit.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Deposit *DepositTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.RevokeOperator(&_Deposit.TransactOpts, _operator)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Deposit *DepositTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Deposit *DepositSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.SetAuthority(&_Deposit.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Deposit *DepositTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.SetAuthority(&_Deposit.TransactOpts, authority_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Deposit *DepositTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Deposit *DepositSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.SetOwner(&_Deposit.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Deposit *DepositTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Deposit.Contract.SetOwner(&_Deposit.TransactOpts, owner_)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Deposit *DepositTransactor) Start(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "start")
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Deposit *DepositSession) Start() (*types.Transaction, error) {
	return _Deposit.Contract.Start(&_Deposit.TransactOpts)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Deposit *DepositTransactorSession) Start() (*types.Transaction, error) {
	return _Deposit.Contract.Start(&_Deposit.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Deposit *DepositTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Deposit.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Deposit *DepositSession) Stop() (*types.Transaction, error) {
	return _Deposit.Contract.Stop(&_Deposit.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Deposit *DepositTransactorSession) Stop() (*types.Transaction, error) {
	return _Deposit.Contract.Stop(&_Deposit.TransactOpts)
}

// DepositDepositReceivedIterator is returned from FilterDepositReceived and is used to iterate over the raw logs and unpacked data for DepositReceived events raised by the Deposit contract.
type DepositDepositReceivedIterator struct {
	Event *DepositDepositReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DepositDepositReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DepositDepositReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DepositDepositReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DepositDepositReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DepositDepositReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DepositDepositReceived represents a DepositReceived event raised by the Deposit contract.
type DepositDepositReceived struct {
	DepositID *big.Int
	Depositor common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDepositReceived is a free log retrieval operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_Deposit *DepositFilterer) FilterDepositReceived(opts *bind.FilterOpts) (*DepositDepositReceivedIterator, error) {

	logs, sub, err := _Deposit.contract.FilterLogs(opts, "DepositReceived")
	if err != nil {
		return nil, err
	}
	return &DepositDepositReceivedIterator{contract: _Deposit.contract, event: "DepositReceived", logs: logs, sub: sub}, nil
}

// WatchDepositReceived is a free log subscription operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_Deposit *DepositFilterer) WatchDepositReceived(opts *bind.WatchOpts, sink chan<- *DepositDepositReceived) (event.Subscription, error) {

	logs, sub, err := _Deposit.contract.WatchLogs(opts, "DepositReceived")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DepositDepositReceived)
				if err := _Deposit.contract.UnpackLog(event, "DepositReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDepositReceived is a log parse operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_Deposit *DepositFilterer) ParseDepositReceived(log types.Log) (*DepositDepositReceived, error) {
	event := new(DepositDepositReceived)
	if err := _Deposit.contract.UnpackLog(event, "DepositReceived", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DepositLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the Deposit contract.
type DepositLogSetAuthorityIterator struct {
	Event *DepositLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DepositLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DepositLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DepositLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DepositLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DepositLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DepositLogSetAuthority represents a LogSetAuthority event raised by the Deposit contract.
type DepositLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Deposit *DepositFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*DepositLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Deposit.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &DepositLogSetAuthorityIterator{contract: _Deposit.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Deposit *DepositFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *DepositLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Deposit.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DepositLogSetAuthority)
				if err := _Deposit.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetAuthority is a log parse operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Deposit *DepositFilterer) ParseLogSetAuthority(log types.Log) (*DepositLogSetAuthority, error) {
	event := new(DepositLogSetAuthority)
	if err := _Deposit.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DepositLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the Deposit contract.
type DepositLogSetOwnerIterator struct {
	Event *DepositLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DepositLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DepositLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DepositLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DepositLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DepositLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DepositLogSetOwner represents a LogSetOwner event raised by the Deposit contract.
type DepositLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Deposit *DepositFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*DepositLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Deposit.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &DepositLogSetOwnerIterator{contract: _Deposit.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Deposit *DepositFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *DepositLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Deposit.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DepositLogSetOwner)
				if err := _Deposit.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetOwner is a log parse operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Deposit *DepositFilterer) ParseLogSetOwner(log types.Log) (*DepositLogSetOwner, error) {
	event := new(DepositLogSetOwner)
	if err := _Deposit.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DepositEventsABI is the input ABI used to generate the binding from.
const DepositEventsABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositReceived\",\"type\":\"event\"}]"

// DepositEvents is an auto generated Go binding around an Ethereum contract.
type DepositEvents struct {
	DepositEventsCaller     // Read-only binding to the contract
	DepositEventsTransactor // Write-only binding to the contract
	DepositEventsFilterer   // Log filterer for contract events
}

// DepositEventsCaller is an auto generated read-only Go binding around an Ethereum contract.
type DepositEventsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositEventsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DepositEventsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositEventsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DepositEventsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DepositEventsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DepositEventsSession struct {
	Contract     *DepositEvents    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DepositEventsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DepositEventsCallerSession struct {
	Contract *DepositEventsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// DepositEventsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DepositEventsTransactorSession struct {
	Contract     *DepositEventsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// DepositEventsRaw is an auto generated low-level Go binding around an Ethereum contract.
type DepositEventsRaw struct {
	Contract *DepositEvents // Generic contract binding to access the raw methods on
}

// DepositEventsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DepositEventsCallerRaw struct {
	Contract *DepositEventsCaller // Generic read-only contract binding to access the raw methods on
}

// DepositEventsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DepositEventsTransactorRaw struct {
	Contract *DepositEventsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDepositEvents creates a new instance of DepositEvents, bound to a specific deployed contract.
func NewDepositEvents(address common.Address, backend bind.ContractBackend) (*DepositEvents, error) {
	contract, err := bindDepositEvents(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DepositEvents{DepositEventsCaller: DepositEventsCaller{contract: contract}, DepositEventsTransactor: DepositEventsTransactor{contract: contract}, DepositEventsFilterer: DepositEventsFilterer{contract: contract}}, nil
}

// NewDepositEventsCaller creates a new read-only instance of DepositEvents, bound to a specific deployed contract.
func NewDepositEventsCaller(address common.Address, caller bind.ContractCaller) (*DepositEventsCaller, error) {
	contract, err := bindDepositEvents(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DepositEventsCaller{contract: contract}, nil
}

// NewDepositEventsTransactor creates a new write-only instance of DepositEvents, bound to a specific deployed contract.
func NewDepositEventsTransactor(address common.Address, transactor bind.ContractTransactor) (*DepositEventsTransactor, error) {
	contract, err := bindDepositEvents(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DepositEventsTransactor{contract: contract}, nil
}

// NewDepositEventsFilterer creates a new log filterer instance of DepositEvents, bound to a specific deployed contract.
func NewDepositEventsFilterer(address common.Address, filterer bind.ContractFilterer) (*DepositEventsFilterer, error) {
	contract, err := bindDepositEvents(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DepositEventsFilterer{contract: contract}, nil
}

// bindDepositEvents binds a generic wrapper to an already deployed contract.
func bindDepositEvents(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DepositEventsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DepositEvents *DepositEventsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DepositEvents.Contract.DepositEventsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DepositEvents *DepositEventsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DepositEvents.Contract.DepositEventsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DepositEvents *DepositEventsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DepositEvents.Contract.DepositEventsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DepositEvents *DepositEventsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DepositEvents.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DepositEvents *DepositEventsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DepositEvents.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DepositEvents *DepositEventsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DepositEvents.Contract.contract.Transact(opts, method, params...)
}

// DepositEventsDepositReceivedIterator is returned from FilterDepositReceived and is used to iterate over the raw logs and unpacked data for DepositReceived events raised by the DepositEvents contract.
type DepositEventsDepositReceivedIterator struct {
	Event *DepositEventsDepositReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DepositEventsDepositReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DepositEventsDepositReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DepositEventsDepositReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DepositEventsDepositReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DepositEventsDepositReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DepositEventsDepositReceived represents a DepositReceived event raised by the DepositEvents contract.
type DepositEventsDepositReceived struct {
	DepositID *big.Int
	Depositor common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDepositReceived is a free log retrieval operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_DepositEvents *DepositEventsFilterer) FilterDepositReceived(opts *bind.FilterOpts) (*DepositEventsDepositReceivedIterator, error) {

	logs, sub, err := _DepositEvents.contract.FilterLogs(opts, "DepositReceived")
	if err != nil {
		return nil, err
	}
	return &DepositEventsDepositReceivedIterator{contract: _DepositEvents.contract, event: "DepositReceived", logs: logs, sub: sub}, nil
}

// WatchDepositReceived is a free log subscription operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_DepositEvents *DepositEventsFilterer) WatchDepositReceived(opts *bind.WatchOpts, sink chan<- *DepositEventsDepositReceived) (event.Subscription, error) {

	logs, sub, err := _DepositEvents.contract.WatchLogs(opts, "DepositReceived")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DepositEventsDepositReceived)
				if err := _DepositEvents.contract.UnpackLog(event, "DepositReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDepositReceived is a log parse operation binding the contract event 0x5b063c6569a91e8133fc6cd71d31a4ca5c65c652fd53ae093f46107754f08541.
//
// Solidity: event DepositReceived(uint256 depositID, address depositor, uint256 amount)
func (_DepositEvents *DepositEventsFilterer) ParseDepositReceived(log types.Log) (*DepositEventsDepositReceived, error) {
	event := new(DepositEventsDepositReceived)
	if err := _DepositEvents.contract.UnpackLog(event, "DepositReceived", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGABI is the input ABI used to generate the binding from.
const ETHDKGABI = "[{\"inputs\":[{\"internalType\":\"contractRegistry\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"KeyShareSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgStarts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareDistributionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyShareSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mpkSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjDisputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgComplete\",\"type\":\"uint256\"}],\"name\":\"RegistrationOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"ShareDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share3\",\"type\":\"uint256\"}],\"name\":\"ValidatorMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"validatorCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ethHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"madHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey3\",\"type\":\"uint256\"}],\"name\":\"ValidatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELTA_CONFIRM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"invArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"honestIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dishonestIndices\",\"type\":\"uint256[]\"}],\"name\":\"Group_Accusation_GPKj\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"gpkj\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"sig\",\"type\":\"uint256[2]\"}],\"name\":\"Submit_GPKj\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Successful_Completion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DKG_COMPLETE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_KEY_SHARE_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_MPK_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REGISTRATION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SHARE_DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments_1st_coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completion_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"distribute_shares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPhaseLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gpkj_submissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_message\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_signatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_malicious\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"key_share_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"key_shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"master_public_key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpk_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfRegistrations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"public_keys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"public_key\",\"type\":\"uint256[2]\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registration_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reloadRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share_distribution_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_distribution_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"issuer_list_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disputer_list_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2]\",\"name\":\"shared_key\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"shared_key_correctness_proof\",\"type\":\"uint256[2]\"}],\"name\":\"submit_dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"submit_key_share\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"_master_public_key\",\"type\":\"uint256[4]\"}],\"name\":\"submit_master_public_key\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelta\",\"type\":\"uint256\"}],\"name\":\"updatePhaseLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ETHDKGBin is the compiled bytecode used for deploying new contracts.
var ETHDKGBin = "0x608060405260405160200180807f43727970746f67726170687920697320677265617400000000000000000000008152506015019050604051602081830303815290604052600d90805190602001906200005b9291906200012e565b5060286017553480156200006e57600080fd5b5060405162005f5e38038062005f5e833981810160405260208110156200009457600080fd5b810190808051906020019092919050505080601a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555033601860006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050620001dd565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200017157805160ff1916838001178555620001a2565b82800160010185558215620001a2579182015b82811115620001a157825182559160200191906001019062000184565b5b509050620001b19190620001b5565b5090565b620001da91905b80821115620001d6576000816000905550600101620001bc565b5090565b90565b615d7180620001ed6000396000f3fe608060405234801561001057600080fd5b50600436106102275760003560e01c806392896b2d11610130578063d3cf6186116100b8578063e65113781161007c578063e651137814610e89578063eadfcadc14610ecb578063edf26d9b14610f27578063f47ae6a914610f95578063fef001a914610ffa57610227565b8063d3cf618614610d6b578063d8f63eb714610d89578063dc5e8a0a14610da7578063dc614e2814610e4d578063e2291ec314610e6b57610227565b8063a88c9e1c116100ff578063a88c9e1c14610bee578063aa7bd33814610c50578063ab63c72214610cd3578063b7b09ed614610cf1578063c21bee8314610d1357610227565b806392896b2d146108065780639c2aa83814610868578063a080e5e014610886578063a687283314610a0e57610227565b80633442af5c116101b35780637543b80f116101825780637543b80f1461077c57806375f7ed6a1461079a57806377fbebd1146107bc57806382571195146107da578063836889dc146107e457610227565b80633442af5c146105a357806365c97c01146106085780637163525e146106125780637328f8261461071a57610227565b80631476601d116101fa5780631476601d146102a85780632a702773146102b25780632cf4050b146102e05780632f11b985146103425780632f123ffc1461036457610227565b8063050a54f01461022c57806307f02c541461024e5780630de1553f1461026c578063106da57d1461028a575b600080fd5b61023461105c565b604051808215151515815260200191505060405180910390f35b61025661106f565b6040518082815260200191505060405180910390f35b610274611075565b6040518082815260200191505060405180910390f35b61029261107b565b6040518082815260200191505060405180910390f35b6102b0611085565b005b6102de600480360360208110156102c857600080fd5b8101908080359060200190929190505050611a7a565b005b61032c600480360360408110156102f657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611b47565b6040518082815260200191505060405180910390f35b61034a611b6c565b604051808215151515815260200191505060405180910390f35b6105a1600480360361012081101561037b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190929190803590602001906401000000008111156103cc57600080fd5b8201836020820111156103de57600080fd5b8035906020019184602083028401116401000000008311171561040057600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561046057600080fd5b82018360208201111561047257600080fd5b8035906020019184604083028401116401000000008311171561049457600080fd5b9190808060200260200160405190810160405280939291908181526020016000905b8282101561050d578484839050604002016002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050815260200190600101906104b6565b5050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f8201169050808301925050505050509192919290505050611b7f565b005b610606600480360360408110156105b957600080fd5b8101908080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f82011690508083019250505050505091929192905050506129b2565b005b610610612fa6565b005b610718600480360361012081101561062957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f8201169050808301925050505050509192919290505050613197565b005b6107666004803603604081101561073057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050613b59565b6040518082815260200191505060405180910390f35b610784613b7e565b6040518082815260200191505060405180910390f35b6107a2613b83565b604051808215151515815260200191505060405180910390f35b6107c4613b96565b6040518082815260200191505060405180910390f35b6107e2613b9c565b005b6107ec613cc1565b604051808215151515815260200191505060405180910390f35b6108526004803603604081101561081c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050613cd4565b6040518082815260200191505060405180910390f35b610870613cf9565b6040518082815260200191505060405180910390f35b610a0c6004803603604081101561089c57600080fd5b81019080803590602001906401000000008111156108b957600080fd5b8201836020820111156108cb57600080fd5b803590602001918460208302840111640100000000831117156108ed57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561094d57600080fd5b82018360208201111561095f57600080fd5b8035906020019184604083028401116401000000008311171561098157600080fd5b9190808060200260200160405190810160405280939291908181526020016000905b828210156109fa578484839050604002016002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050815260200190600101906109a3565b50505050509192919290505050613cff565b005b610bec60048036036060811015610a2457600080fd5b8101908080359060200190640100000000811115610a4157600080fd5b820183602082011115610a5357600080fd5b80359060200191846020830284011164010000000083111715610a7557600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190640100000000811115610ad557600080fd5b820183602082011115610ae757600080fd5b80359060200191846020830284011164010000000083111715610b0957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190640100000000811115610b6957600080fd5b820183602082011115610b7b57600080fd5b80359060200191846020830284011164010000000083111715610b9d57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f82011690508083019250505050505050919291929050505061446c565b005b610c3a60048036036040811015610c0457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050614700565b6040518082815260200191505060405180910390f35b610c58614725565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610c98578082015181840152602081019050610c7d565b50505050905090810190601f168015610cc55780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610cdb6147c3565b6040518082815260200191505060405180910390f35b610cf96147c9565b604051808215151515815260200191505060405180910390f35b610d5560048036036020811015610d2957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506147dc565b6040518082815260200191505060405180910390f35b610d736147f4565b6040518082815260200191505060405180910390f35b610d916147fa565b6040518082815260200191505060405180910390f35b610e4b600480360360c0811015610dbd57600080fd5b8101908080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f820116905080830192505050505050919291929080604001906002806020026040519081016040528092919082600260200280828437600081840152601f19601f820116905080830192505050505050919291929050505061487e565b005b610e55614f0a565b6040518082815260200191505060405180910390f35b610e73614f10565b6040518082815260200191505060405180910390f35b610eb560048036036020811015610e9f57600080fd5b8101908080359060200190929190505050614f16565b6040518082815260200191505060405180910390f35b610f0d60048036036020811015610ee157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050614f2e565b604051808215151515815260200191505060405180910390f35b610f5360048036036020811015610f3d57600080fd5b8101908080359060200190929190505050614f4e565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610ff860048036036080811015610fab57600080fd5b8101908080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f8201169050808301925050505050509192919290505050614f8a565b005b6110466004803603604081101561101057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506151af565b6040518082815260200191505060405180910390f35b600e60039054906101000a900460ff1681565b60135481565b600f5481565b6000601754905090565b601860009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611148576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f4e6f7420617574686f72697a656400000000000000000000000000000000000081525060200191505060405180910390fd5b601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600981526020017f63727970746f2f763100000000000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561120b5780820151818401526020810190506111f0565b50505050905090810190601f1680156112385780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561125557600080fd5b505afa158015611269573d6000803e3d6000fd5b505050506040513d602081101561127f57600080fd5b8101908080519060200190929190505050601960006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600d81526020017f76616c696461746f72732f7631000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611393578082015181840152602081019050611378565b50505050905090810190601f1680156113c05780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156113dd57600080fd5b505afa1580156113f1573d6000803e3d6000fd5b505050506040513d602081101561140757600080fd5b8101908080519060200190929190505050601b60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280601581526020017f76616c696461746f7273536e617073686f742f763100000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561151b578082015181840152602081019050611500565b50505050905090810190601f1680156115485780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561156557600080fd5b505afa158015611579573d6000803e3d6000fd5b505050506040513d602081101561158f57600080fd5b8101908080519060200190929190505050601c60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280601381526020017f657468646b67436f6d706c6574696f6e2f7631000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156116a3578082015181840152602081019050611688565b50505050905090810190601f1680156116d05780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156116ed57600080fd5b505afa158015611701573d6000803e3d6000fd5b505050506040513d602081101561171757600080fd5b8101908080519060200190929190505050601d60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280601881526020017f657468646b6747726f757041636375736174696f6e2f763100000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561182b578082015181840152602081019050611810565b50505050905090810190601f1680156118585780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561187557600080fd5b505afa158015611889573d6000803e3d6000fd5b505050506040513d602081101561189f57600080fd5b8101908080519060200190929190505050601e60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280601281526020017f657468646b675375626d69744d504b2f763100000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156119b3578082015181840152602081019050611998565b50505050905090810190601f1680156119e05780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156119fd57600080fd5b505afa158015611a11573d6000803e3d6000fd5b505050506040513d6020811015611a2757600080fd5b8101908080519060200190929190505050601f60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b601860009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611b3d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f4e6f7420617574686f72697a656400000000000000000000000000000000000081525060200191505060405180910390fd5b8060178190555050565b60036020528160005260406000208160028110611b6057fe5b01600091509150505481565b600e60019054906101000a900460ff1681565b43601054108015611b9257506011544311155b611be7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806159ac6031913960400191505060405180910390fd5b8673ffffffffffffffffffffffffffffffffffffffff1660008781548110611c0b57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16148015611cbb57503373ffffffffffffffffffffffffffffffffffffffff1660008681548110611c7857fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b611d10576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180615a6f6025913960400191505060405180910390fd5b6000801b600260008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541415611d5f576129a9565b838360405160200180838051906020019060200280838360005b83811015611d94578082015181840152602081019050611d79565b505050509050018280516000925b81841015611deb5782846020026020010151600260200280838360005b83811015611dda578082015181840152602081019050611dbf565b505050509050019260010192611da2565b925050509250505060405160208183030381529060405280519060200120600260008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414611e9f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603681526020018061589a6036913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e81ee0e36040518060400160405280600181526020016002815250600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600160008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002086866040518663ffffffff1660e01b81526004018086600260200280838360005b83811015611fae578082015181840152602081019050611f93565b505050509050018560028015611fd9576020028201915b815481526020019060010190808311611fc5575b50508460028015611fff576020028201915b815481526020019060010190808311611feb575b505083600260200280838360005b8381101561202857808201518184015260208101905061200d565b5050505090500182600260200280838360005b8381101561205657808201518184015260208101905061203b565b505050509050019550505050505060206040518083038186803b15801561207c57600080fd5b505afa158015612090573d6000803e3d6000fd5b505050506040513d60208110156120a657600080fd5b810190808051906020019092919050505061210c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602c815260200180615adb602c913960400191505060405180910390fd5b600080600187019050878710156121385785878151811061212957fe5b60200260200101519150612152565b85600188038151811061214757fe5b602002602001015191505b60008460006002811061216157fe5b60200201518260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012060001c9050808318925060008290506121ab615702565b876000815181106121b857fe5b602002602001015190506121ca615702565b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166382688f1460405180606001604052808c60018151811061222057fe5b602002602001015160006002811061223457fe5b602002015181526020018c60018151811061224b57fe5b602002602001015160016002811061225f57fe5b60200201518152602001868152506040518263ffffffff1660e01b81526004018082600360200280838360005b838110156122a757808201518184015260208101905061228c565b50505050905001915050604080518083038186803b1580156122c857600080fd5b505afa1580156122dc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250604081101561230157600080fd5b81019080919050509050601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e664725b60405180608001604052808560006002811061236157fe5b602002015181526020018560016002811061237857fe5b602002015181526020018460006002811061238f57fe5b60200201518152602001846001600281106123a657fe5b60200201518152506040518263ffffffff1660e01b81526004018082600460200280838360005b838110156123e85780820151818401526020810190506123cd565b50505050905001915050604080518083038186803b15801561240957600080fd5b505afa15801561241d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250604081101561244257600080fd5b810190809190505091506000600290505b8951811015612714577f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061248457fe5b8685099350601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166382688f1460405180606001604052808d85815181106124de57fe5b60200260200101516000600281106124f257fe5b602002015181526020018d858151811061250857fe5b602002602001015160016002811061251c57fe5b60200201518152602001878152506040518263ffffffff1660e01b81526004018082600360200280838360005b83811015612564578082015181840152602081019050612549565b50505050905001915050604080518083038186803b15801561258557600080fd5b505afa158015612599573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060408110156125be57600080fd5b81019080919050509150601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e664725b60405180608001604052808660006002811061261e57fe5b602002015181526020018660016002811061263557fe5b602002015181526020018560006002811061264c57fe5b602002015181526020018560016002811061266357fe5b60200201518152506040518263ffffffff1660e01b81526004018082600460200280838360005b838110156126a557808201518184015260208101905061268a565b50505050905001915050604080518083038186803b1580156126c657600080fd5b505afa1580156126da573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060408110156126ff57600080fd5b81019080919050509250600181019050612453565b50601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166382688f1460405180606001604052806001815260200160028152602001898152506040518263ffffffff1660e01b81526004018082600360200280838360005b838110156127aa57808201518184015260208101905061278f565b50505050905001915050604080518083038186803b1580156127cb57600080fd5b505afa1580156127df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250604081101561280457600080fd5b810190809190505090508060006002811061281b57fe5b60200201518260006002811061282d57fe5b602002015114158061286157508060016002811061284757fe5b60200201518260016002811061285957fe5b602002015114155b1561290657600260008e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600090556001600860008f73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506129a2565b600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600090556001600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505b5050505050505b50505050505050565b6000816000600281106129c157fe5b60200201511415612a1d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180615a476028913960400191505060405180910390fd5b600081600160028110612a2c57fe5b60200201511415612a88576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806158d06028913960400191505060405180910390fd5b600f54431115612ae3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603b81526020018061593d603b913960400191505060405180910390fd5b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600060028110612b3057fe5b015414612b88576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603d815260200180615816603d913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f4d7d33d826040518263ffffffff1660e01b81526004018082600260200280838360005b83811015612c01578082015181840152602081019050612be6565b5050505090500191505060206040518083038186803b158015612c2357600080fd5b505afa158015612c37573d6000803e3d6000fd5b505050506040513d6020811015612c4d57600080fd5b8101908080519060200190929190505050612cb3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260368152602001806159dd6036913960400191505060405180910390fd5b601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166335c6a1636040518163ffffffff1660e01b8152600401602060405180830381600087803b158015612d1d57600080fd5b505af1158015612d31573d6000803e3d6000fd5b505050506040513d6020811015612d4757600080fd5b810190808051906020019092919050505050601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663facd743b336040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015612df857600080fd5b505afa158015612e0c573d6000803e3d6000fd5b505050506040513d6020811015612e2257600080fd5b8101908080519060200190929190505050612ea5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f76616c696461746f72206e6f7420616c6c6f776564000000000000000000000081525060200191505060405180910390fd5b6000339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906002612f56929190615724565b50600160008054905003600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050565b60006060601d60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f65c97c01000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106130995780518252602082019150602081019050602083039250613076565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146130f9576040519150601f19603f3d011682016040523d82523d6000602084013e6130fe565b606091505b509150915081613159576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180615b076031913960400191505060405180910390fd5b600081806020019051602081101561317057600080fd5b810190808051906020019092919050505090508015613192576131916151d4565b5b505050565b436011541080156131aa57506012544311155b6131ff576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526045815260200180615bcf6045913960600191505060405180910390fd5b600e60019054906101000a900460ff166134bc5760006001905060005b60008054905081101561348b57600080828154811061323757fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000801b600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054141561347d57600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16156133be57601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166357b4f82a826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156133a157600080fd5b505af11580156133b5573d6000803e3d6000fd5b50505050613478565b601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d2a2c55c826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561345f57600080fd5b505af1158015613473573d6000803e3d6000fd5b505050505b600092505b50808060010191505061321c565b508061349f576134996151d4565b50613b53565b6001600e60016101000a81548160ff021916908315150217905550505b6000600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006002811061350957fe5b01541461351557613b53565b6000801b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414156135b0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526032815260200180615b386032913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e81ee0e360405180604001604052807f062a0ad5cf656709286b38ae4fb927fc901c5f9cf9623bfd0b6d22d30f95a1f381526020017f1b4af7018d896f006d7e5c23d05903b5d2698da94674e546e51f77b6df70ffac815250856040518060400160405280600181526020016002815250600360008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020876040518663ffffffff1660e01b81526004018086600260200280838360005b838110156136d55780820151818401526020810190506136ba565b5050505090500185600260200280838360005b838110156137035780820151818401526020810190506136e8565b5050505090500184600260200280838360005b83811015613731578082015181840152602081019050613716565b50505050905001836002801561375c576020028201915b815481526020019060010190808311613748575b505082600260200280838360005b8381101561378557808201518184015260208101905061376a565b505050509050019550505050505060206040518083038186803b1580156137ab57600080fd5b505afa1580156137bf573d6000803e3d6000fd5b505050506040513d60208110156137d557600080fd5b810190808051906020019092919050505061383b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526034815260200180615b9b6034913960400191505060405180910390fd5b6139bb6040518061018001604052808560006002811061385757fe5b602002015181526020018560016002811061386e57fe5b602002015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d81526020017f062a0ad5cf656709286b38ae4fb927fc901c5f9cf9623bfd0b6d22d30f95a1f381526020017f1b4af7018d896f006d7e5c23d05903b5d2698da94674e546e51f77b6df70ffac81526020018360006004811061396957fe5b602002015181526020018360016004811061398057fe5b602002015181526020018360026004811061399757fe5b60200201518152602001836003600481106139ae57fe5b6020020151815250615656565b613a10576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260348152602001806159786034913960400191505060405180910390fd5b82600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906002613a5e929190615724565b507fb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc84848484604051808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184600260200280838360005b83811015613ae1578082015181840152602081019050613ac6565b5050505090500183600260200280838360005b83811015613b0f578082015181840152602081019050613af4565b5050505090500182600460200280838360005b83811015613b3d578082015181840152602081019050613b22565b5050505090500194505050505060405180910390a15b50505050565b60066020528160005260406000208160028110613b7257fe5b01600091509150505481565b600681565b600e60049054906101000a900460ff1681565b60165481565b601860009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613c455750601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b613cb7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f4e6f7420617574686f72697a656400000000000000000000000000000000000081525060200191505060405180910390fd5b613cbf6151d4565b565b600e60029054906101000a900460ff1681565b60016020528160005260406000208160028110613ced57fe5b01600091509150505481565b60145481565b43600f54108015613d1257506010544311155b613d67576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260478152602001806158536047913960600191505060405180910390fd5b6000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600060028110613db457fe5b0154148015613e0f57506000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600160028110613e0b57fe5b0154145b613e81576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f73686172657320616c726561647920646973747269627574656400000000000081525060200191505060405180910390fd5b600e60009054906101000a900460ff16613ecc5760046000805490501015613eb057613eab6151d4565b614468565b6001600e60006101000a81548160ff0219169083151502179055505b600080805490509050600060038281613ee157fe5b049050600081600202905081600302830360021415613f01576001810190505b6000600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600060028110613f4e57fe5b01541415613fa7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603f815260200180615c5e603f913960400191505060405180910390fd5b60018303855114614003576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526047815260200180615a946047913960600191505060405180910390fd5b6001810184511461405f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603b815260200180615c9d603b913960400191505060405180910390fd5b600091505b8082116141b457601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f4d7d33d8584815181106140b557fe5b60200260200101516040518263ffffffff1660e01b81526004018082600260200280838360005b838110156140f75780820151818401526020810190506140dc565b5050505090500191505060206040518083038186803b15801561411957600080fd5b505afa15801561412d573d6000803e3d6000fd5b505050506040513d602081101561414357600080fd5b81019080805190602001909291905050506141a9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526035815260200180615d076035913960400191505060405180910390fd5b600182019150614064565b848460405160200180838051906020019060200280838360005b838110156141e95780820151818401526020810190506141ce565b505050509050018280516000925b818410156142405782846020026020010151600260200280838360005b8381101561422f578082015181840152602081019050614214565b5050505090500192600101926141f7565b925050509250505060405160208183030381529060405280519060200120600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550836000815181106142ae57fe5b6020026020010151600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906002614303929190615724565b507fa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10336001600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054018787604051808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018060200180602001838103835285818151815260200191508051906020019060200280838360005b838110156143ea5780820151818401526020810190506143cf565b505050509050018381038252848181518152602001915080516000925b818410156144505782846020026020010151600260200280838360005b8381101561443f578082015181840152602081019050614424565b505050509050019260010192614407565b92505050965050505050505060405180910390a15050505b5050565b6000601e60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1684848460405160240180806020018060200180602001848103845287818151815260200191508051906020019060200280838360005b838110156144f85780820151818401526020810190506144dd565b50505050905001848103835286818151815260200191508051906020019060200280838360005b8381101561453a57808201518184015260208101905061451f565b50505050905001848103825285818151815260200191508051906020019060200280838360005b8381101561457c578082015181840152602081019050614561565b5050505090500196505050505050506040516020818303038152906040527fa6872833000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b6020831061463b5780518252602082019150602081019050602083039250614618565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461469b576040519150601f19603f3d011682016040523d82523d6000602084013e6146a0565b606091505b50509050806146fa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180615b6a6031913960400191505060405180910390fd5b50505050565b6004602052816000526040600020816002811061471957fe5b01600091509150505481565b600d8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156147bb5780601f10614790576101008083540402835291602001916147bb565b820191906000526020600020905b81548152906001019060200180831161479e57829003601f168201915b505050505081565b60155481565b600e60009054906101000a900460ff1681565b60026020528060005260406000206000915090505481565b60115481565b6000600f544311614873576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f726567697374726174696f6e206e6f7420636f6d706c6574650000000000000081525060200191505060405180910390fd5b600080549050905090565b4360135410801561489157506014544311155b6148e6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260458152602001806158f86045913960600191505060405180910390fd5b600e60039054906101000a900460ff1661498c576000600960006004811061490a57fe5b015414801561492857506000600960016004811061492457fe5b0154145b801561494357506000600960026004811061493f57fe5b0154145b801561495e57506000600960036004811061495a57fe5b0154145b156149705761496b6151d4565b614f06565b6001600e60036101000a81548160ff0219169083151502179055505b6000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000600481106149d957fe5b0154148015614a3457506000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600160048110614a3057fe5b0154145b8015614a8c57506000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600260048110614a8857fe5b0154145b8015614ae457506000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600360048110614ae057fe5b0154145b614b39576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602f815260200180615cd8602f913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f4d7d33d826040518263ffffffff1660e01b81526004018082600260200280838360005b83811015614bb2578082015181840152602081019050614b97565b5050505090500191505060206040518083038186803b158015614bd457600080fd5b505afa158015614be8573d6000803e3d6000fd5b505050506040513d6020811015614bfe57600080fd5b8101908080519060200190929190505050614c81576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260208152602001807f496e76616c6964207369676e617475726520286e6f74206f6e2063757276652981525060200191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306367587600d83856040518463ffffffff1660e01b8152600401808060200184600260200280838360005b83811015614d01578082015181840152602081019050614ce6565b5050505090500183600460200280838360005b83811015614d2f578082015181840152602081019050614d14565b50505050905001828103825285818154600181600116156101000203166002900481526020019150805460018160011615610100020316600290048015614db75780601f10614d8c57610100808354040283529160200191614db7565b820191906000526020600020905b815481529060010190602001808311614d9a57829003601f168201915b505094505050505060206040518083038186803b158015614dd757600080fd5b505afa158015614deb573d6000803e3d6000fd5b505050506040513d6020811015614e0157600080fd5b8101908080519060200190929190505050614e67576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252604a815260200180615c14604a913960600191505060405180910390fd5b81600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906004614eb5929190615764565b5080600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906002614f04929190615724565b505b5050565b60105481565b60125481565b60098160048110614f2357fe5b016000915090505481565b60086020528060005260406000206000915054906101000a900460ff1681565b60008181548110614f5b57fe5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006060601f60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16836040516024018082600460200280838360005b83811015614ff6578082015181840152602081019050614fdb565b505050509050019150506040516020818303038152906040527ff47ae6a9000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106150b0578051825260208201915060208101905060208303925061508d565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d8060008114615110576040519150601f19603f3d011682016040523d82523d6000602084013e615115565b606091505b509150915081615170576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526034815260200180615a136034913960400191505060405180910390fd5b600081806020019051602081101561518757600080fd5b8101908080519060200190929190505050905080156151a9576151a86151d4565b5b50505050565b600560205281600052604060002081600481106151c857fe5b01600091509150505481565b60004390506017548101600f819055506017546006600f5401016010819055506017546006601054010160118190555060175460066011540101601281905550601754600660125401016013819055506017546006601354010160148190555060175460066014540101601581905550601754600660155401016016819055507f9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e9781600f54601054601154601254601354601454601554601654604051808a8152602001898152602001888152602001878152602001868152602001858152602001848152602001838152602001828152602001995050505050505050505060405180910390a16000600e60006101000a81548160ff0219169083151502179055506000600e60016101000a81548160ff0219169083151502179055506000600e60026101000a81548160ff0219169083151502179055506000600e60036101000a81548160ff0219169083151502179055506000600e60046101000a81548160ff0219169083151502179055506009600061537091906157a4565b5b600080805490501115615653576000806001600080549050038154811061539457fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600061540c91906157c0565b600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009055600360008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600061549a91906157c0565b600460008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006154e591906157c0565b600560008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600061553091906157a4565b600660008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600061557b91906157c0565b600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600760008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009055600080548061561857fe5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055905550615371565b50565b60006156606157ce565b6000602082610180866008600019fa9050806156e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f656c6c69707469632063757276652070616972696e67206661696c656400000081525060200191505060405180910390fd5b6001826000600181106156f357fe5b60200201511492505050919050565b6040518060400160405280600290602082028036833780820191505090505090565b8260028101928215615753579160200282015b82811115615752578251825591602001919060010190615737565b5b50905061576091906157f0565b5090565b8260048101928215615793579160200282015b82811115615792578251825591602001919060010190615777565b5b5090506157a091906157f0565b5090565b5060008155600101600081556001016000815560010160009055565b506000815560010160009055565b6040518060200160405280600190602082028036833780820191505090505090565b61581291905b8082111561580e5760008160009055506001016157f6565b5090565b9056fe726567697374726174696f6e206661696c656420286163636f756e7420616c726561647920726567697374657265642061207075626c6963206b657929736861726520646973747269627574696f6e206661696c65642028636f6e7472616374206973206e6f7420696e20736861726520646973747269627574696f6e2070686173652964697370757465206661696c65642028696e76616c6964207265706c6179206f662073686172696e67207472616e73616374696f6e29726567697374726174696f6e206661696c656420287075626c6963206b65795b315d203d3d20302967706b6a206b6579207375626d697373696f6e206661696c65642028636f6e7472616374206973206e6f7420696e2067706b6a2064657269766174696f6e20706861736529726567697374726174696f6e206661696c65642028636f6e7472616374206973206e6f7420696e20726567697374726174696f6e207068617365296b6579207368617265207375626d697373696f6e206661696c65642028696e76616c6964206b657920736861726520284732292964697370757465206661696c65642028636f6e7472616374206973206e6f7420696e206469737075746520706861736529726567697374726174696f6e206661696c656420287075626c6963206b6579206e6f74206f6e20656c6c69707469632063757276652964656c6567617465642063616c6c206661696c656420666f72207375626d69745f6d61737465725f7075626c69635f6b65792829726567697374726174696f6e206661696c656420287075626c6963206b65795b305d203d3d20302964697370757465206661696c65642028696e76616c6964206c69737420696e646963657329736861726520646973747269627574696f6e206661696c65642028696e76616c6964206e756d626572206f6620656e63727970746564207368617265732070726f76696465642964697370757465206661696c65642028696e76616c696420736861726564206b6579206f722070726f6f662964656c6567617465642063616c6c206661696c656420666f72205375636365737366756c5f436f6d706c6574696f6e28296b6579207368617265207375626d697373696f6e206661696c65642028697373756572206e6f74207175616c69666965642964656c6567617465642063616c6c206661696c656420666f722047726f75705f41636375736174696f6e5f47504b6a28296b6579207368617265207375626d697373696f6e206661696c65642028696e76616c6964206b65792073686172652028473129296b6579207368617265207375626d697373696f6e206661696c65642028636f6e7472616374206973206e6f7420696e206b65792064657269766174696f6e2070686173652947504b6a207375626d697373696f6e206661696c656420287369676e617475726520766572696669636174696f6e206661696c65642064756520746f20696e76616c69642067706b6a29736861726520646973747269627574696f6e206661696c65642028657468657265756d206163636f756e7420686173206e6f742072656769737465726564296b65792073686172696e67206661696c65642028696e76616c6964206e756d626572206f6620636f6d6d69746d656e74732070726f76696465642947504b6a207375626d697373696f6e206661696c65642028616c7265616479207375626d69747465642067706b6a296b65792073686172696e67206661696c65642028636f6d6d69746d656e74206e6f74206f6e20656c6c697074696320637572766529a2646970667358221220ee919bd67f153dfb607d4a2de8f22211e7abbb05af69cc41b16afb78931ccc5964736f6c63430006070033"

// DeployETHDKG deploys a new Ethereum contract, binding an instance of ETHDKG to it.
func DeployETHDKG(auth *bind.TransactOpts, backend bind.ContractBackend, registry_ common.Address) (common.Address, *types.Transaction, *ETHDKG, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ETHDKGBin), backend, registry_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ETHDKG{ETHDKGCaller: ETHDKGCaller{contract: contract}, ETHDKGTransactor: ETHDKGTransactor{contract: contract}, ETHDKGFilterer: ETHDKGFilterer{contract: contract}}, nil
}

// ETHDKG is an auto generated Go binding around an Ethereum contract.
type ETHDKG struct {
	ETHDKGCaller     // Read-only binding to the contract
	ETHDKGTransactor // Write-only binding to the contract
	ETHDKGFilterer   // Log filterer for contract events
}

// ETHDKGCaller is an auto generated read-only Go binding around an Ethereum contract.
type ETHDKGCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ETHDKGTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ETHDKGFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ETHDKGSession struct {
	Contract     *ETHDKG           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ETHDKGCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ETHDKGCallerSession struct {
	Contract *ETHDKGCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ETHDKGTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ETHDKGTransactorSession struct {
	Contract     *ETHDKGTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ETHDKGRaw is an auto generated low-level Go binding around an Ethereum contract.
type ETHDKGRaw struct {
	Contract *ETHDKG // Generic contract binding to access the raw methods on
}

// ETHDKGCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ETHDKGCallerRaw struct {
	Contract *ETHDKGCaller // Generic read-only contract binding to access the raw methods on
}

// ETHDKGTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ETHDKGTransactorRaw struct {
	Contract *ETHDKGTransactor // Generic write-only contract binding to access the raw methods on
}

// NewETHDKG creates a new instance of ETHDKG, bound to a specific deployed contract.
func NewETHDKG(address common.Address, backend bind.ContractBackend) (*ETHDKG, error) {
	contract, err := bindETHDKG(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ETHDKG{ETHDKGCaller: ETHDKGCaller{contract: contract}, ETHDKGTransactor: ETHDKGTransactor{contract: contract}, ETHDKGFilterer: ETHDKGFilterer{contract: contract}}, nil
}

// NewETHDKGCaller creates a new read-only instance of ETHDKG, bound to a specific deployed contract.
func NewETHDKGCaller(address common.Address, caller bind.ContractCaller) (*ETHDKGCaller, error) {
	contract, err := bindETHDKG(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGCaller{contract: contract}, nil
}

// NewETHDKGTransactor creates a new write-only instance of ETHDKG, bound to a specific deployed contract.
func NewETHDKGTransactor(address common.Address, transactor bind.ContractTransactor) (*ETHDKGTransactor, error) {
	contract, err := bindETHDKG(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGTransactor{contract: contract}, nil
}

// NewETHDKGFilterer creates a new log filterer instance of ETHDKG, bound to a specific deployed contract.
func NewETHDKGFilterer(address common.Address, filterer bind.ContractFilterer) (*ETHDKGFilterer, error) {
	contract, err := bindETHDKG(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ETHDKGFilterer{contract: contract}, nil
}

// bindETHDKG binds a generic wrapper to an already deployed contract.
func bindETHDKG(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKG *ETHDKGRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKG.Contract.ETHDKGCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKG *ETHDKGRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKG.Contract.ETHDKGTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKG *ETHDKGRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKG.Contract.ETHDKGTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKG *ETHDKGCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKG.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKG *ETHDKGTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKG.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKG *ETHDKGTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKG.Contract.contract.Transact(opts, method, params...)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) DELTACONFIRM(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "DELTA_CONFIRM")
	return *ret0, err
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKG *ETHDKGSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKG.Contract.DELTACONFIRM(&_ETHDKG.CallOpts)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKG.Contract.DELTACONFIRM(&_ETHDKG.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_DISPUTE_END")
	return *ret0, err
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKG.Contract.TDISPUTEEND(&_ETHDKG.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKG.Contract.TDISPUTEEND(&_ETHDKG.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TDKGCOMPLETE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_DKG_COMPLETE")
	return *ret0, err
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKG.Contract.TDKGCOMPLETE(&_ETHDKG.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKG.Contract.TDKGCOMPLETE(&_ETHDKG.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TGPKJDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_GPKJ_DISPUTE_END")
	return *ret0, err
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKG.Contract.TGPKJDISPUTEEND(&_ETHDKG.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKG.Contract.TGPKJDISPUTEEND(&_ETHDKG.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TGPKJSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_GPKJ_SUBMISSION_END")
	return *ret0, err
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TGPKJSUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TGPKJSUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TKEYSHARESUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_KEY_SHARE_SUBMISSION_END")
	return *ret0, err
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TMPKSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_MPK_SUBMISSION_END")
	return *ret0, err
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TMPKSUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TMPKSUBMISSIONEND(&_ETHDKG.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TREGISTRATIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_REGISTRATION_END")
	return *ret0, err
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TREGISTRATIONEND(&_ETHDKG.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TREGISTRATIONEND(&_ETHDKG.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) TSHAREDISTRIBUTIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "T_SHARE_DISTRIBUTION_END")
	return *ret0, err
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKG *ETHDKGSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKG.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKG.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKG.CallOpts)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKG *ETHDKGCaller) Addresses(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "addresses", arg0)
	return *ret0, err
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKG *ETHDKGSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKG.Contract.Addresses(&_ETHDKG.CallOpts, arg0)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKG *ETHDKGCallerSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKG.Contract.Addresses(&_ETHDKG.CallOpts, arg0)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) Commitments1stCoefficient(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "commitments_1st_coefficient", arg0, arg1)
	return *ret0, err
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.Commitments1stCoefficient(&_ETHDKG.CallOpts, arg0, arg1)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.Commitments1stCoefficient(&_ETHDKG.CallOpts, arg0, arg1)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKG *ETHDKGCaller) CompletionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "completion_check")
	return *ret0, err
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKG *ETHDKGSession) CompletionCheck() (bool, error) {
	return _ETHDKG.Contract.CompletionCheck(&_ETHDKG.CallOpts)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) CompletionCheck() (bool, error) {
	return _ETHDKG.Contract.CompletionCheck(&_ETHDKG.CallOpts)
}

// GetPhaseLength is a free data retrieval call binding the contract method 0x106da57d.
//
// Solidity: function getPhaseLength() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) GetPhaseLength(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "getPhaseLength")
	return *ret0, err
}

// GetPhaseLength is a free data retrieval call binding the contract method 0x106da57d.
//
// Solidity: function getPhaseLength() view returns(uint256)
func (_ETHDKG *ETHDKGSession) GetPhaseLength() (*big.Int, error) {
	return _ETHDKG.Contract.GetPhaseLength(&_ETHDKG.CallOpts)
}

// GetPhaseLength is a free data retrieval call binding the contract method 0x106da57d.
//
// Solidity: function getPhaseLength() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) GetPhaseLength() (*big.Int, error) {
	return _ETHDKG.Contract.GetPhaseLength(&_ETHDKG.CallOpts)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) GpkjSubmissions(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "gpkj_submissions", arg0, arg1)
	return *ret0, err
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.GpkjSubmissions(&_ETHDKG.CallOpts, arg0, arg1)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.GpkjSubmissions(&_ETHDKG.CallOpts, arg0, arg1)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKG *ETHDKGCaller) InitialMessage(opts *bind.CallOpts) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "initial_message")
	return *ret0, err
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKG *ETHDKGSession) InitialMessage() ([]byte, error) {
	return _ETHDKG.Contract.InitialMessage(&_ETHDKG.CallOpts)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKG *ETHDKGCallerSession) InitialMessage() ([]byte, error) {
	return _ETHDKG.Contract.InitialMessage(&_ETHDKG.CallOpts)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) InitialSignatures(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "initial_signatures", arg0, arg1)
	return *ret0, err
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.InitialSignatures(&_ETHDKG.CallOpts, arg0, arg1)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.InitialSignatures(&_ETHDKG.CallOpts, arg0, arg1)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKG *ETHDKGCaller) IsMalicious(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "is_malicious", arg0)
	return *ret0, err
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKG *ETHDKGSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKG.Contract.IsMalicious(&_ETHDKG.CallOpts, arg0)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKG.Contract.IsMalicious(&_ETHDKG.CallOpts, arg0)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGCaller) KeyShareSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "key_share_submission_check")
	return *ret0, err
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKG.Contract.KeyShareSubmissionCheck(&_ETHDKG.CallOpts)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKG.Contract.KeyShareSubmissionCheck(&_ETHDKG.CallOpts)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) KeyShares(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "key_shares", arg0, arg1)
	return *ret0, err
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.KeyShares(&_ETHDKG.CallOpts, arg0, arg1)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.KeyShares(&_ETHDKG.CallOpts, arg0, arg1)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) MasterPublicKey(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "master_public_key", arg0)
	return *ret0, err
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.MasterPublicKey(&_ETHDKG.CallOpts, arg0)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.MasterPublicKey(&_ETHDKG.CallOpts, arg0)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGCaller) MpkSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "mpk_submission_check")
	return *ret0, err
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKG.Contract.MpkSubmissionCheck(&_ETHDKG.CallOpts)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKG.Contract.MpkSubmissionCheck(&_ETHDKG.CallOpts)
}

// NumberOfRegistrations is a free data retrieval call binding the contract method 0xd8f63eb7.
//
// Solidity: function numberOfRegistrations() view returns(uint256)
func (_ETHDKG *ETHDKGCaller) NumberOfRegistrations(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "numberOfRegistrations")
	return *ret0, err
}

// NumberOfRegistrations is a free data retrieval call binding the contract method 0xd8f63eb7.
//
// Solidity: function numberOfRegistrations() view returns(uint256)
func (_ETHDKG *ETHDKGSession) NumberOfRegistrations() (*big.Int, error) {
	return _ETHDKG.Contract.NumberOfRegistrations(&_ETHDKG.CallOpts)
}

// NumberOfRegistrations is a free data retrieval call binding the contract method 0xd8f63eb7.
//
// Solidity: function numberOfRegistrations() view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) NumberOfRegistrations() (*big.Int, error) {
	return _ETHDKG.Contract.NumberOfRegistrations(&_ETHDKG.CallOpts)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCaller) PublicKeys(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "public_keys", arg0, arg1)
	return *ret0, err
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.PublicKeys(&_ETHDKG.CallOpts, arg0, arg1)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKG *ETHDKGCallerSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKG.Contract.PublicKeys(&_ETHDKG.CallOpts, arg0, arg1)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKG *ETHDKGCaller) RegistrationCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "registration_check")
	return *ret0, err
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKG *ETHDKGSession) RegistrationCheck() (bool, error) {
	return _ETHDKG.Contract.RegistrationCheck(&_ETHDKG.CallOpts)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) RegistrationCheck() (bool, error) {
	return _ETHDKG.Contract.RegistrationCheck(&_ETHDKG.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKG *ETHDKGCaller) ShareDistributionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "share_distribution_check")
	return *ret0, err
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKG *ETHDKGSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKG.Contract.ShareDistributionCheck(&_ETHDKG.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKG *ETHDKGCallerSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKG.Contract.ShareDistributionCheck(&_ETHDKG.CallOpts)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKG *ETHDKGCaller) ShareDistributionHashes(opts *bind.CallOpts, arg0 common.Address) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ETHDKG.contract.Call(opts, out, "share_distribution_hashes", arg0)
	return *ret0, err
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKG *ETHDKGSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKG.Contract.ShareDistributionHashes(&_ETHDKG.CallOpts, arg0)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKG *ETHDKGCallerSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKG.Contract.ShareDistributionHashes(&_ETHDKG.CallOpts, arg0)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKG *ETHDKGTransactor) GroupAccusationGPKj(opts *bind.TransactOpts, invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "Group_Accusation_GPKj", invArray, honestIndices, dishonestIndices)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKG *ETHDKGSession) GroupAccusationGPKj(invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.GroupAccusationGPKj(&_ETHDKG.TransactOpts, invArray, honestIndices, dishonestIndices)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKG *ETHDKGTransactorSession) GroupAccusationGPKj(invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.GroupAccusationGPKj(&_ETHDKG.TransactOpts, invArray, honestIndices, dishonestIndices)
}

// SubmitGPKj is a paid mutator transaction binding the contract method 0xdc5e8a0a.
//
// Solidity: function Submit_GPKj(uint256[4] gpkj, uint256[2] sig) returns()
func (_ETHDKG *ETHDKGTransactor) SubmitGPKj(opts *bind.TransactOpts, gpkj [4]*big.Int, sig [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "Submit_GPKj", gpkj, sig)
}

// SubmitGPKj is a paid mutator transaction binding the contract method 0xdc5e8a0a.
//
// Solidity: function Submit_GPKj(uint256[4] gpkj, uint256[2] sig) returns()
func (_ETHDKG *ETHDKGSession) SubmitGPKj(gpkj [4]*big.Int, sig [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitGPKj(&_ETHDKG.TransactOpts, gpkj, sig)
}

// SubmitGPKj is a paid mutator transaction binding the contract method 0xdc5e8a0a.
//
// Solidity: function Submit_GPKj(uint256[4] gpkj, uint256[2] sig) returns()
func (_ETHDKG *ETHDKGTransactorSession) SubmitGPKj(gpkj [4]*big.Int, sig [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitGPKj(&_ETHDKG.TransactOpts, gpkj, sig)
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns()
func (_ETHDKG *ETHDKGTransactor) SuccessfulCompletion(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "Successful_Completion")
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns()
func (_ETHDKG *ETHDKGSession) SuccessfulCompletion() (*types.Transaction, error) {
	return _ETHDKG.Contract.SuccessfulCompletion(&_ETHDKG.TransactOpts)
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns()
func (_ETHDKG *ETHDKGTransactorSession) SuccessfulCompletion() (*types.Transaction, error) {
	return _ETHDKG.Contract.SuccessfulCompletion(&_ETHDKG.TransactOpts)
}

// DistributeShares is a paid mutator transaction binding the contract method 0xa080e5e0.
//
// Solidity: function distribute_shares(uint256[] encrypted_shares, uint256[2][] commitments) returns()
func (_ETHDKG *ETHDKGTransactor) DistributeShares(opts *bind.TransactOpts, encrypted_shares []*big.Int, commitments [][2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "distribute_shares", encrypted_shares, commitments)
}

// DistributeShares is a paid mutator transaction binding the contract method 0xa080e5e0.
//
// Solidity: function distribute_shares(uint256[] encrypted_shares, uint256[2][] commitments) returns()
func (_ETHDKG *ETHDKGSession) DistributeShares(encrypted_shares []*big.Int, commitments [][2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.DistributeShares(&_ETHDKG.TransactOpts, encrypted_shares, commitments)
}

// DistributeShares is a paid mutator transaction binding the contract method 0xa080e5e0.
//
// Solidity: function distribute_shares(uint256[] encrypted_shares, uint256[2][] commitments) returns()
func (_ETHDKG *ETHDKGTransactorSession) DistributeShares(encrypted_shares []*big.Int, commitments [][2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.DistributeShares(&_ETHDKG.TransactOpts, encrypted_shares, commitments)
}

// InitializeState is a paid mutator transaction binding the contract method 0x82571195.
//
// Solidity: function initializeState() returns()
func (_ETHDKG *ETHDKGTransactor) InitializeState(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "initializeState")
}

// InitializeState is a paid mutator transaction binding the contract method 0x82571195.
//
// Solidity: function initializeState() returns()
func (_ETHDKG *ETHDKGSession) InitializeState() (*types.Transaction, error) {
	return _ETHDKG.Contract.InitializeState(&_ETHDKG.TransactOpts)
}

// InitializeState is a paid mutator transaction binding the contract method 0x82571195.
//
// Solidity: function initializeState() returns()
func (_ETHDKG *ETHDKGTransactorSession) InitializeState() (*types.Transaction, error) {
	return _ETHDKG.Contract.InitializeState(&_ETHDKG.TransactOpts)
}

// Register is a paid mutator transaction binding the contract method 0x3442af5c.
//
// Solidity: function register(uint256[2] public_key) returns()
func (_ETHDKG *ETHDKGTransactor) Register(opts *bind.TransactOpts, public_key [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "register", public_key)
}

// Register is a paid mutator transaction binding the contract method 0x3442af5c.
//
// Solidity: function register(uint256[2] public_key) returns()
func (_ETHDKG *ETHDKGSession) Register(public_key [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.Register(&_ETHDKG.TransactOpts, public_key)
}

// Register is a paid mutator transaction binding the contract method 0x3442af5c.
//
// Solidity: function register(uint256[2] public_key) returns()
func (_ETHDKG *ETHDKGTransactorSession) Register(public_key [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.Register(&_ETHDKG.TransactOpts, public_key)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_ETHDKG *ETHDKGTransactor) ReloadRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "reloadRegistry")
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_ETHDKG *ETHDKGSession) ReloadRegistry() (*types.Transaction, error) {
	return _ETHDKG.Contract.ReloadRegistry(&_ETHDKG.TransactOpts)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_ETHDKG *ETHDKGTransactorSession) ReloadRegistry() (*types.Transaction, error) {
	return _ETHDKG.Contract.ReloadRegistry(&_ETHDKG.TransactOpts)
}

// SubmitDispute is a paid mutator transaction binding the contract method 0x2f123ffc.
//
// Solidity: function submit_dispute(address issuer, uint256 issuer_list_idx, uint256 disputer_list_idx, uint256[] encrypted_shares, uint256[2][] commitments, uint256[2] shared_key, uint256[2] shared_key_correctness_proof) returns()
func (_ETHDKG *ETHDKGTransactor) SubmitDispute(opts *bind.TransactOpts, issuer common.Address, issuer_list_idx *big.Int, disputer_list_idx *big.Int, encrypted_shares []*big.Int, commitments [][2]*big.Int, shared_key [2]*big.Int, shared_key_correctness_proof [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "submit_dispute", issuer, issuer_list_idx, disputer_list_idx, encrypted_shares, commitments, shared_key, shared_key_correctness_proof)
}

// SubmitDispute is a paid mutator transaction binding the contract method 0x2f123ffc.
//
// Solidity: function submit_dispute(address issuer, uint256 issuer_list_idx, uint256 disputer_list_idx, uint256[] encrypted_shares, uint256[2][] commitments, uint256[2] shared_key, uint256[2] shared_key_correctness_proof) returns()
func (_ETHDKG *ETHDKGSession) SubmitDispute(issuer common.Address, issuer_list_idx *big.Int, disputer_list_idx *big.Int, encrypted_shares []*big.Int, commitments [][2]*big.Int, shared_key [2]*big.Int, shared_key_correctness_proof [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitDispute(&_ETHDKG.TransactOpts, issuer, issuer_list_idx, disputer_list_idx, encrypted_shares, commitments, shared_key, shared_key_correctness_proof)
}

// SubmitDispute is a paid mutator transaction binding the contract method 0x2f123ffc.
//
// Solidity: function submit_dispute(address issuer, uint256 issuer_list_idx, uint256 disputer_list_idx, uint256[] encrypted_shares, uint256[2][] commitments, uint256[2] shared_key, uint256[2] shared_key_correctness_proof) returns()
func (_ETHDKG *ETHDKGTransactorSession) SubmitDispute(issuer common.Address, issuer_list_idx *big.Int, disputer_list_idx *big.Int, encrypted_shares []*big.Int, commitments [][2]*big.Int, shared_key [2]*big.Int, shared_key_correctness_proof [2]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitDispute(&_ETHDKG.TransactOpts, issuer, issuer_list_idx, disputer_list_idx, encrypted_shares, commitments, shared_key, shared_key_correctness_proof)
}

// SubmitKeyShare is a paid mutator transaction binding the contract method 0x7163525e.
//
// Solidity: function submit_key_share(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2) returns()
func (_ETHDKG *ETHDKGTransactor) SubmitKeyShare(opts *bind.TransactOpts, issuer common.Address, key_share_G1 [2]*big.Int, key_share_G1_correctness_proof [2]*big.Int, key_share_G2 [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "submit_key_share", issuer, key_share_G1, key_share_G1_correctness_proof, key_share_G2)
}

// SubmitKeyShare is a paid mutator transaction binding the contract method 0x7163525e.
//
// Solidity: function submit_key_share(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2) returns()
func (_ETHDKG *ETHDKGSession) SubmitKeyShare(issuer common.Address, key_share_G1 [2]*big.Int, key_share_G1_correctness_proof [2]*big.Int, key_share_G2 [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitKeyShare(&_ETHDKG.TransactOpts, issuer, key_share_G1, key_share_G1_correctness_proof, key_share_G2)
}

// SubmitKeyShare is a paid mutator transaction binding the contract method 0x7163525e.
//
// Solidity: function submit_key_share(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2) returns()
func (_ETHDKG *ETHDKGTransactorSession) SubmitKeyShare(issuer common.Address, key_share_G1 [2]*big.Int, key_share_G1_correctness_proof [2]*big.Int, key_share_G2 [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitKeyShare(&_ETHDKG.TransactOpts, issuer, key_share_G1, key_share_G1_correctness_proof, key_share_G2)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns()
func (_ETHDKG *ETHDKGTransactor) SubmitMasterPublicKey(opts *bind.TransactOpts, _master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "submit_master_public_key", _master_public_key)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns()
func (_ETHDKG *ETHDKGSession) SubmitMasterPublicKey(_master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitMasterPublicKey(&_ETHDKG.TransactOpts, _master_public_key)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns()
func (_ETHDKG *ETHDKGTransactorSession) SubmitMasterPublicKey(_master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.SubmitMasterPublicKey(&_ETHDKG.TransactOpts, _master_public_key)
}

// UpdatePhaseLength is a paid mutator transaction binding the contract method 0x2a702773.
//
// Solidity: function updatePhaseLength(uint256 newDelta) returns()
func (_ETHDKG *ETHDKGTransactor) UpdatePhaseLength(opts *bind.TransactOpts, newDelta *big.Int) (*types.Transaction, error) {
	return _ETHDKG.contract.Transact(opts, "updatePhaseLength", newDelta)
}

// UpdatePhaseLength is a paid mutator transaction binding the contract method 0x2a702773.
//
// Solidity: function updatePhaseLength(uint256 newDelta) returns()
func (_ETHDKG *ETHDKGSession) UpdatePhaseLength(newDelta *big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.UpdatePhaseLength(&_ETHDKG.TransactOpts, newDelta)
}

// UpdatePhaseLength is a paid mutator transaction binding the contract method 0x2a702773.
//
// Solidity: function updatePhaseLength(uint256 newDelta) returns()
func (_ETHDKG *ETHDKGTransactorSession) UpdatePhaseLength(newDelta *big.Int) (*types.Transaction, error) {
	return _ETHDKG.Contract.UpdatePhaseLength(&_ETHDKG.TransactOpts, newDelta)
}

// ETHDKGKeyShareSubmissionIterator is returned from FilterKeyShareSubmission and is used to iterate over the raw logs and unpacked data for KeyShareSubmission events raised by the ETHDKG contract.
type ETHDKGKeyShareSubmissionIterator struct {
	Event *ETHDKGKeyShareSubmission // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGKeyShareSubmissionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGKeyShareSubmission)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGKeyShareSubmission)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGKeyShareSubmissionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGKeyShareSubmissionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGKeyShareSubmission represents a KeyShareSubmission event raised by the ETHDKG contract.
type ETHDKGKeyShareSubmission struct {
	Issuer                     common.Address
	KeyShareG1                 [2]*big.Int
	KeyShareG1CorrectnessProof [2]*big.Int
	KeyShareG2                 [4]*big.Int
	Raw                        types.Log // Blockchain specific contextual infos
}

// FilterKeyShareSubmission is a free log retrieval operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKG *ETHDKGFilterer) FilterKeyShareSubmission(opts *bind.FilterOpts) (*ETHDKGKeyShareSubmissionIterator, error) {

	logs, sub, err := _ETHDKG.contract.FilterLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return &ETHDKGKeyShareSubmissionIterator{contract: _ETHDKG.contract, event: "KeyShareSubmission", logs: logs, sub: sub}, nil
}

// WatchKeyShareSubmission is a free log subscription operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKG *ETHDKGFilterer) WatchKeyShareSubmission(opts *bind.WatchOpts, sink chan<- *ETHDKGKeyShareSubmission) (event.Subscription, error) {

	logs, sub, err := _ETHDKG.contract.WatchLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGKeyShareSubmission)
				if err := _ETHDKG.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeyShareSubmission is a log parse operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKG *ETHDKGFilterer) ParseKeyShareSubmission(log types.Log) (*ETHDKGKeyShareSubmission, error) {
	event := new(ETHDKGKeyShareSubmission)
	if err := _ETHDKG.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGRegistrationOpenIterator is returned from FilterRegistrationOpen and is used to iterate over the raw logs and unpacked data for RegistrationOpen events raised by the ETHDKG contract.
type ETHDKGRegistrationOpenIterator struct {
	Event *ETHDKGRegistrationOpen // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGRegistrationOpenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGRegistrationOpen)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGRegistrationOpen)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGRegistrationOpenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGRegistrationOpenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGRegistrationOpen represents a RegistrationOpen event raised by the ETHDKG contract.
type ETHDKGRegistrationOpen struct {
	DkgStarts              *big.Int
	RegistrationEnds       *big.Int
	ShareDistributionEnds  *big.Int
	DisputeEnds            *big.Int
	KeyShareSubmissionEnds *big.Int
	MpkSubmissionEnds      *big.Int
	GpkjSubmissionEnds     *big.Int
	GpkjDisputeEnds        *big.Int
	DkgComplete            *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterRegistrationOpen is a free log retrieval operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKG *ETHDKGFilterer) FilterRegistrationOpen(opts *bind.FilterOpts) (*ETHDKGRegistrationOpenIterator, error) {

	logs, sub, err := _ETHDKG.contract.FilterLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return &ETHDKGRegistrationOpenIterator{contract: _ETHDKG.contract, event: "RegistrationOpen", logs: logs, sub: sub}, nil
}

// WatchRegistrationOpen is a free log subscription operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKG *ETHDKGFilterer) WatchRegistrationOpen(opts *bind.WatchOpts, sink chan<- *ETHDKGRegistrationOpen) (event.Subscription, error) {

	logs, sub, err := _ETHDKG.contract.WatchLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGRegistrationOpen)
				if err := _ETHDKG.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrationOpen is a log parse operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKG *ETHDKGFilterer) ParseRegistrationOpen(log types.Log) (*ETHDKGRegistrationOpen, error) {
	event := new(ETHDKGRegistrationOpen)
	if err := _ETHDKG.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGShareDistributionIterator is returned from FilterShareDistribution and is used to iterate over the raw logs and unpacked data for ShareDistribution events raised by the ETHDKG contract.
type ETHDKGShareDistributionIterator struct {
	Event *ETHDKGShareDistribution // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGShareDistributionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGShareDistribution)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGShareDistribution)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGShareDistributionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGShareDistributionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGShareDistribution represents a ShareDistribution event raised by the ETHDKG contract.
type ETHDKGShareDistribution struct {
	Issuer          common.Address
	Index           *big.Int
	EncryptedShares []*big.Int
	Commitments     [][2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterShareDistribution is a free log retrieval operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKG *ETHDKGFilterer) FilterShareDistribution(opts *bind.FilterOpts) (*ETHDKGShareDistributionIterator, error) {

	logs, sub, err := _ETHDKG.contract.FilterLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return &ETHDKGShareDistributionIterator{contract: _ETHDKG.contract, event: "ShareDistribution", logs: logs, sub: sub}, nil
}

// WatchShareDistribution is a free log subscription operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKG *ETHDKGFilterer) WatchShareDistribution(opts *bind.WatchOpts, sink chan<- *ETHDKGShareDistribution) (event.Subscription, error) {

	logs, sub, err := _ETHDKG.contract.WatchLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGShareDistribution)
				if err := _ETHDKG.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseShareDistribution is a log parse operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKG *ETHDKGFilterer) ParseShareDistribution(log types.Log) (*ETHDKGShareDistribution, error) {
	event := new(ETHDKGShareDistribution)
	if err := _ETHDKG.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGValidatorMemberIterator is returned from FilterValidatorMember and is used to iterate over the raw logs and unpacked data for ValidatorMember events raised by the ETHDKG contract.
type ETHDKGValidatorMemberIterator struct {
	Event *ETHDKGValidatorMember // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGValidatorMemberIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGValidatorMember)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGValidatorMember)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGValidatorMemberIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGValidatorMemberIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGValidatorMember represents a ValidatorMember event raised by the ETHDKG contract.
type ETHDKGValidatorMember struct {
	Account common.Address
	Epoch   *big.Int
	Index   *big.Int
	Share0  *big.Int
	Share1  *big.Int
	Share2  *big.Int
	Share3  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterValidatorMember is a free log retrieval operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKG *ETHDKGFilterer) FilterValidatorMember(opts *bind.FilterOpts) (*ETHDKGValidatorMemberIterator, error) {

	logs, sub, err := _ETHDKG.contract.FilterLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return &ETHDKGValidatorMemberIterator{contract: _ETHDKG.contract, event: "ValidatorMember", logs: logs, sub: sub}, nil
}

// WatchValidatorMember is a free log subscription operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKG *ETHDKGFilterer) WatchValidatorMember(opts *bind.WatchOpts, sink chan<- *ETHDKGValidatorMember) (event.Subscription, error) {

	logs, sub, err := _ETHDKG.contract.WatchLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGValidatorMember)
				if err := _ETHDKG.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorMember is a log parse operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKG *ETHDKGFilterer) ParseValidatorMember(log types.Log) (*ETHDKGValidatorMember, error) {
	event := new(ETHDKGValidatorMember)
	if err := _ETHDKG.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGValidatorSetIterator is returned from FilterValidatorSet and is used to iterate over the raw logs and unpacked data for ValidatorSet events raised by the ETHDKG contract.
type ETHDKGValidatorSetIterator struct {
	Event *ETHDKGValidatorSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGValidatorSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGValidatorSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGValidatorSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGValidatorSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGValidatorSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGValidatorSet represents a ValidatorSet event raised by the ETHDKG contract.
type ETHDKGValidatorSet struct {
	ValidatorCount uint8
	Epoch          *big.Int
	EthHeight      uint32
	MadHeight      uint32
	GroupKey0      *big.Int
	GroupKey1      *big.Int
	GroupKey2      *big.Int
	GroupKey3      *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterValidatorSet is a free log retrieval operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKG *ETHDKGFilterer) FilterValidatorSet(opts *bind.FilterOpts) (*ETHDKGValidatorSetIterator, error) {

	logs, sub, err := _ETHDKG.contract.FilterLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return &ETHDKGValidatorSetIterator{contract: _ETHDKG.contract, event: "ValidatorSet", logs: logs, sub: sub}, nil
}

// WatchValidatorSet is a free log subscription operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKG *ETHDKGFilterer) WatchValidatorSet(opts *bind.WatchOpts, sink chan<- *ETHDKGValidatorSet) (event.Subscription, error) {

	logs, sub, err := _ETHDKG.contract.WatchLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGValidatorSet)
				if err := _ETHDKG.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorSet is a log parse operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKG *ETHDKGFilterer) ParseValidatorSet(log types.Log) (*ETHDKGValidatorSet, error) {
	event := new(ETHDKGValidatorSet)
	if err := _ETHDKG.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGCompletionABI is the input ABI used to generate the binding from.
const ETHDKGCompletionABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"KeyShareSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgStarts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareDistributionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyShareSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mpkSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjDisputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgComplete\",\"type\":\"uint256\"}],\"name\":\"RegistrationOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"ShareDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share3\",\"type\":\"uint256\"}],\"name\":\"ValidatorMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"validatorCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ethHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"madHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey3\",\"type\":\"uint256\"}],\"name\":\"ValidatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELTA_CONFIRM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Successful_Completion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DKG_COMPLETE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_KEY_SHARE_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_MPK_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REGISTRATION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SHARE_DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments_1st_coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completion_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gpkj_submissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_message\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_signatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_malicious\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"key_share_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"key_shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"master_public_key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpk_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"public_keys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registration_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share_distribution_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_distribution_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ETHDKGCompletionBin is the compiled bytecode used for deploying new contracts.
var ETHDKGCompletionBin = "0x608060405260405160200180807f43727970746f67726170687920697320677265617400000000000000000000008152506015019050604051602081830303815290604052600d90805190602001906200005b92919062000075565b5060286017553480156200006e57600080fd5b5062000124565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000b857805160ff1916838001178555620000e9565b82800160010185558215620000e9579182015b82811115620000e8578251825591602001919060010190620000cb565b5b509050620000f89190620000fc565b5090565b6200012191905b808211156200011d57600081600090555060010162000103565b5090565b90565b6114a680620001346000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c80639c2aa838116100de578063d3cf618611610097578063e651137811610071578063e6511378146105b5578063eadfcadc146105f7578063edf26d9b14610653578063fef001a9146106c157610173565b8063d3cf61861461055b578063dc614e2814610579578063e2291ec31461059757610173565b80639c2aa838146103c0578063a88c9e1c146103de578063aa7bd33814610440578063ab63c722146104c3578063b7b09ed6146104e1578063c21bee831461050357610173565b80637328f826116101305780637328f8261461027c5780637543b80f146102de57806375f7ed6a146102fc57806377fbebd11461031e578063836889dc1461033c57806392896b2d1461035e57610173565b8063050a54f01461017857806307f02c541461019a5780630de1553f146101b85780632cf4050b146101d65780632f11b9851461023857806365c97c011461025a575b600080fd5b610180610723565b604051808215151515815260200191505060405180910390f35b6101a2610736565b6040518082815260200191505060405180910390f35b6101c061073c565b6040518082815260200191505060405180910390f35b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610742565b6040518082815260200191505060405180910390f35b610240610767565b604051808215151515815260200191505060405180910390f35b61026261077a565b604051808215151515815260200191505060405180910390f35b6102c86004803603604081101561029257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061120b565b6040518082815260200191505060405180910390f35b6102e6611230565b6040518082815260200191505060405180910390f35b610304611235565b604051808215151515815260200191505060405180910390f35b610326611248565b6040518082815260200191505060405180910390f35b61034461124e565b604051808215151515815260200191505060405180910390f35b6103aa6004803603604081101561037457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611261565b6040518082815260200191505060405180910390f35b6103c8611286565b6040518082815260200191505060405180910390f35b61042a600480360360408110156103f457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061128c565b6040518082815260200191505060405180910390f35b6104486112b1565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561048857808201518184015260208101905061046d565b50505050905090810190601f1680156104b55780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6104cb61134f565b6040518082815260200191505060405180910390f35b6104e9611355565b604051808215151515815260200191505060405180910390f35b6105456004803603602081101561051957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611368565b6040518082815260200191505060405180910390f35b610563611380565b6040518082815260200191505060405180910390f35b610581611386565b6040518082815260200191505060405180910390f35b61059f61138c565b6040518082815260200191505060405180910390f35b6105e1600480360360208110156105cb57600080fd5b8101908080359060200190929190505050611392565b6040518082815260200191505060405180910390f35b6106396004803603602081101561060d57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506113aa565b604051808215151515815260200191505060405180910390f35b61067f6004803603602081101561066957600080fd5b81019080803590602001909291905050506113ca565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61070d600480360360408110156106d757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611406565b6040518082815260200191505060405180910390f35b600e60039054906101000a900460ff1681565b60135481565b600f5481565b6003602052816000526040600020816002811061075b57fe5b01600091509150505481565b600e60019054906101000a900460ff1681565b60004360155410801561078f57506016544311155b6107e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252604581526020018061142c6045913960600191505060405180910390fd5b6000809050600e60049054906101000a900460ff166112045760006001905060005b600080549050811015610b8857600080828154811061082157fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006004811061089b57fe5b01541480156108f657506000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001600481106108f257fe5b0154145b801561094e57506000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060026004811061094a57fe5b0154145b80156109a657506000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206003600481106109a257fe5b0154145b15610b7a57600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615610abb57601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166357b4f82a826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015610a9e57600080fd5b505af1158015610ab2573d6000803e3d6000fd5b50505050610b75565b601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d2a2c55c826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015610b5c57600080fd5b505af1158015610b70573d6000803e3d6000fd5b505050505b600092505b508080600101915050610806565b5080610b975760019150611202565b6001600e60046101000a81548160ff02191690831515021790555060006001601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663900cf0cf6040518163ffffffff1660e01b815260040160206040518083038186803b158015610c1e57600080fd5b505afa158015610c32573d6000803e3d6000fd5b505050506040513d6020811015610c4857600080fd5b81019080805190602001909291905050500390506000601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e380b228836040518263ffffffff1660e01b8152600401808263ffffffff16815260200191505060206040518083038186803b158015610cd757600080fd5b505afa158015610ceb573d6000803e3d6000fd5b505050506040513d6020811015610d0157600080fd5b810190808051906020019092919050505090506000601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634f4ea614846040518263ffffffff1660e01b8152600401808263ffffffff16815260200191505060206040518083038186803b158015610d8f57600080fd5b505afa158015610da3573d6000803e3d6000fd5b505050506040513d6020811015610db957600080fd5b810190808051906020019092919050505090507f1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f600080549050601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663900cf0cf6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e5b57600080fd5b505afa158015610e6f573d6000803e3d6000fd5b505050506040513d6020811015610e8557600080fd5b810190808051906020019092919050505084846009600060048110610ea657fe5b01546009600160048110610eb657fe5b01546009600260048110610ec657fe5b01546009600360048110610ed657fe5b0154604051808960ff1660ff1681526020018881526020018763ffffffff1663ffffffff1681526020018663ffffffff1663ffffffff1681526020018581526020018481526020018381526020018281526020019850505050505050505060405180910390a160005b6000805490508110156111fd576000808281548110610f5a57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690507f113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b081601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663900cf0cf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561101157600080fd5b505afa158015611025573d6000803e3d6000fd5b505050506040513d602081101561103b57600080fd5b810190808051906020019092919050505060018501600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006004811061109b57fe5b0154600560008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001600481106110e857fe5b0154600560008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060026004811061113557fe5b0154600560008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060036004811061118257fe5b0154604051808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200187815260200186815260200185815260200184815260200183815260200182815260200197505050505050505060405180910390a1508080600101915050610f3f565b505050505b505b8091505090565b6006602052816000526040600020816002811061122457fe5b01600091509150505481565b600681565b600e60049054906101000a900460ff1681565b60165481565b600e60029054906101000a900460ff1681565b6001602052816000526040600020816002811061127a57fe5b01600091509150505481565b60145481565b600460205281600052604060002081600281106112a557fe5b01600091509150505481565b600d8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156113475780601f1061131c57610100808354040283529160200191611347565b820191906000526020600020905b81548152906001019060200180831161132a57829003601f168201915b505050505081565b60155481565b600e60009054906101000a900460ff1681565b60026020528060005260406000206000915090505481565b60115481565b60105481565b60125481565b6009816004811061139f57fe5b016000915090505481565b60086020528060005260406000206000915054906101000a900460ff1681565b600081815481106113d757fe5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6005602052816000526040600020816004811061141f57fe5b0160009150915050548156fe7375636365737366756c20636f6d706c6574696f6e206973206f6e6c792061667465722077696e646f7720666f722061636375736174696f6e732068617320636c6f736564a2646970667358221220f73dd213396ce781325d551dbc41473f83f5ab9dd4471218c101510d85927d5e64736f6c63430006070033"

// DeployETHDKGCompletion deploys a new Ethereum contract, binding an instance of ETHDKGCompletion to it.
func DeployETHDKGCompletion(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ETHDKGCompletion, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGCompletionABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ETHDKGCompletionBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ETHDKGCompletion{ETHDKGCompletionCaller: ETHDKGCompletionCaller{contract: contract}, ETHDKGCompletionTransactor: ETHDKGCompletionTransactor{contract: contract}, ETHDKGCompletionFilterer: ETHDKGCompletionFilterer{contract: contract}}, nil
}

// ETHDKGCompletion is an auto generated Go binding around an Ethereum contract.
type ETHDKGCompletion struct {
	ETHDKGCompletionCaller     // Read-only binding to the contract
	ETHDKGCompletionTransactor // Write-only binding to the contract
	ETHDKGCompletionFilterer   // Log filterer for contract events
}

// ETHDKGCompletionCaller is an auto generated read-only Go binding around an Ethereum contract.
type ETHDKGCompletionCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGCompletionTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ETHDKGCompletionTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGCompletionFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ETHDKGCompletionFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGCompletionSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ETHDKGCompletionSession struct {
	Contract     *ETHDKGCompletion // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ETHDKGCompletionCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ETHDKGCompletionCallerSession struct {
	Contract *ETHDKGCompletionCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ETHDKGCompletionTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ETHDKGCompletionTransactorSession struct {
	Contract     *ETHDKGCompletionTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ETHDKGCompletionRaw is an auto generated low-level Go binding around an Ethereum contract.
type ETHDKGCompletionRaw struct {
	Contract *ETHDKGCompletion // Generic contract binding to access the raw methods on
}

// ETHDKGCompletionCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ETHDKGCompletionCallerRaw struct {
	Contract *ETHDKGCompletionCaller // Generic read-only contract binding to access the raw methods on
}

// ETHDKGCompletionTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ETHDKGCompletionTransactorRaw struct {
	Contract *ETHDKGCompletionTransactor // Generic write-only contract binding to access the raw methods on
}

// NewETHDKGCompletion creates a new instance of ETHDKGCompletion, bound to a specific deployed contract.
func NewETHDKGCompletion(address common.Address, backend bind.ContractBackend) (*ETHDKGCompletion, error) {
	contract, err := bindETHDKGCompletion(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletion{ETHDKGCompletionCaller: ETHDKGCompletionCaller{contract: contract}, ETHDKGCompletionTransactor: ETHDKGCompletionTransactor{contract: contract}, ETHDKGCompletionFilterer: ETHDKGCompletionFilterer{contract: contract}}, nil
}

// NewETHDKGCompletionCaller creates a new read-only instance of ETHDKGCompletion, bound to a specific deployed contract.
func NewETHDKGCompletionCaller(address common.Address, caller bind.ContractCaller) (*ETHDKGCompletionCaller, error) {
	contract, err := bindETHDKGCompletion(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionCaller{contract: contract}, nil
}

// NewETHDKGCompletionTransactor creates a new write-only instance of ETHDKGCompletion, bound to a specific deployed contract.
func NewETHDKGCompletionTransactor(address common.Address, transactor bind.ContractTransactor) (*ETHDKGCompletionTransactor, error) {
	contract, err := bindETHDKGCompletion(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionTransactor{contract: contract}, nil
}

// NewETHDKGCompletionFilterer creates a new log filterer instance of ETHDKGCompletion, bound to a specific deployed contract.
func NewETHDKGCompletionFilterer(address common.Address, filterer bind.ContractFilterer) (*ETHDKGCompletionFilterer, error) {
	contract, err := bindETHDKGCompletion(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionFilterer{contract: contract}, nil
}

// bindETHDKGCompletion binds a generic wrapper to an already deployed contract.
func bindETHDKGCompletion(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGCompletionABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGCompletion *ETHDKGCompletionRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGCompletion.Contract.ETHDKGCompletionCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGCompletion *ETHDKGCompletionRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.ETHDKGCompletionTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGCompletion *ETHDKGCompletionRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.ETHDKGCompletionTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGCompletion *ETHDKGCompletionCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGCompletion.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGCompletion *ETHDKGCompletionTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGCompletion *ETHDKGCompletionTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.contract.Transact(opts, method, params...)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) DELTACONFIRM(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "DELTA_CONFIRM")
	return *ret0, err
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.DELTACONFIRM(&_ETHDKGCompletion.CallOpts)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.DELTACONFIRM(&_ETHDKGCompletion.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_DISPUTE_END")
	return *ret0, err
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TDISPUTEEND(&_ETHDKGCompletion.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TDISPUTEEND(&_ETHDKGCompletion.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TDKGCOMPLETE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_DKG_COMPLETE")
	return *ret0, err
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TDKGCOMPLETE(&_ETHDKGCompletion.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TDKGCOMPLETE(&_ETHDKGCompletion.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TGPKJDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_GPKJ_DISPUTE_END")
	return *ret0, err
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TGPKJDISPUTEEND(&_ETHDKGCompletion.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TGPKJDISPUTEEND(&_ETHDKGCompletion.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TGPKJSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_GPKJ_SUBMISSION_END")
	return *ret0, err
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TGPKJSUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TGPKJSUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TKEYSHARESUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_KEY_SHARE_SUBMISSION_END")
	return *ret0, err
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TMPKSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_MPK_SUBMISSION_END")
	return *ret0, err
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TMPKSUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TMPKSUBMISSIONEND(&_ETHDKGCompletion.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TREGISTRATIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_REGISTRATION_END")
	return *ret0, err
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TREGISTRATIONEND(&_ETHDKGCompletion.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TREGISTRATIONEND(&_ETHDKGCompletion.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) TSHAREDISTRIBUTIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "T_SHARE_DISTRIBUTION_END")
	return *ret0, err
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGCompletion.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGCompletion.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGCompletion.CallOpts)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) Addresses(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "addresses", arg0)
	return *ret0, err
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGCompletion *ETHDKGCompletionSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGCompletion.Contract.Addresses(&_ETHDKGCompletion.CallOpts, arg0)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGCompletion.Contract.Addresses(&_ETHDKGCompletion.CallOpts, arg0)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) Commitments1stCoefficient(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "commitments_1st_coefficient", arg0, arg1)
	return *ret0, err
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.Commitments1stCoefficient(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.Commitments1stCoefficient(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) CompletionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "completion_check")
	return *ret0, err
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) CompletionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.CompletionCheck(&_ETHDKGCompletion.CallOpts)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) CompletionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.CompletionCheck(&_ETHDKGCompletion.CallOpts)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) GpkjSubmissions(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "gpkj_submissions", arg0, arg1)
	return *ret0, err
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.GpkjSubmissions(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.GpkjSubmissions(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) InitialMessage(opts *bind.CallOpts) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "initial_message")
	return *ret0, err
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGCompletion *ETHDKGCompletionSession) InitialMessage() ([]byte, error) {
	return _ETHDKGCompletion.Contract.InitialMessage(&_ETHDKGCompletion.CallOpts)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) InitialMessage() ([]byte, error) {
	return _ETHDKGCompletion.Contract.InitialMessage(&_ETHDKGCompletion.CallOpts)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) InitialSignatures(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "initial_signatures", arg0, arg1)
	return *ret0, err
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.InitialSignatures(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.InitialSignatures(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) IsMalicious(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "is_malicious", arg0)
	return *ret0, err
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGCompletion.Contract.IsMalicious(&_ETHDKGCompletion.CallOpts, arg0)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGCompletion.Contract.IsMalicious(&_ETHDKGCompletion.CallOpts, arg0)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) KeyShareSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "key_share_submission_check")
	return *ret0, err
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.KeyShareSubmissionCheck(&_ETHDKGCompletion.CallOpts)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.KeyShareSubmissionCheck(&_ETHDKGCompletion.CallOpts)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) KeyShares(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "key_shares", arg0, arg1)
	return *ret0, err
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.KeyShares(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.KeyShares(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) MasterPublicKey(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "master_public_key", arg0)
	return *ret0, err
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.MasterPublicKey(&_ETHDKGCompletion.CallOpts, arg0)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.MasterPublicKey(&_ETHDKGCompletion.CallOpts, arg0)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) MpkSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "mpk_submission_check")
	return *ret0, err
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.MpkSubmissionCheck(&_ETHDKGCompletion.CallOpts)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.MpkSubmissionCheck(&_ETHDKGCompletion.CallOpts)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) PublicKeys(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "public_keys", arg0, arg1)
	return *ret0, err
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.PublicKeys(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGCompletion.Contract.PublicKeys(&_ETHDKGCompletion.CallOpts, arg0, arg1)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) RegistrationCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "registration_check")
	return *ret0, err
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) RegistrationCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.RegistrationCheck(&_ETHDKGCompletion.CallOpts)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) RegistrationCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.RegistrationCheck(&_ETHDKGCompletion.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) ShareDistributionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "share_distribution_check")
	return *ret0, err
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.ShareDistributionCheck(&_ETHDKGCompletion.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGCompletion.Contract.ShareDistributionCheck(&_ETHDKGCompletion.CallOpts)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGCompletion *ETHDKGCompletionCaller) ShareDistributionHashes(opts *bind.CallOpts, arg0 common.Address) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ETHDKGCompletion.contract.Call(opts, out, "share_distribution_hashes", arg0)
	return *ret0, err
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGCompletion *ETHDKGCompletionSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGCompletion.Contract.ShareDistributionHashes(&_ETHDKGCompletion.CallOpts, arg0)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGCompletion *ETHDKGCompletionCallerSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGCompletion.Contract.ShareDistributionHashes(&_ETHDKGCompletion.CallOpts, arg0)
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionTransactor) SuccessfulCompletion(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGCompletion.contract.Transact(opts, "Successful_Completion")
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionSession) SuccessfulCompletion() (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.SuccessfulCompletion(&_ETHDKGCompletion.TransactOpts)
}

// SuccessfulCompletion is a paid mutator transaction binding the contract method 0x65c97c01.
//
// Solidity: function Successful_Completion() returns(bool)
func (_ETHDKGCompletion *ETHDKGCompletionTransactorSession) SuccessfulCompletion() (*types.Transaction, error) {
	return _ETHDKGCompletion.Contract.SuccessfulCompletion(&_ETHDKGCompletion.TransactOpts)
}

// ETHDKGCompletionKeyShareSubmissionIterator is returned from FilterKeyShareSubmission and is used to iterate over the raw logs and unpacked data for KeyShareSubmission events raised by the ETHDKGCompletion contract.
type ETHDKGCompletionKeyShareSubmissionIterator struct {
	Event *ETHDKGCompletionKeyShareSubmission // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGCompletionKeyShareSubmissionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGCompletionKeyShareSubmission)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGCompletionKeyShareSubmission)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGCompletionKeyShareSubmissionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGCompletionKeyShareSubmissionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGCompletionKeyShareSubmission represents a KeyShareSubmission event raised by the ETHDKGCompletion contract.
type ETHDKGCompletionKeyShareSubmission struct {
	Issuer                     common.Address
	KeyShareG1                 [2]*big.Int
	KeyShareG1CorrectnessProof [2]*big.Int
	KeyShareG2                 [4]*big.Int
	Raw                        types.Log // Blockchain specific contextual infos
}

// FilterKeyShareSubmission is a free log retrieval operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) FilterKeyShareSubmission(opts *bind.FilterOpts) (*ETHDKGCompletionKeyShareSubmissionIterator, error) {

	logs, sub, err := _ETHDKGCompletion.contract.FilterLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionKeyShareSubmissionIterator{contract: _ETHDKGCompletion.contract, event: "KeyShareSubmission", logs: logs, sub: sub}, nil
}

// WatchKeyShareSubmission is a free log subscription operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) WatchKeyShareSubmission(opts *bind.WatchOpts, sink chan<- *ETHDKGCompletionKeyShareSubmission) (event.Subscription, error) {

	logs, sub, err := _ETHDKGCompletion.contract.WatchLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGCompletionKeyShareSubmission)
				if err := _ETHDKGCompletion.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeyShareSubmission is a log parse operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) ParseKeyShareSubmission(log types.Log) (*ETHDKGCompletionKeyShareSubmission, error) {
	event := new(ETHDKGCompletionKeyShareSubmission)
	if err := _ETHDKGCompletion.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGCompletionRegistrationOpenIterator is returned from FilterRegistrationOpen and is used to iterate over the raw logs and unpacked data for RegistrationOpen events raised by the ETHDKGCompletion contract.
type ETHDKGCompletionRegistrationOpenIterator struct {
	Event *ETHDKGCompletionRegistrationOpen // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGCompletionRegistrationOpenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGCompletionRegistrationOpen)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGCompletionRegistrationOpen)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGCompletionRegistrationOpenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGCompletionRegistrationOpenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGCompletionRegistrationOpen represents a RegistrationOpen event raised by the ETHDKGCompletion contract.
type ETHDKGCompletionRegistrationOpen struct {
	DkgStarts              *big.Int
	RegistrationEnds       *big.Int
	ShareDistributionEnds  *big.Int
	DisputeEnds            *big.Int
	KeyShareSubmissionEnds *big.Int
	MpkSubmissionEnds      *big.Int
	GpkjSubmissionEnds     *big.Int
	GpkjDisputeEnds        *big.Int
	DkgComplete            *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterRegistrationOpen is a free log retrieval operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) FilterRegistrationOpen(opts *bind.FilterOpts) (*ETHDKGCompletionRegistrationOpenIterator, error) {

	logs, sub, err := _ETHDKGCompletion.contract.FilterLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionRegistrationOpenIterator{contract: _ETHDKGCompletion.contract, event: "RegistrationOpen", logs: logs, sub: sub}, nil
}

// WatchRegistrationOpen is a free log subscription operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) WatchRegistrationOpen(opts *bind.WatchOpts, sink chan<- *ETHDKGCompletionRegistrationOpen) (event.Subscription, error) {

	logs, sub, err := _ETHDKGCompletion.contract.WatchLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGCompletionRegistrationOpen)
				if err := _ETHDKGCompletion.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrationOpen is a log parse operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) ParseRegistrationOpen(log types.Log) (*ETHDKGCompletionRegistrationOpen, error) {
	event := new(ETHDKGCompletionRegistrationOpen)
	if err := _ETHDKGCompletion.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGCompletionShareDistributionIterator is returned from FilterShareDistribution and is used to iterate over the raw logs and unpacked data for ShareDistribution events raised by the ETHDKGCompletion contract.
type ETHDKGCompletionShareDistributionIterator struct {
	Event *ETHDKGCompletionShareDistribution // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGCompletionShareDistributionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGCompletionShareDistribution)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGCompletionShareDistribution)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGCompletionShareDistributionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGCompletionShareDistributionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGCompletionShareDistribution represents a ShareDistribution event raised by the ETHDKGCompletion contract.
type ETHDKGCompletionShareDistribution struct {
	Issuer          common.Address
	Index           *big.Int
	EncryptedShares []*big.Int
	Commitments     [][2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterShareDistribution is a free log retrieval operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) FilterShareDistribution(opts *bind.FilterOpts) (*ETHDKGCompletionShareDistributionIterator, error) {

	logs, sub, err := _ETHDKGCompletion.contract.FilterLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionShareDistributionIterator{contract: _ETHDKGCompletion.contract, event: "ShareDistribution", logs: logs, sub: sub}, nil
}

// WatchShareDistribution is a free log subscription operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) WatchShareDistribution(opts *bind.WatchOpts, sink chan<- *ETHDKGCompletionShareDistribution) (event.Subscription, error) {

	logs, sub, err := _ETHDKGCompletion.contract.WatchLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGCompletionShareDistribution)
				if err := _ETHDKGCompletion.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseShareDistribution is a log parse operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) ParseShareDistribution(log types.Log) (*ETHDKGCompletionShareDistribution, error) {
	event := new(ETHDKGCompletionShareDistribution)
	if err := _ETHDKGCompletion.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGCompletionValidatorMemberIterator is returned from FilterValidatorMember and is used to iterate over the raw logs and unpacked data for ValidatorMember events raised by the ETHDKGCompletion contract.
type ETHDKGCompletionValidatorMemberIterator struct {
	Event *ETHDKGCompletionValidatorMember // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGCompletionValidatorMemberIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGCompletionValidatorMember)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGCompletionValidatorMember)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGCompletionValidatorMemberIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGCompletionValidatorMemberIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGCompletionValidatorMember represents a ValidatorMember event raised by the ETHDKGCompletion contract.
type ETHDKGCompletionValidatorMember struct {
	Account common.Address
	Epoch   *big.Int
	Index   *big.Int
	Share0  *big.Int
	Share1  *big.Int
	Share2  *big.Int
	Share3  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterValidatorMember is a free log retrieval operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) FilterValidatorMember(opts *bind.FilterOpts) (*ETHDKGCompletionValidatorMemberIterator, error) {

	logs, sub, err := _ETHDKGCompletion.contract.FilterLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionValidatorMemberIterator{contract: _ETHDKGCompletion.contract, event: "ValidatorMember", logs: logs, sub: sub}, nil
}

// WatchValidatorMember is a free log subscription operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) WatchValidatorMember(opts *bind.WatchOpts, sink chan<- *ETHDKGCompletionValidatorMember) (event.Subscription, error) {

	logs, sub, err := _ETHDKGCompletion.contract.WatchLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGCompletionValidatorMember)
				if err := _ETHDKGCompletion.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorMember is a log parse operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) ParseValidatorMember(log types.Log) (*ETHDKGCompletionValidatorMember, error) {
	event := new(ETHDKGCompletionValidatorMember)
	if err := _ETHDKGCompletion.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGCompletionValidatorSetIterator is returned from FilterValidatorSet and is used to iterate over the raw logs and unpacked data for ValidatorSet events raised by the ETHDKGCompletion contract.
type ETHDKGCompletionValidatorSetIterator struct {
	Event *ETHDKGCompletionValidatorSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGCompletionValidatorSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGCompletionValidatorSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGCompletionValidatorSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGCompletionValidatorSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGCompletionValidatorSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGCompletionValidatorSet represents a ValidatorSet event raised by the ETHDKGCompletion contract.
type ETHDKGCompletionValidatorSet struct {
	ValidatorCount uint8
	Epoch          *big.Int
	EthHeight      uint32
	MadHeight      uint32
	GroupKey0      *big.Int
	GroupKey1      *big.Int
	GroupKey2      *big.Int
	GroupKey3      *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterValidatorSet is a free log retrieval operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) FilterValidatorSet(opts *bind.FilterOpts) (*ETHDKGCompletionValidatorSetIterator, error) {

	logs, sub, err := _ETHDKGCompletion.contract.FilterLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return &ETHDKGCompletionValidatorSetIterator{contract: _ETHDKGCompletion.contract, event: "ValidatorSet", logs: logs, sub: sub}, nil
}

// WatchValidatorSet is a free log subscription operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) WatchValidatorSet(opts *bind.WatchOpts, sink chan<- *ETHDKGCompletionValidatorSet) (event.Subscription, error) {

	logs, sub, err := _ETHDKGCompletion.contract.WatchLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGCompletionValidatorSet)
				if err := _ETHDKGCompletion.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorSet is a log parse operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGCompletion *ETHDKGCompletionFilterer) ParseValidatorSet(log types.Log) (*ETHDKGCompletionValidatorSet, error) {
	event := new(ETHDKGCompletionValidatorSet)
	if err := _ETHDKGCompletion.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGGroupAccusationABI is the input ABI used to generate the binding from.
const ETHDKGGroupAccusationABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"KeyShareSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgStarts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareDistributionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyShareSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mpkSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjDisputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgComplete\",\"type\":\"uint256\"}],\"name\":\"RegistrationOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"ShareDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share3\",\"type\":\"uint256\"}],\"name\":\"ValidatorMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"validatorCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ethHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"madHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey3\",\"type\":\"uint256\"}],\"name\":\"ValidatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELTA_CONFIRM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"invArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"honestIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dishonestIndices\",\"type\":\"uint256[]\"}],\"name\":\"Group_Accusation_GPKj\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DKG_COMPLETE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_KEY_SHARE_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_MPK_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REGISTRATION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SHARE_DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments_1st_coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completion_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gpkj_submissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_message\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_signatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_malicious\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"key_share_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"key_shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"master_public_key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpk_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"public_keys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registration_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share_distribution_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_distribution_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ETHDKGGroupAccusationBin is the compiled bytecode used for deploying new contracts.
var ETHDKGGroupAccusationBin = "0x608060405260405160200180807f43727970746f67726170687920697320677265617400000000000000000000008152506015019050604051602081830303815290604052600d90805190602001906200005b92919062000075565b5060286017553480156200006e57600080fd5b5062000124565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000b857805160ff1916838001178555620000e9565b82800160010185558215620000e9579182015b82811115620000e8578251825591602001919060010190620000cb565b5b509050620000f89190620000fc565b5090565b6200012191905b808211156200011d57600081600090555060010162000103565b5090565b90565b611bca80620001346000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063a6872833116100de578063d3cf618611610097578063e651137811610071578063e651137814610773578063eadfcadc146107b5578063edf26d9b14610811578063fef001a91461087f57610173565b8063d3cf618614610719578063dc614e2814610737578063e2291ec31461075557610173565b8063a6872833146103bc578063a88c9e1c1461059c578063aa7bd338146105fe578063ab63c72214610681578063b7b09ed61461069f578063c21bee83146106c157610173565b80637543b80f116101305780637543b80f146102bc57806375f7ed6a146102da57806377fbebd1146102fc578063836889dc1461031a57806392896b2d1461033c5780639c2aa8381461039e57610173565b8063050a54f01461017857806307f02c541461019a5780630de1553f146101b85780632cf4050b146101d65780632f11b985146102385780637328f8261461025a575b600080fd5b6101806108e1565b604051808215151515815260200191505060405180910390f35b6101a26108f4565b6040518082815260200191505060405180910390f35b6101c06108fa565b6040518082815260200191505060405180910390f35b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610900565b6040518082815260200191505060405180910390f35b610240610925565b604051808215151515815260200191505060405180910390f35b6102a66004803603604081101561027057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610938565b6040518082815260200191505060405180910390f35b6102c461095d565b6040518082815260200191505060405180910390f35b6102e2610962565b604051808215151515815260200191505060405180910390f35b610304610975565b6040518082815260200191505060405180910390f35b61032261097b565b604051808215151515815260200191505060405180910390f35b6103886004803603604081101561035257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061098e565b6040518082815260200191505060405180910390f35b6103a66109b3565b6040518082815260200191505060405180910390f35b61059a600480360360608110156103d257600080fd5b81019080803590602001906401000000008111156103ef57600080fd5b82018360208201111561040157600080fd5b8035906020019184602083028401116401000000008311171561042357600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561048357600080fd5b82018360208201111561049557600080fd5b803590602001918460208302840111640100000000831117156104b757600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192908035906020019064010000000081111561051757600080fd5b82018360208201111561052957600080fd5b8035906020019184602083028401116401000000008311171561054b57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505091929192905050506109b9565b005b6105e8600480360360408110156105b257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506118ac565b6040518082815260200191505060405180910390f35b6106066118d1565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561064657808201518184015260208101905061062b565b50505050905090810190601f1680156106735780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61068961196f565b6040518082815260200191505060405180910390f35b6106a7611975565b604051808215151515815260200191505060405180910390f35b610703600480360360208110156106d757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611988565b6040518082815260200191505060405180910390f35b6107216119a0565b6040518082815260200191505060405180910390f35b61073f6119a6565b6040518082815260200191505060405180910390f35b61075d6119ac565b6040518082815260200191505060405180910390f35b61079f6004803603602081101561078957600080fd5b81019080803590602001909291905050506119b2565b6040518082815260200191505060405180910390f35b6107f7600480360360208110156107cb57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506119ca565b604051808215151515815260200191505060405180910390f35b61083d6004803603602081101561082757600080fd5b81019080803590602001909291905050506119ea565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6108cb6004803603604081101561089557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611a26565b6040518082815260200191505060405180910390f35b600e60039054906101000a900460ff1681565b60135481565b600f5481565b6003602052816000526040600020816002811061091957fe5b01600091509150505481565b600e60019054906101000a900460ff1681565b6006602052816000526040600020816002811061095157fe5b01600091509150505481565b600681565b600e60049054906101000a900460ff1681565b60165481565b600e60029054906101000a900460ff1681565b600160205281600052604060002081600281106109a757fe5b01600091509150505481565b60145481565b436014541080156109cc57506015544311155b610a21576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526041815260200180611a8a6041913960600191505060405180910390fd5b6000600360008054905081610a3257fe5b0490506000816002029050816003026000805490500360021415610a57576001810190505b6001810184511015610ab4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602b815260200180611b6a602b913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166380f4a92285856000805490506040518463ffffffff1660e01b8152600401808060200180602001848152602001838103835286818151815260200191508051906020019060200280838360005b83811015610b56578082015181840152602081019050610b3b565b50505050905001838103825285818151815260200191508051906020019060200280838360005b83811015610b98578082015181840152602081019050610b7d565b505050509050019550505050505060206040518083038186803b158015610bbe57600080fd5b505afa158015610bd2573d6000803e3d6000fd5b505050506040513d6020811015610be857600080fd5b8101908080519060200190929190505050610c4e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526040815260200180611af56040913960400191505060405180910390fd5b60606001820167ffffffffffffffff81118015610c6a57600080fd5b50604051908082528060200260200182016040528015610ca457816020015b610c91611a4b565b815260200190600190039081610c895790505b50905060606001830167ffffffffffffffff81118015610cc357600080fd5b50604051908082528060200260200182016040528015610cf25781602001602082028036833780820191505090505b509050600080601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e480a92e8a6000805490506040518363ffffffff1660e01b81526004018080602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610d95578082015181840152602081019050610d7a565b50505050905001935050505060206040518083038186803b158015610db957600080fd5b505afa158015610dcd573d6000803e3d6000fd5b505050506040513d6020811015610de357600080fd5b8101908080519060200190929190505050610e49576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180611acb602a913960400191505060405180910390fd5b600095505b60018501861015610f6457878681518110610e6557fe5b6020026020010151915060006001830381548110610e7f57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600660008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015610f22576020028201915b815481526020019060010190808311610f0e575b5050505050848781518110610f3357fe5b602002602001018190525081838781518110610f4b57fe5b6020026020010181815250508580600101965050610e4e565b610f6c611a4b565b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f022e0618686898e6040518563ffffffff1660e01b8152600401808060200180602001858152602001806020018481038452888181518152602001915080516000925b818410156110325782846020026020010151600260200280838360005b83811015611021578082015181840152602081019050611006565b505050509050019260010192610fe9565b92505050848103835287818151815260200191508051906020019060200280838360005b83811015611071578082015181840152602081019050611056565b50505050905001848103825285818151815260200191508051906020019060200280838360005b838110156110b3578082015181840152602081019050611098565b50505050905001975050505050505050604080518083038186803b1580156110da57600080fd5b505afa1580156110ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250604081101561111357600080fd5b81019080919050509050601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306367587600d8360096040518463ffffffff1660e01b8152600401808060200184600260200280838360005b8381101561119e578082015181840152602081019050611183565b5050505090500183600480156111c9576020028201915b8154815260200190600101908083116111b5575b505082810382528581815460018160011615610100020316600290048152602001915080546001816001161561010002031660029004801561124c5780601f106112215761010080835404028352916020019161124c565b820191906000526020600020905b81548152906001019060200180831161122f57829003601f168201915b505094505050505060206040518083038186803b15801561126c57600080fd5b505afa158015611280573d6000803e3d6000fd5b505050506040513d602081101561129657600080fd5b81019080805190602001909291905050506112fc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526035815260200180611b356035913960400191505060405180910390fd5b600096505b87518710156118a05787878151811061131657fe5b602002602001015192506000600184038154811061133057fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691508284878151811061136a57fe5b602002602001018181525050600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002806020026040519081016040528092919082600280156113ec576020028201915b8154815260200190600101908083116113d8575b50505050508587815181106113fd57fe5b6020026020010181905250601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f022e0618686898e6040518563ffffffff1660e01b8152600401808060200180602001858152602001806020018481038452888181518152602001915080516000925b818410156114ce5782846020026020010151600260200280838360005b838110156114bd5780820151818401526020810190506114a2565b505050509050019260010192611485565b92505050848103835287818151815260200191508051906020019060200280838360005b8381101561150d5780820151818401526020810190506114f2565b50505050905001848103825285818151815260200191508051906020019060200280838360005b8381101561154f578082015181840152602081019050611534565b50505050905001975050505050505050604080518083038186803b15801561157657600080fd5b505afa15801561158a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060408110156115af57600080fd5b81019080919050509050601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306367587600d8360096040518463ffffffff1660e01b8152600401808060200184600260200280838360005b8381101561163a57808201518184015260208101905061161f565b505050509050018360048015611665576020028201915b815481526020019060010190808311611651575b50508281038252858181546001816001161561010002031660029004815260200191508054600181600116156101000203166002900480156116e85780601f106116bd576101008083540402835291602001916116e8565b820191906000526020600020905b8154815290600101906020018083116116cb57829003601f168201915b505094505050505060206040518083038186803b15801561170857600080fd5b505afa15801561171c573d6000803e3d6000fd5b505050506040513d602081101561173257600080fd5b81019080805190602001909291905050506117ef57600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006117929190611a6d565b6001600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550611893565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600061183a9190611a6d565b6001600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505b8680600101975050611301565b50505050505050505050565b600460205281600052604060002081600281106118c557fe5b01600091509150505481565b600d8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156119675780601f1061193c57610100808354040283529160200191611967565b820191906000526020600020905b81548152906001019060200180831161194a57829003601f168201915b505050505081565b60155481565b600e60009054906101000a900460ff1681565b60026020528060005260406000206000915090505481565b60115481565b60105481565b60125481565b600981600481106119bf57fe5b016000915090505481565b60086020528060005260406000206000915054906101000a900460ff1681565b600081815481106119f757fe5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60056020528160005260406000208160048110611a3f57fe5b01600091509150505481565b6040518060400160405280600290602082028036833780820191505090505090565b506000815560010160008155600101600081556001016000905556fe67706b6a2061636375736174696f6e206661696c65642028636f6e7472616374206973206e6f7420696e2067706b6a2061636375736174696f6e20706861736529696e76417272617920646f6573206e6f7420696e636c75646520636f727265637420696e766572736573686f6e657374496e646963657320616e6420646973686f6e657374496e646963657320646f206e6f7420636f6e7461696e20756e6971756520696e6469636573686f6e657374496e6469636573206661696c656420746f2070726f647563652076616c69642067726f7570207369676e6174757265496e636f7272656374206e756d626572206f6620686f6e6573742076616c696461746f72733b2065786974a2646970667358221220e215c862ba565d8486315f1433328fd7cabc924507e6fcde5fc6aadfbb26d1cc64736f6c63430006070033"

// DeployETHDKGGroupAccusation deploys a new Ethereum contract, binding an instance of ETHDKGGroupAccusation to it.
func DeployETHDKGGroupAccusation(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ETHDKGGroupAccusation, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGGroupAccusationABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ETHDKGGroupAccusationBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ETHDKGGroupAccusation{ETHDKGGroupAccusationCaller: ETHDKGGroupAccusationCaller{contract: contract}, ETHDKGGroupAccusationTransactor: ETHDKGGroupAccusationTransactor{contract: contract}, ETHDKGGroupAccusationFilterer: ETHDKGGroupAccusationFilterer{contract: contract}}, nil
}

// ETHDKGGroupAccusation is an auto generated Go binding around an Ethereum contract.
type ETHDKGGroupAccusation struct {
	ETHDKGGroupAccusationCaller     // Read-only binding to the contract
	ETHDKGGroupAccusationTransactor // Write-only binding to the contract
	ETHDKGGroupAccusationFilterer   // Log filterer for contract events
}

// ETHDKGGroupAccusationCaller is an auto generated read-only Go binding around an Ethereum contract.
type ETHDKGGroupAccusationCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGGroupAccusationTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ETHDKGGroupAccusationTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGGroupAccusationFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ETHDKGGroupAccusationFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGGroupAccusationSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ETHDKGGroupAccusationSession struct {
	Contract     *ETHDKGGroupAccusation // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ETHDKGGroupAccusationCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ETHDKGGroupAccusationCallerSession struct {
	Contract *ETHDKGGroupAccusationCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// ETHDKGGroupAccusationTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ETHDKGGroupAccusationTransactorSession struct {
	Contract     *ETHDKGGroupAccusationTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// ETHDKGGroupAccusationRaw is an auto generated low-level Go binding around an Ethereum contract.
type ETHDKGGroupAccusationRaw struct {
	Contract *ETHDKGGroupAccusation // Generic contract binding to access the raw methods on
}

// ETHDKGGroupAccusationCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ETHDKGGroupAccusationCallerRaw struct {
	Contract *ETHDKGGroupAccusationCaller // Generic read-only contract binding to access the raw methods on
}

// ETHDKGGroupAccusationTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ETHDKGGroupAccusationTransactorRaw struct {
	Contract *ETHDKGGroupAccusationTransactor // Generic write-only contract binding to access the raw methods on
}

// NewETHDKGGroupAccusation creates a new instance of ETHDKGGroupAccusation, bound to a specific deployed contract.
func NewETHDKGGroupAccusation(address common.Address, backend bind.ContractBackend) (*ETHDKGGroupAccusation, error) {
	contract, err := bindETHDKGGroupAccusation(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusation{ETHDKGGroupAccusationCaller: ETHDKGGroupAccusationCaller{contract: contract}, ETHDKGGroupAccusationTransactor: ETHDKGGroupAccusationTransactor{contract: contract}, ETHDKGGroupAccusationFilterer: ETHDKGGroupAccusationFilterer{contract: contract}}, nil
}

// NewETHDKGGroupAccusationCaller creates a new read-only instance of ETHDKGGroupAccusation, bound to a specific deployed contract.
func NewETHDKGGroupAccusationCaller(address common.Address, caller bind.ContractCaller) (*ETHDKGGroupAccusationCaller, error) {
	contract, err := bindETHDKGGroupAccusation(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationCaller{contract: contract}, nil
}

// NewETHDKGGroupAccusationTransactor creates a new write-only instance of ETHDKGGroupAccusation, bound to a specific deployed contract.
func NewETHDKGGroupAccusationTransactor(address common.Address, transactor bind.ContractTransactor) (*ETHDKGGroupAccusationTransactor, error) {
	contract, err := bindETHDKGGroupAccusation(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationTransactor{contract: contract}, nil
}

// NewETHDKGGroupAccusationFilterer creates a new log filterer instance of ETHDKGGroupAccusation, bound to a specific deployed contract.
func NewETHDKGGroupAccusationFilterer(address common.Address, filterer bind.ContractFilterer) (*ETHDKGGroupAccusationFilterer, error) {
	contract, err := bindETHDKGGroupAccusation(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationFilterer{contract: contract}, nil
}

// bindETHDKGGroupAccusation binds a generic wrapper to an already deployed contract.
func bindETHDKGGroupAccusation(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGGroupAccusationABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGGroupAccusation.Contract.ETHDKGGroupAccusationCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.ETHDKGGroupAccusationTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.ETHDKGGroupAccusationTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGGroupAccusation.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.contract.Transact(opts, method, params...)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) DELTACONFIRM(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "DELTA_CONFIRM")
	return *ret0, err
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.DELTACONFIRM(&_ETHDKGGroupAccusation.CallOpts)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.DELTACONFIRM(&_ETHDKGGroupAccusation.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_DISPUTE_END")
	return *ret0, err
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TDISPUTEEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TDISPUTEEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TDKGCOMPLETE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_DKG_COMPLETE")
	return *ret0, err
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TDKGCOMPLETE(&_ETHDKGGroupAccusation.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TDKGCOMPLETE(&_ETHDKGGroupAccusation.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TGPKJDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_GPKJ_DISPUTE_END")
	return *ret0, err
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TGPKJDISPUTEEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TGPKJDISPUTEEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TGPKJSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_GPKJ_SUBMISSION_END")
	return *ret0, err
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TGPKJSUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TGPKJSUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TKEYSHARESUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_KEY_SHARE_SUBMISSION_END")
	return *ret0, err
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TMPKSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_MPK_SUBMISSION_END")
	return *ret0, err
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TMPKSUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TMPKSUBMISSIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TREGISTRATIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_REGISTRATION_END")
	return *ret0, err
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TREGISTRATIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TREGISTRATIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) TSHAREDISTRIBUTIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "T_SHARE_DISTRIBUTION_END")
	return *ret0, err
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGGroupAccusation.CallOpts)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) Addresses(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "addresses", arg0)
	return *ret0, err
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGGroupAccusation.Contract.Addresses(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGGroupAccusation.Contract.Addresses(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) Commitments1stCoefficient(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "commitments_1st_coefficient", arg0, arg1)
	return *ret0, err
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.Commitments1stCoefficient(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.Commitments1stCoefficient(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) CompletionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "completion_check")
	return *ret0, err
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) CompletionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.CompletionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) CompletionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.CompletionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) GpkjSubmissions(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "gpkj_submissions", arg0, arg1)
	return *ret0, err
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.GpkjSubmissions(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.GpkjSubmissions(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) InitialMessage(opts *bind.CallOpts) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "initial_message")
	return *ret0, err
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) InitialMessage() ([]byte, error) {
	return _ETHDKGGroupAccusation.Contract.InitialMessage(&_ETHDKGGroupAccusation.CallOpts)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) InitialMessage() ([]byte, error) {
	return _ETHDKGGroupAccusation.Contract.InitialMessage(&_ETHDKGGroupAccusation.CallOpts)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) InitialSignatures(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "initial_signatures", arg0, arg1)
	return *ret0, err
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.InitialSignatures(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.InitialSignatures(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) IsMalicious(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "is_malicious", arg0)
	return *ret0, err
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGGroupAccusation.Contract.IsMalicious(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGGroupAccusation.Contract.IsMalicious(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) KeyShareSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "key_share_submission_check")
	return *ret0, err
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.KeyShareSubmissionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.KeyShareSubmissionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) KeyShares(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "key_shares", arg0, arg1)
	return *ret0, err
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.KeyShares(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.KeyShares(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) MasterPublicKey(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "master_public_key", arg0)
	return *ret0, err
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.MasterPublicKey(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.MasterPublicKey(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) MpkSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "mpk_submission_check")
	return *ret0, err
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.MpkSubmissionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.MpkSubmissionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) PublicKeys(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "public_keys", arg0, arg1)
	return *ret0, err
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.PublicKeys(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGGroupAccusation.Contract.PublicKeys(&_ETHDKGGroupAccusation.CallOpts, arg0, arg1)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) RegistrationCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "registration_check")
	return *ret0, err
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) RegistrationCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.RegistrationCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) RegistrationCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.RegistrationCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) ShareDistributionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "share_distribution_check")
	return *ret0, err
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.ShareDistributionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGGroupAccusation.Contract.ShareDistributionCheck(&_ETHDKGGroupAccusation.CallOpts)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCaller) ShareDistributionHashes(opts *bind.CallOpts, arg0 common.Address) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ETHDKGGroupAccusation.contract.Call(opts, out, "share_distribution_hashes", arg0)
	return *ret0, err
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGGroupAccusation.Contract.ShareDistributionHashes(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationCallerSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGGroupAccusation.Contract.ShareDistributionHashes(&_ETHDKGGroupAccusation.CallOpts, arg0)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationTransactor) GroupAccusationGPKj(opts *bind.TransactOpts, invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.contract.Transact(opts, "Group_Accusation_GPKj", invArray, honestIndices, dishonestIndices)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationSession) GroupAccusationGPKj(invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.GroupAccusationGPKj(&_ETHDKGGroupAccusation.TransactOpts, invArray, honestIndices, dishonestIndices)
}

// GroupAccusationGPKj is a paid mutator transaction binding the contract method 0xa6872833.
//
// Solidity: function Group_Accusation_GPKj(uint256[] invArray, uint256[] honestIndices, uint256[] dishonestIndices) returns()
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationTransactorSession) GroupAccusationGPKj(invArray []*big.Int, honestIndices []*big.Int, dishonestIndices []*big.Int) (*types.Transaction, error) {
	return _ETHDKGGroupAccusation.Contract.GroupAccusationGPKj(&_ETHDKGGroupAccusation.TransactOpts, invArray, honestIndices, dishonestIndices)
}

// ETHDKGGroupAccusationKeyShareSubmissionIterator is returned from FilterKeyShareSubmission and is used to iterate over the raw logs and unpacked data for KeyShareSubmission events raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationKeyShareSubmissionIterator struct {
	Event *ETHDKGGroupAccusationKeyShareSubmission // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGGroupAccusationKeyShareSubmissionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGGroupAccusationKeyShareSubmission)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGGroupAccusationKeyShareSubmission)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGGroupAccusationKeyShareSubmissionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGGroupAccusationKeyShareSubmissionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGGroupAccusationKeyShareSubmission represents a KeyShareSubmission event raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationKeyShareSubmission struct {
	Issuer                     common.Address
	KeyShareG1                 [2]*big.Int
	KeyShareG1CorrectnessProof [2]*big.Int
	KeyShareG2                 [4]*big.Int
	Raw                        types.Log // Blockchain specific contextual infos
}

// FilterKeyShareSubmission is a free log retrieval operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) FilterKeyShareSubmission(opts *bind.FilterOpts) (*ETHDKGGroupAccusationKeyShareSubmissionIterator, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.FilterLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationKeyShareSubmissionIterator{contract: _ETHDKGGroupAccusation.contract, event: "KeyShareSubmission", logs: logs, sub: sub}, nil
}

// WatchKeyShareSubmission is a free log subscription operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) WatchKeyShareSubmission(opts *bind.WatchOpts, sink chan<- *ETHDKGGroupAccusationKeyShareSubmission) (event.Subscription, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.WatchLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGGroupAccusationKeyShareSubmission)
				if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeyShareSubmission is a log parse operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) ParseKeyShareSubmission(log types.Log) (*ETHDKGGroupAccusationKeyShareSubmission, error) {
	event := new(ETHDKGGroupAccusationKeyShareSubmission)
	if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGGroupAccusationRegistrationOpenIterator is returned from FilterRegistrationOpen and is used to iterate over the raw logs and unpacked data for RegistrationOpen events raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationRegistrationOpenIterator struct {
	Event *ETHDKGGroupAccusationRegistrationOpen // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGGroupAccusationRegistrationOpenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGGroupAccusationRegistrationOpen)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGGroupAccusationRegistrationOpen)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGGroupAccusationRegistrationOpenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGGroupAccusationRegistrationOpenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGGroupAccusationRegistrationOpen represents a RegistrationOpen event raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationRegistrationOpen struct {
	DkgStarts              *big.Int
	RegistrationEnds       *big.Int
	ShareDistributionEnds  *big.Int
	DisputeEnds            *big.Int
	KeyShareSubmissionEnds *big.Int
	MpkSubmissionEnds      *big.Int
	GpkjSubmissionEnds     *big.Int
	GpkjDisputeEnds        *big.Int
	DkgComplete            *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterRegistrationOpen is a free log retrieval operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) FilterRegistrationOpen(opts *bind.FilterOpts) (*ETHDKGGroupAccusationRegistrationOpenIterator, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.FilterLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationRegistrationOpenIterator{contract: _ETHDKGGroupAccusation.contract, event: "RegistrationOpen", logs: logs, sub: sub}, nil
}

// WatchRegistrationOpen is a free log subscription operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) WatchRegistrationOpen(opts *bind.WatchOpts, sink chan<- *ETHDKGGroupAccusationRegistrationOpen) (event.Subscription, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.WatchLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGGroupAccusationRegistrationOpen)
				if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrationOpen is a log parse operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) ParseRegistrationOpen(log types.Log) (*ETHDKGGroupAccusationRegistrationOpen, error) {
	event := new(ETHDKGGroupAccusationRegistrationOpen)
	if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGGroupAccusationShareDistributionIterator is returned from FilterShareDistribution and is used to iterate over the raw logs and unpacked data for ShareDistribution events raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationShareDistributionIterator struct {
	Event *ETHDKGGroupAccusationShareDistribution // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGGroupAccusationShareDistributionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGGroupAccusationShareDistribution)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGGroupAccusationShareDistribution)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGGroupAccusationShareDistributionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGGroupAccusationShareDistributionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGGroupAccusationShareDistribution represents a ShareDistribution event raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationShareDistribution struct {
	Issuer          common.Address
	Index           *big.Int
	EncryptedShares []*big.Int
	Commitments     [][2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterShareDistribution is a free log retrieval operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) FilterShareDistribution(opts *bind.FilterOpts) (*ETHDKGGroupAccusationShareDistributionIterator, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.FilterLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationShareDistributionIterator{contract: _ETHDKGGroupAccusation.contract, event: "ShareDistribution", logs: logs, sub: sub}, nil
}

// WatchShareDistribution is a free log subscription operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) WatchShareDistribution(opts *bind.WatchOpts, sink chan<- *ETHDKGGroupAccusationShareDistribution) (event.Subscription, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.WatchLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGGroupAccusationShareDistribution)
				if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseShareDistribution is a log parse operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) ParseShareDistribution(log types.Log) (*ETHDKGGroupAccusationShareDistribution, error) {
	event := new(ETHDKGGroupAccusationShareDistribution)
	if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGGroupAccusationValidatorMemberIterator is returned from FilterValidatorMember and is used to iterate over the raw logs and unpacked data for ValidatorMember events raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationValidatorMemberIterator struct {
	Event *ETHDKGGroupAccusationValidatorMember // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGGroupAccusationValidatorMemberIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGGroupAccusationValidatorMember)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGGroupAccusationValidatorMember)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGGroupAccusationValidatorMemberIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGGroupAccusationValidatorMemberIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGGroupAccusationValidatorMember represents a ValidatorMember event raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationValidatorMember struct {
	Account common.Address
	Epoch   *big.Int
	Index   *big.Int
	Share0  *big.Int
	Share1  *big.Int
	Share2  *big.Int
	Share3  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterValidatorMember is a free log retrieval operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) FilterValidatorMember(opts *bind.FilterOpts) (*ETHDKGGroupAccusationValidatorMemberIterator, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.FilterLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationValidatorMemberIterator{contract: _ETHDKGGroupAccusation.contract, event: "ValidatorMember", logs: logs, sub: sub}, nil
}

// WatchValidatorMember is a free log subscription operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) WatchValidatorMember(opts *bind.WatchOpts, sink chan<- *ETHDKGGroupAccusationValidatorMember) (event.Subscription, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.WatchLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGGroupAccusationValidatorMember)
				if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorMember is a log parse operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) ParseValidatorMember(log types.Log) (*ETHDKGGroupAccusationValidatorMember, error) {
	event := new(ETHDKGGroupAccusationValidatorMember)
	if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGGroupAccusationValidatorSetIterator is returned from FilterValidatorSet and is used to iterate over the raw logs and unpacked data for ValidatorSet events raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationValidatorSetIterator struct {
	Event *ETHDKGGroupAccusationValidatorSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGGroupAccusationValidatorSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGGroupAccusationValidatorSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGGroupAccusationValidatorSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGGroupAccusationValidatorSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGGroupAccusationValidatorSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGGroupAccusationValidatorSet represents a ValidatorSet event raised by the ETHDKGGroupAccusation contract.
type ETHDKGGroupAccusationValidatorSet struct {
	ValidatorCount uint8
	Epoch          *big.Int
	EthHeight      uint32
	MadHeight      uint32
	GroupKey0      *big.Int
	GroupKey1      *big.Int
	GroupKey2      *big.Int
	GroupKey3      *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterValidatorSet is a free log retrieval operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) FilterValidatorSet(opts *bind.FilterOpts) (*ETHDKGGroupAccusationValidatorSetIterator, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.FilterLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return &ETHDKGGroupAccusationValidatorSetIterator{contract: _ETHDKGGroupAccusation.contract, event: "ValidatorSet", logs: logs, sub: sub}, nil
}

// WatchValidatorSet is a free log subscription operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) WatchValidatorSet(opts *bind.WatchOpts, sink chan<- *ETHDKGGroupAccusationValidatorSet) (event.Subscription, error) {

	logs, sub, err := _ETHDKGGroupAccusation.contract.WatchLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGGroupAccusationValidatorSet)
				if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorSet is a log parse operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGGroupAccusation *ETHDKGGroupAccusationFilterer) ParseValidatorSet(log types.Log) (*ETHDKGGroupAccusationValidatorSet, error) {
	event := new(ETHDKGGroupAccusationValidatorSet)
	if err := _ETHDKGGroupAccusation.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGStorageABI is the input ABI used to generate the binding from.
const ETHDKGStorageABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"KeyShareSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgStarts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareDistributionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyShareSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mpkSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjDisputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgComplete\",\"type\":\"uint256\"}],\"name\":\"RegistrationOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"ShareDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share3\",\"type\":\"uint256\"}],\"name\":\"ValidatorMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"validatorCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ethHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"madHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey3\",\"type\":\"uint256\"}],\"name\":\"ValidatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELTA_CONFIRM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DKG_COMPLETE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_KEY_SHARE_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_MPK_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REGISTRATION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SHARE_DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments_1st_coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completion_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gpkj_submissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_message\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_signatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_malicious\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"key_share_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"key_shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"master_public_key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpk_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"public_keys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registration_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share_distribution_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_distribution_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ETHDKGStorageBin is the compiled bytecode used for deploying new contracts.
var ETHDKGStorageBin = "0x608060405260405160200180807f43727970746f67726170687920697320677265617400000000000000000000008152506015019050604051602081830303815290604052600d9080519060200190610059929190610071565b50602860175534801561006b57600080fd5b50610116565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100b257805160ff19168380011785556100e0565b828001600101855582156100e0579182015b828111156100df5782518255916020019190600101906100c4565b5b5090506100ed91906100f1565b5090565b61011391905b8082111561010f5760008160009055506001016100f7565b5090565b90565b610993806101256000396000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c8063a88c9e1c116100c3578063dc614e281161007c578063dc614e281461053c578063e2291ec31461055a578063e651137814610578578063eadfcadc146105ba578063edf26d9b14610616578063fef001a91461068457610158565b8063a88c9e1c146103a1578063aa7bd33814610403578063ab63c72214610486578063b7b09ed6146104a4578063c21bee83146104c6578063d3cf61861461051e57610158565b80637543b80f116101155780637543b80f146102a157806375f7ed6a146102bf57806377fbebd1146102e1578063836889dc146102ff57806392896b2d146103215780639c2aa8381461038357610158565b8063050a54f01461015d57806307f02c541461017f5780630de1553f1461019d5780632cf4050b146101bb5780632f11b9851461021d5780637328f8261461023f575b600080fd5b6101656106e6565b604051808215151515815260200191505060405180910390f35b6101876106f9565b6040518082815260200191505060405180910390f35b6101a56106ff565b6040518082815260200191505060405180910390f35b610207600480360360408110156101d157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610705565b6040518082815260200191505060405180910390f35b61022561072a565b604051808215151515815260200191505060405180910390f35b61028b6004803603604081101561025557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061073d565b6040518082815260200191505060405180910390f35b6102a9610762565b6040518082815260200191505060405180910390f35b6102c7610767565b604051808215151515815260200191505060405180910390f35b6102e961077a565b6040518082815260200191505060405180910390f35b610307610780565b604051808215151515815260200191505060405180910390f35b61036d6004803603604081101561033757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610793565b6040518082815260200191505060405180910390f35b61038b6107b8565b6040518082815260200191505060405180910390f35b6103ed600480360360408110156103b757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506107be565b6040518082815260200191505060405180910390f35b61040b6107e3565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561044b578082015181840152602081019050610430565b50505050905090810190601f1680156104785780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61048e610881565b6040518082815260200191505060405180910390f35b6104ac610887565b604051808215151515815260200191505060405180910390f35b610508600480360360208110156104dc57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061089a565b6040518082815260200191505060405180910390f35b6105266108b2565b6040518082815260200191505060405180910390f35b6105446108b8565b6040518082815260200191505060405180910390f35b6105626108be565b6040518082815260200191505060405180910390f35b6105a46004803603602081101561058e57600080fd5b81019080803590602001909291905050506108c4565b6040518082815260200191505060405180910390f35b6105fc600480360360208110156105d057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506108dc565b604051808215151515815260200191505060405180910390f35b6106426004803603602081101561062c57600080fd5b81019080803590602001909291905050506108fc565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6106d06004803603604081101561069a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610938565b6040518082815260200191505060405180910390f35b600e60039054906101000a900460ff1681565b60135481565b600f5481565b6003602052816000526040600020816002811061071e57fe5b01600091509150505481565b600e60019054906101000a900460ff1681565b6006602052816000526040600020816002811061075657fe5b01600091509150505481565b600681565b600e60049054906101000a900460ff1681565b60165481565b600e60029054906101000a900460ff1681565b600160205281600052604060002081600281106107ac57fe5b01600091509150505481565b60145481565b600460205281600052604060002081600281106107d757fe5b01600091509150505481565b600d8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156108795780601f1061084e57610100808354040283529160200191610879565b820191906000526020600020905b81548152906001019060200180831161085c57829003601f168201915b505050505081565b60155481565b600e60009054906101000a900460ff1681565b60026020528060005260406000206000915090505481565b60115481565b60105481565b60125481565b600981600481106108d157fe5b016000915090505481565b60086020528060005260406000206000915054906101000a900460ff1681565b6000818154811061090957fe5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6005602052816000526040600020816004811061095157fe5b0160009150915050548156fea2646970667358221220cb513711035670bcd44e3410ce3dcac25c67c983d07210746bb3f4efb6a1bb3064736f6c63430006070033"

// DeployETHDKGStorage deploys a new Ethereum contract, binding an instance of ETHDKGStorage to it.
func DeployETHDKGStorage(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ETHDKGStorage, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGStorageABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ETHDKGStorageBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ETHDKGStorage{ETHDKGStorageCaller: ETHDKGStorageCaller{contract: contract}, ETHDKGStorageTransactor: ETHDKGStorageTransactor{contract: contract}, ETHDKGStorageFilterer: ETHDKGStorageFilterer{contract: contract}}, nil
}

// ETHDKGStorage is an auto generated Go binding around an Ethereum contract.
type ETHDKGStorage struct {
	ETHDKGStorageCaller     // Read-only binding to the contract
	ETHDKGStorageTransactor // Write-only binding to the contract
	ETHDKGStorageFilterer   // Log filterer for contract events
}

// ETHDKGStorageCaller is an auto generated read-only Go binding around an Ethereum contract.
type ETHDKGStorageCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGStorageTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ETHDKGStorageTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGStorageFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ETHDKGStorageFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGStorageSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ETHDKGStorageSession struct {
	Contract     *ETHDKGStorage    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ETHDKGStorageCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ETHDKGStorageCallerSession struct {
	Contract *ETHDKGStorageCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ETHDKGStorageTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ETHDKGStorageTransactorSession struct {
	Contract     *ETHDKGStorageTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ETHDKGStorageRaw is an auto generated low-level Go binding around an Ethereum contract.
type ETHDKGStorageRaw struct {
	Contract *ETHDKGStorage // Generic contract binding to access the raw methods on
}

// ETHDKGStorageCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ETHDKGStorageCallerRaw struct {
	Contract *ETHDKGStorageCaller // Generic read-only contract binding to access the raw methods on
}

// ETHDKGStorageTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ETHDKGStorageTransactorRaw struct {
	Contract *ETHDKGStorageTransactor // Generic write-only contract binding to access the raw methods on
}

// NewETHDKGStorage creates a new instance of ETHDKGStorage, bound to a specific deployed contract.
func NewETHDKGStorage(address common.Address, backend bind.ContractBackend) (*ETHDKGStorage, error) {
	contract, err := bindETHDKGStorage(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorage{ETHDKGStorageCaller: ETHDKGStorageCaller{contract: contract}, ETHDKGStorageTransactor: ETHDKGStorageTransactor{contract: contract}, ETHDKGStorageFilterer: ETHDKGStorageFilterer{contract: contract}}, nil
}

// NewETHDKGStorageCaller creates a new read-only instance of ETHDKGStorage, bound to a specific deployed contract.
func NewETHDKGStorageCaller(address common.Address, caller bind.ContractCaller) (*ETHDKGStorageCaller, error) {
	contract, err := bindETHDKGStorage(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageCaller{contract: contract}, nil
}

// NewETHDKGStorageTransactor creates a new write-only instance of ETHDKGStorage, bound to a specific deployed contract.
func NewETHDKGStorageTransactor(address common.Address, transactor bind.ContractTransactor) (*ETHDKGStorageTransactor, error) {
	contract, err := bindETHDKGStorage(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageTransactor{contract: contract}, nil
}

// NewETHDKGStorageFilterer creates a new log filterer instance of ETHDKGStorage, bound to a specific deployed contract.
func NewETHDKGStorageFilterer(address common.Address, filterer bind.ContractFilterer) (*ETHDKGStorageFilterer, error) {
	contract, err := bindETHDKGStorage(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageFilterer{contract: contract}, nil
}

// bindETHDKGStorage binds a generic wrapper to an already deployed contract.
func bindETHDKGStorage(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGStorageABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGStorage *ETHDKGStorageRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGStorage.Contract.ETHDKGStorageCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGStorage *ETHDKGStorageRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGStorage.Contract.ETHDKGStorageTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGStorage *ETHDKGStorageRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGStorage.Contract.ETHDKGStorageTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGStorage *ETHDKGStorageCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGStorage.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGStorage *ETHDKGStorageTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGStorage.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGStorage *ETHDKGStorageTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGStorage.Contract.contract.Transact(opts, method, params...)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) DELTACONFIRM(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "DELTA_CONFIRM")
	return *ret0, err
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGStorage.Contract.DELTACONFIRM(&_ETHDKGStorage.CallOpts)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGStorage.Contract.DELTACONFIRM(&_ETHDKGStorage.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_DISPUTE_END")
	return *ret0, err
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TDISPUTEEND(&_ETHDKGStorage.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TDISPUTEEND(&_ETHDKGStorage.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TDKGCOMPLETE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_DKG_COMPLETE")
	return *ret0, err
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TDKGCOMPLETE(&_ETHDKGStorage.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TDKGCOMPLETE(&_ETHDKGStorage.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TGPKJDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_GPKJ_DISPUTE_END")
	return *ret0, err
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TGPKJDISPUTEEND(&_ETHDKGStorage.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TGPKJDISPUTEEND(&_ETHDKGStorage.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TGPKJSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_GPKJ_SUBMISSION_END")
	return *ret0, err
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TGPKJSUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TGPKJSUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TKEYSHARESUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_KEY_SHARE_SUBMISSION_END")
	return *ret0, err
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TMPKSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_MPK_SUBMISSION_END")
	return *ret0, err
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TMPKSUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TMPKSUBMISSIONEND(&_ETHDKGStorage.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TREGISTRATIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_REGISTRATION_END")
	return *ret0, err
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TREGISTRATIONEND(&_ETHDKGStorage.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TREGISTRATIONEND(&_ETHDKGStorage.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) TSHAREDISTRIBUTIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "T_SHARE_DISTRIBUTION_END")
	return *ret0, err
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGStorage.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGStorage.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGStorage.CallOpts)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGStorage *ETHDKGStorageCaller) Addresses(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "addresses", arg0)
	return *ret0, err
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGStorage *ETHDKGStorageSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGStorage.Contract.Addresses(&_ETHDKGStorage.CallOpts, arg0)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGStorage.Contract.Addresses(&_ETHDKGStorage.CallOpts, arg0)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) Commitments1stCoefficient(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "commitments_1st_coefficient", arg0, arg1)
	return *ret0, err
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.Commitments1stCoefficient(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.Commitments1stCoefficient(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) CompletionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "completion_check")
	return *ret0, err
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) CompletionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.CompletionCheck(&_ETHDKGStorage.CallOpts)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) CompletionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.CompletionCheck(&_ETHDKGStorage.CallOpts)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) GpkjSubmissions(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "gpkj_submissions", arg0, arg1)
	return *ret0, err
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.GpkjSubmissions(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.GpkjSubmissions(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGStorage *ETHDKGStorageCaller) InitialMessage(opts *bind.CallOpts) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "initial_message")
	return *ret0, err
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGStorage *ETHDKGStorageSession) InitialMessage() ([]byte, error) {
	return _ETHDKGStorage.Contract.InitialMessage(&_ETHDKGStorage.CallOpts)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) InitialMessage() ([]byte, error) {
	return _ETHDKGStorage.Contract.InitialMessage(&_ETHDKGStorage.CallOpts)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) InitialSignatures(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "initial_signatures", arg0, arg1)
	return *ret0, err
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.InitialSignatures(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.InitialSignatures(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) IsMalicious(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "is_malicious", arg0)
	return *ret0, err
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGStorage.Contract.IsMalicious(&_ETHDKGStorage.CallOpts, arg0)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGStorage.Contract.IsMalicious(&_ETHDKGStorage.CallOpts, arg0)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) KeyShareSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "key_share_submission_check")
	return *ret0, err
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.KeyShareSubmissionCheck(&_ETHDKGStorage.CallOpts)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.KeyShareSubmissionCheck(&_ETHDKGStorage.CallOpts)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) KeyShares(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "key_shares", arg0, arg1)
	return *ret0, err
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.KeyShares(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.KeyShares(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) MasterPublicKey(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "master_public_key", arg0)
	return *ret0, err
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.MasterPublicKey(&_ETHDKGStorage.CallOpts, arg0)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.MasterPublicKey(&_ETHDKGStorage.CallOpts, arg0)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) MpkSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "mpk_submission_check")
	return *ret0, err
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.MpkSubmissionCheck(&_ETHDKGStorage.CallOpts)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.MpkSubmissionCheck(&_ETHDKGStorage.CallOpts)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCaller) PublicKeys(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "public_keys", arg0, arg1)
	return *ret0, err
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.PublicKeys(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGStorage.Contract.PublicKeys(&_ETHDKGStorage.CallOpts, arg0, arg1)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) RegistrationCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "registration_check")
	return *ret0, err
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) RegistrationCheck() (bool, error) {
	return _ETHDKGStorage.Contract.RegistrationCheck(&_ETHDKGStorage.CallOpts)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) RegistrationCheck() (bool, error) {
	return _ETHDKGStorage.Contract.RegistrationCheck(&_ETHDKGStorage.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCaller) ShareDistributionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "share_distribution_check")
	return *ret0, err
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.ShareDistributionCheck(&_ETHDKGStorage.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGStorage.Contract.ShareDistributionCheck(&_ETHDKGStorage.CallOpts)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGStorage *ETHDKGStorageCaller) ShareDistributionHashes(opts *bind.CallOpts, arg0 common.Address) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ETHDKGStorage.contract.Call(opts, out, "share_distribution_hashes", arg0)
	return *ret0, err
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGStorage *ETHDKGStorageSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGStorage.Contract.ShareDistributionHashes(&_ETHDKGStorage.CallOpts, arg0)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGStorage *ETHDKGStorageCallerSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGStorage.Contract.ShareDistributionHashes(&_ETHDKGStorage.CallOpts, arg0)
}

// ETHDKGStorageKeyShareSubmissionIterator is returned from FilterKeyShareSubmission and is used to iterate over the raw logs and unpacked data for KeyShareSubmission events raised by the ETHDKGStorage contract.
type ETHDKGStorageKeyShareSubmissionIterator struct {
	Event *ETHDKGStorageKeyShareSubmission // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGStorageKeyShareSubmissionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGStorageKeyShareSubmission)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGStorageKeyShareSubmission)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGStorageKeyShareSubmissionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGStorageKeyShareSubmissionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGStorageKeyShareSubmission represents a KeyShareSubmission event raised by the ETHDKGStorage contract.
type ETHDKGStorageKeyShareSubmission struct {
	Issuer                     common.Address
	KeyShareG1                 [2]*big.Int
	KeyShareG1CorrectnessProof [2]*big.Int
	KeyShareG2                 [4]*big.Int
	Raw                        types.Log // Blockchain specific contextual infos
}

// FilterKeyShareSubmission is a free log retrieval operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGStorage *ETHDKGStorageFilterer) FilterKeyShareSubmission(opts *bind.FilterOpts) (*ETHDKGStorageKeyShareSubmissionIterator, error) {

	logs, sub, err := _ETHDKGStorage.contract.FilterLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageKeyShareSubmissionIterator{contract: _ETHDKGStorage.contract, event: "KeyShareSubmission", logs: logs, sub: sub}, nil
}

// WatchKeyShareSubmission is a free log subscription operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGStorage *ETHDKGStorageFilterer) WatchKeyShareSubmission(opts *bind.WatchOpts, sink chan<- *ETHDKGStorageKeyShareSubmission) (event.Subscription, error) {

	logs, sub, err := _ETHDKGStorage.contract.WatchLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGStorageKeyShareSubmission)
				if err := _ETHDKGStorage.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeyShareSubmission is a log parse operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGStorage *ETHDKGStorageFilterer) ParseKeyShareSubmission(log types.Log) (*ETHDKGStorageKeyShareSubmission, error) {
	event := new(ETHDKGStorageKeyShareSubmission)
	if err := _ETHDKGStorage.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGStorageRegistrationOpenIterator is returned from FilterRegistrationOpen and is used to iterate over the raw logs and unpacked data for RegistrationOpen events raised by the ETHDKGStorage contract.
type ETHDKGStorageRegistrationOpenIterator struct {
	Event *ETHDKGStorageRegistrationOpen // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGStorageRegistrationOpenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGStorageRegistrationOpen)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGStorageRegistrationOpen)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGStorageRegistrationOpenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGStorageRegistrationOpenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGStorageRegistrationOpen represents a RegistrationOpen event raised by the ETHDKGStorage contract.
type ETHDKGStorageRegistrationOpen struct {
	DkgStarts              *big.Int
	RegistrationEnds       *big.Int
	ShareDistributionEnds  *big.Int
	DisputeEnds            *big.Int
	KeyShareSubmissionEnds *big.Int
	MpkSubmissionEnds      *big.Int
	GpkjSubmissionEnds     *big.Int
	GpkjDisputeEnds        *big.Int
	DkgComplete            *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterRegistrationOpen is a free log retrieval operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGStorage *ETHDKGStorageFilterer) FilterRegistrationOpen(opts *bind.FilterOpts) (*ETHDKGStorageRegistrationOpenIterator, error) {

	logs, sub, err := _ETHDKGStorage.contract.FilterLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageRegistrationOpenIterator{contract: _ETHDKGStorage.contract, event: "RegistrationOpen", logs: logs, sub: sub}, nil
}

// WatchRegistrationOpen is a free log subscription operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGStorage *ETHDKGStorageFilterer) WatchRegistrationOpen(opts *bind.WatchOpts, sink chan<- *ETHDKGStorageRegistrationOpen) (event.Subscription, error) {

	logs, sub, err := _ETHDKGStorage.contract.WatchLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGStorageRegistrationOpen)
				if err := _ETHDKGStorage.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrationOpen is a log parse operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGStorage *ETHDKGStorageFilterer) ParseRegistrationOpen(log types.Log) (*ETHDKGStorageRegistrationOpen, error) {
	event := new(ETHDKGStorageRegistrationOpen)
	if err := _ETHDKGStorage.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGStorageShareDistributionIterator is returned from FilterShareDistribution and is used to iterate over the raw logs and unpacked data for ShareDistribution events raised by the ETHDKGStorage contract.
type ETHDKGStorageShareDistributionIterator struct {
	Event *ETHDKGStorageShareDistribution // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGStorageShareDistributionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGStorageShareDistribution)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGStorageShareDistribution)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGStorageShareDistributionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGStorageShareDistributionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGStorageShareDistribution represents a ShareDistribution event raised by the ETHDKGStorage contract.
type ETHDKGStorageShareDistribution struct {
	Issuer          common.Address
	Index           *big.Int
	EncryptedShares []*big.Int
	Commitments     [][2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterShareDistribution is a free log retrieval operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGStorage *ETHDKGStorageFilterer) FilterShareDistribution(opts *bind.FilterOpts) (*ETHDKGStorageShareDistributionIterator, error) {

	logs, sub, err := _ETHDKGStorage.contract.FilterLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageShareDistributionIterator{contract: _ETHDKGStorage.contract, event: "ShareDistribution", logs: logs, sub: sub}, nil
}

// WatchShareDistribution is a free log subscription operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGStorage *ETHDKGStorageFilterer) WatchShareDistribution(opts *bind.WatchOpts, sink chan<- *ETHDKGStorageShareDistribution) (event.Subscription, error) {

	logs, sub, err := _ETHDKGStorage.contract.WatchLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGStorageShareDistribution)
				if err := _ETHDKGStorage.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseShareDistribution is a log parse operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGStorage *ETHDKGStorageFilterer) ParseShareDistribution(log types.Log) (*ETHDKGStorageShareDistribution, error) {
	event := new(ETHDKGStorageShareDistribution)
	if err := _ETHDKGStorage.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGStorageValidatorMemberIterator is returned from FilterValidatorMember and is used to iterate over the raw logs and unpacked data for ValidatorMember events raised by the ETHDKGStorage contract.
type ETHDKGStorageValidatorMemberIterator struct {
	Event *ETHDKGStorageValidatorMember // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGStorageValidatorMemberIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGStorageValidatorMember)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGStorageValidatorMember)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGStorageValidatorMemberIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGStorageValidatorMemberIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGStorageValidatorMember represents a ValidatorMember event raised by the ETHDKGStorage contract.
type ETHDKGStorageValidatorMember struct {
	Account common.Address
	Epoch   *big.Int
	Index   *big.Int
	Share0  *big.Int
	Share1  *big.Int
	Share2  *big.Int
	Share3  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterValidatorMember is a free log retrieval operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) FilterValidatorMember(opts *bind.FilterOpts) (*ETHDKGStorageValidatorMemberIterator, error) {

	logs, sub, err := _ETHDKGStorage.contract.FilterLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageValidatorMemberIterator{contract: _ETHDKGStorage.contract, event: "ValidatorMember", logs: logs, sub: sub}, nil
}

// WatchValidatorMember is a free log subscription operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) WatchValidatorMember(opts *bind.WatchOpts, sink chan<- *ETHDKGStorageValidatorMember) (event.Subscription, error) {

	logs, sub, err := _ETHDKGStorage.contract.WatchLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGStorageValidatorMember)
				if err := _ETHDKGStorage.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorMember is a log parse operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) ParseValidatorMember(log types.Log) (*ETHDKGStorageValidatorMember, error) {
	event := new(ETHDKGStorageValidatorMember)
	if err := _ETHDKGStorage.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGStorageValidatorSetIterator is returned from FilterValidatorSet and is used to iterate over the raw logs and unpacked data for ValidatorSet events raised by the ETHDKGStorage contract.
type ETHDKGStorageValidatorSetIterator struct {
	Event *ETHDKGStorageValidatorSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGStorageValidatorSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGStorageValidatorSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGStorageValidatorSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGStorageValidatorSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGStorageValidatorSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGStorageValidatorSet represents a ValidatorSet event raised by the ETHDKGStorage contract.
type ETHDKGStorageValidatorSet struct {
	ValidatorCount uint8
	Epoch          *big.Int
	EthHeight      uint32
	MadHeight      uint32
	GroupKey0      *big.Int
	GroupKey1      *big.Int
	GroupKey2      *big.Int
	GroupKey3      *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterValidatorSet is a free log retrieval operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) FilterValidatorSet(opts *bind.FilterOpts) (*ETHDKGStorageValidatorSetIterator, error) {

	logs, sub, err := _ETHDKGStorage.contract.FilterLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return &ETHDKGStorageValidatorSetIterator{contract: _ETHDKGStorage.contract, event: "ValidatorSet", logs: logs, sub: sub}, nil
}

// WatchValidatorSet is a free log subscription operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) WatchValidatorSet(opts *bind.WatchOpts, sink chan<- *ETHDKGStorageValidatorSet) (event.Subscription, error) {

	logs, sub, err := _ETHDKGStorage.contract.WatchLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGStorageValidatorSet)
				if err := _ETHDKGStorage.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorSet is a log parse operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGStorage *ETHDKGStorageFilterer) ParseValidatorSet(log types.Log) (*ETHDKGStorageValidatorSet, error) {
	event := new(ETHDKGStorageValidatorSet)
	if err := _ETHDKGStorage.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGSubmitMPKABI is the input ABI used to generate the binding from.
const ETHDKGSubmitMPKABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"key_share_G1_correctness_proof\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"key_share_G2\",\"type\":\"uint256[4]\"}],\"name\":\"KeyShareSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgStarts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareDistributionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyShareSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mpkSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjSubmissionEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gpkjDisputeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dkgComplete\",\"type\":\"uint256\"}],\"name\":\"RegistrationOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"encrypted_shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[2][]\",\"name\":\"commitments\",\"type\":\"uint256[2][]\"}],\"name\":\"ShareDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share3\",\"type\":\"uint256\"}],\"name\":\"ValidatorMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"validatorCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ethHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"madHeight\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"groupKey3\",\"type\":\"uint256\"}],\"name\":\"ValidatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELTA_CONFIRM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_DKG_COMPLETE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_DISPUTE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_GPKJ_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_KEY_SHARE_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_MPK_SUBMISSION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REGISTRATION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SHARE_DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments_1st_coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completion_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gpkj_submissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_message\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_signatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_malicious\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"key_share_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"key_shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"master_public_key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpk_submission_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"public_keys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registration_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share_distribution_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_distribution_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"_master_public_key\",\"type\":\"uint256[4]\"}],\"name\":\"submit_master_public_key\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ETHDKGSubmitMPKBin is the compiled bytecode used for deploying new contracts.
var ETHDKGSubmitMPKBin = "0x608060405260405160200180807f43727970746f67726170687920697320677265617400000000000000000000008152506015019050604051602081830303815290604052600d90805190602001906200005b92919062000075565b5060286017553480156200006e57600080fd5b5062000124565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000b857805160ff1916838001178555620000e9565b82800160010185558215620000e9579182015b82811115620000e8578251825591602001919060010190620000cb565b5b509050620000f89190620000fc565b5090565b6200012191905b808211156200011d57600081600090555060010162000103565b5090565b90565b61159080620001346000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063a88c9e1c116100de578063dc614e2811610097578063eadfcadc11610071578063eadfcadc146105d5578063edf26d9b14610631578063f47ae6a91461069f578063fef001a91461071c57610173565b8063dc614e2814610557578063e2291ec314610575578063e65113781461059357610173565b8063a88c9e1c146103bc578063aa7bd3381461041e578063ab63c722146104a1578063b7b09ed6146104bf578063c21bee83146104e1578063d3cf61861461053957610173565b80637543b80f116101305780637543b80f146102bc57806375f7ed6a146102da57806377fbebd1146102fc578063836889dc1461031a57806392896b2d1461033c5780639c2aa8381461039e57610173565b8063050a54f01461017857806307f02c541461019a5780630de1553f146101b85780632cf4050b146101d65780632f11b985146102385780637328f8261461025a575b600080fd5b61018061077e565b604051808215151515815260200191505060405180910390f35b6101a2610791565b6040518082815260200191505060405180910390f35b6101c0610797565b6040518082815260200191505060405180910390f35b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061079d565b6040518082815260200191505060405180910390f35b6102406107c2565b604051808215151515815260200191505060405180910390f35b6102a66004803603604081101561027057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506107d5565b6040518082815260200191505060405180910390f35b6102c46107fa565b6040518082815260200191505060405180910390f35b6102e26107ff565b604051808215151515815260200191505060405180910390f35b610304610812565b6040518082815260200191505060405180910390f35b610322610818565b604051808215151515815260200191505060405180910390f35b6103886004803603604081101561035257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061082b565b6040518082815260200191505060405180910390f35b6103a6610850565b6040518082815260200191505060405180910390f35b610408600480360360408110156103d257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610856565b6040518082815260200191505060405180910390f35b61042661087b565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561046657808201518184015260208101905061044b565b50505050905090810190601f1680156104935780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6104a9610919565b6040518082815260200191505060405180910390f35b6104c761091f565b604051808215151515815260200191505060405180910390f35b610523600480360360208110156104f757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610932565b6040518082815260200191505060405180910390f35b61054161094a565b6040518082815260200191505060405180910390f35b61055f610950565b6040518082815260200191505060405180910390f35b61057d610956565b6040518082815260200191505060405180910390f35b6105bf600480360360208110156105a957600080fd5b810190808035906020019092919050505061095c565b6040518082815260200191505060405180910390f35b610617600480360360208110156105eb57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610974565b604051808215151515815260200191505060405180910390f35b61065d6004803603602081101561064757600080fd5b8101908080359060200190929190505050610994565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610702600480360360808110156106b557600080fd5b8101908080608001906004806020026040519081016040528092919082600460200280828437600081840152601f19601f82011690508083019250505050505091929192905050506109d0565b604051808215151515815260200191505060405180910390f35b6107686004803603604081101561073257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611337565b6040518082815260200191505060405180910390f35b600e60039054906101000a900460ff1681565b60135481565b600f5481565b600360205281600052604060002081600281106107b657fe5b01600091509150505481565b600e60019054906101000a900460ff1681565b600660205281600052604060002081600281106107ee57fe5b01600091509150505481565b600681565b600e60049054906101000a900460ff1681565b60165481565b600e60029054906101000a900460ff1681565b6001602052816000526040600020816002811061084457fe5b01600091509150505481565b60145481565b6004602052816000526040600020816002811061086f57fe5b01600091509150505481565b600d8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156109115780601f106108e657610100808354040283529160200191610911565b820191906000526020600020905b8154815290600101906020018083116108f457829003601f168201915b505050505081565b60155481565b600e60009054906101000a900460ff1681565b60026020528060005260406000206000915090505481565b60115481565b60105481565b60125481565b6009816004811061096957fe5b016000915090505481565b60086020528060005260406000206000915054906101000a900460ff1681565b600081815481106109a157fe5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000436012541080156109e557506013544311155b610a3a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260468152602001806114b26046913960600191505060405180910390fd5b600e60029054906101000a900460ff16610bed5760006001905060005b600080549050811015610bc0576000808281548110610a7257fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600060028110610aec57fe5b01541415610bb25760009250601b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d2a2c55c826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015610b9957600080fd5b505af1158015610bad573d6000803e3d6000fd5b505050505b508080600101915050610a57565b5080610bd0576001915050611332565b6001600e60026101000a81548160ff021916908315150217905550505b60006009600060048110610bfd57fe5b0154141580610c1c575060006009600160048110610c1757fe5b015414155b80610c37575060006009600260048110610c3257fe5b015414155b80610c52575060006009600360048110610c4d57fe5b015414155b15610c605760009050611332565b600080805490509050600080905060005b60008281548110610c7e57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506001820191508282108015610d0157506000801b600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054145b610c7157610d0d611408565b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015610d83576020028201915b815481526020019060010190808311610d6f575b50505050509050600081600060028110610d9957fe5b60200201511415610df5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603081526020018061152b6030913960400191505060405180910390fd5b610dfd611408565b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015610e73576020028201915b815481526020019060010190808311610e5f575b505050505090505b848410156111415760008481548110610e9057fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1692506000801b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541415610f0c57611136565b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015610f82576020028201915b815481526020019060010190808311610f6e575b50505050509150600082600060028110610f9857fe5b60200201511415610ff4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603081526020018061152b6030913960400191505060405180910390fd5b601960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e664725b60405180608001604052808460006002811061104a57fe5b602002015181526020018460016002811061106157fe5b602002015181526020018560006002811061107857fe5b602002015181526020018560016002811061108f57fe5b60200201518152506040518263ffffffff1660e01b81526004018082600460200280838360005b838110156110d15780820151818401526020810190506110b6565b50505050905001915050604080518083038186803b1580156110f257600080fd5b505afa158015611106573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250604081101561112b57600080fd5b810190809190505090505b600184019350610e7b565b6112c16040518061018001604052808360006002811061115d57fe5b602002015181526020018360016002811061117457fe5b602002015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d81526020017f062a0ad5cf656709286b38ae4fb927fc901c5f9cf9623bfd0b6d22d30f95a1f381526020017f1b4af7018d896f006d7e5c23d05903b5d2698da94674e546e51f77b6df70ffac81526020018960006004811061126f57fe5b602002015181526020018960016004811061128657fe5b602002015181526020018960026004811061129d57fe5b60200201518152602001896003600481106112b457fe5b602002015181525061135c565b611316576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260338152602001806114f86033913960400191505060405180910390fd5b86600990600461132792919061142a565b506000955050505050505b919050565b6005602052816000526040600020816004811061135057fe5b01600091509150505481565b600061136661146a565b6000602082610180866008600019fa9050806113ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f656c6c69707469632063757276652070616972696e67206661696c656400000081525060200191505060405180910390fd5b6001826000600181106113f957fe5b60200201511492505050919050565b6040518060400160405280600290602082028036833780820191505090505090565b8260048101928215611459579160200282015b8281111561145857825182559160200191906001019061143d565b5b509050611466919061148c565b5090565b6040518060200160405280600190602082028036833780820191505090505090565b6114ae91905b808211156114aa576000816000905550600101611492565b5090565b9056fe6d6173746572206b6579207375626d697373696f6e206661696c65642028636f6e7472616374206973206e6f7420696e206d706b2064657269766174696f6e207068617365296d6173746572206b6579207375626d697373696f6e206661696c6564202870616972696e6720636865636b206661696c6564296d6173746572206b6579207375626d697373696f6e206661696c656420286b6579207368617265206d697373696e6729a2646970667358221220caab6dfbed71215971e3aa5c2e2458dec7b65a18954a42a3a8f27f316cd5fc8f64736f6c63430006070033"

// DeployETHDKGSubmitMPK deploys a new Ethereum contract, binding an instance of ETHDKGSubmitMPK to it.
func DeployETHDKGSubmitMPK(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ETHDKGSubmitMPK, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGSubmitMPKABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ETHDKGSubmitMPKBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ETHDKGSubmitMPK{ETHDKGSubmitMPKCaller: ETHDKGSubmitMPKCaller{contract: contract}, ETHDKGSubmitMPKTransactor: ETHDKGSubmitMPKTransactor{contract: contract}, ETHDKGSubmitMPKFilterer: ETHDKGSubmitMPKFilterer{contract: contract}}, nil
}

// ETHDKGSubmitMPK is an auto generated Go binding around an Ethereum contract.
type ETHDKGSubmitMPK struct {
	ETHDKGSubmitMPKCaller     // Read-only binding to the contract
	ETHDKGSubmitMPKTransactor // Write-only binding to the contract
	ETHDKGSubmitMPKFilterer   // Log filterer for contract events
}

// ETHDKGSubmitMPKCaller is an auto generated read-only Go binding around an Ethereum contract.
type ETHDKGSubmitMPKCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGSubmitMPKTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ETHDKGSubmitMPKTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGSubmitMPKFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ETHDKGSubmitMPKFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ETHDKGSubmitMPKSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ETHDKGSubmitMPKSession struct {
	Contract     *ETHDKGSubmitMPK  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ETHDKGSubmitMPKCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ETHDKGSubmitMPKCallerSession struct {
	Contract *ETHDKGSubmitMPKCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ETHDKGSubmitMPKTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ETHDKGSubmitMPKTransactorSession struct {
	Contract     *ETHDKGSubmitMPKTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ETHDKGSubmitMPKRaw is an auto generated low-level Go binding around an Ethereum contract.
type ETHDKGSubmitMPKRaw struct {
	Contract *ETHDKGSubmitMPK // Generic contract binding to access the raw methods on
}

// ETHDKGSubmitMPKCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ETHDKGSubmitMPKCallerRaw struct {
	Contract *ETHDKGSubmitMPKCaller // Generic read-only contract binding to access the raw methods on
}

// ETHDKGSubmitMPKTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ETHDKGSubmitMPKTransactorRaw struct {
	Contract *ETHDKGSubmitMPKTransactor // Generic write-only contract binding to access the raw methods on
}

// NewETHDKGSubmitMPK creates a new instance of ETHDKGSubmitMPK, bound to a specific deployed contract.
func NewETHDKGSubmitMPK(address common.Address, backend bind.ContractBackend) (*ETHDKGSubmitMPK, error) {
	contract, err := bindETHDKGSubmitMPK(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPK{ETHDKGSubmitMPKCaller: ETHDKGSubmitMPKCaller{contract: contract}, ETHDKGSubmitMPKTransactor: ETHDKGSubmitMPKTransactor{contract: contract}, ETHDKGSubmitMPKFilterer: ETHDKGSubmitMPKFilterer{contract: contract}}, nil
}

// NewETHDKGSubmitMPKCaller creates a new read-only instance of ETHDKGSubmitMPK, bound to a specific deployed contract.
func NewETHDKGSubmitMPKCaller(address common.Address, caller bind.ContractCaller) (*ETHDKGSubmitMPKCaller, error) {
	contract, err := bindETHDKGSubmitMPK(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKCaller{contract: contract}, nil
}

// NewETHDKGSubmitMPKTransactor creates a new write-only instance of ETHDKGSubmitMPK, bound to a specific deployed contract.
func NewETHDKGSubmitMPKTransactor(address common.Address, transactor bind.ContractTransactor) (*ETHDKGSubmitMPKTransactor, error) {
	contract, err := bindETHDKGSubmitMPK(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKTransactor{contract: contract}, nil
}

// NewETHDKGSubmitMPKFilterer creates a new log filterer instance of ETHDKGSubmitMPK, bound to a specific deployed contract.
func NewETHDKGSubmitMPKFilterer(address common.Address, filterer bind.ContractFilterer) (*ETHDKGSubmitMPKFilterer, error) {
	contract, err := bindETHDKGSubmitMPK(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKFilterer{contract: contract}, nil
}

// bindETHDKGSubmitMPK binds a generic wrapper to an already deployed contract.
func bindETHDKGSubmitMPK(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ETHDKGSubmitMPKABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGSubmitMPK.Contract.ETHDKGSubmitMPKCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.ETHDKGSubmitMPKTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.ETHDKGSubmitMPKTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ETHDKGSubmitMPK.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.contract.Transact(opts, method, params...)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) DELTACONFIRM(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "DELTA_CONFIRM")
	return *ret0, err
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.DELTACONFIRM(&_ETHDKGSubmitMPK.CallOpts)
}

// DELTACONFIRM is a free data retrieval call binding the contract method 0x7543b80f.
//
// Solidity: function DELTA_CONFIRM() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) DELTACONFIRM() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.DELTACONFIRM(&_ETHDKGSubmitMPK.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_DISPUTE_END")
	return *ret0, err
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TDISPUTEEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TDISPUTEEND is a free data retrieval call binding the contract method 0xd3cf6186.
//
// Solidity: function T_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TDISPUTEEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TDISPUTEEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TDKGCOMPLETE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_DKG_COMPLETE")
	return *ret0, err
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TDKGCOMPLETE(&_ETHDKGSubmitMPK.CallOpts)
}

// TDKGCOMPLETE is a free data retrieval call binding the contract method 0x77fbebd1.
//
// Solidity: function T_DKG_COMPLETE() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TDKGCOMPLETE() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TDKGCOMPLETE(&_ETHDKGSubmitMPK.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TGPKJDISPUTEEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_GPKJ_DISPUTE_END")
	return *ret0, err
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TGPKJDISPUTEEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TGPKJDISPUTEEND is a free data retrieval call binding the contract method 0xab63c722.
//
// Solidity: function T_GPKJ_DISPUTE_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TGPKJDISPUTEEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TGPKJDISPUTEEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TGPKJSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_GPKJ_SUBMISSION_END")
	return *ret0, err
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TGPKJSUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TGPKJSUBMISSIONEND is a free data retrieval call binding the contract method 0x9c2aa838.
//
// Solidity: function T_GPKJ_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TGPKJSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TGPKJSUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TKEYSHARESUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_KEY_SHARE_SUBMISSION_END")
	return *ret0, err
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TKEYSHARESUBMISSIONEND is a free data retrieval call binding the contract method 0xe2291ec3.
//
// Solidity: function T_KEY_SHARE_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TKEYSHARESUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TKEYSHARESUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TMPKSUBMISSIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_MPK_SUBMISSION_END")
	return *ret0, err
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TMPKSUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TMPKSUBMISSIONEND is a free data retrieval call binding the contract method 0x07f02c54.
//
// Solidity: function T_MPK_SUBMISSION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TMPKSUBMISSIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TMPKSUBMISSIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TREGISTRATIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_REGISTRATION_END")
	return *ret0, err
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TREGISTRATIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TREGISTRATIONEND is a free data retrieval call binding the contract method 0x0de1553f.
//
// Solidity: function T_REGISTRATION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TREGISTRATIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TREGISTRATIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) TSHAREDISTRIBUTIONEND(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "T_SHARE_DISTRIBUTION_END")
	return *ret0, err
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// TSHAREDISTRIBUTIONEND is a free data retrieval call binding the contract method 0xdc614e28.
//
// Solidity: function T_SHARE_DISTRIBUTION_END() view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) TSHAREDISTRIBUTIONEND() (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.TSHAREDISTRIBUTIONEND(&_ETHDKGSubmitMPK.CallOpts)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) Addresses(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "addresses", arg0)
	return *ret0, err
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGSubmitMPK.Contract.Addresses(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// Addresses is a free data retrieval call binding the contract method 0xedf26d9b.
//
// Solidity: function addresses(uint256 ) view returns(address)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) Addresses(arg0 *big.Int) (common.Address, error) {
	return _ETHDKGSubmitMPK.Contract.Addresses(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) Commitments1stCoefficient(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "commitments_1st_coefficient", arg0, arg1)
	return *ret0, err
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.Commitments1stCoefficient(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// Commitments1stCoefficient is a free data retrieval call binding the contract method 0x2cf4050b.
//
// Solidity: function commitments_1st_coefficient(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) Commitments1stCoefficient(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.Commitments1stCoefficient(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) CompletionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "completion_check")
	return *ret0, err
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) CompletionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.CompletionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// CompletionCheck is a free data retrieval call binding the contract method 0x75f7ed6a.
//
// Solidity: function completion_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) CompletionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.CompletionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) GpkjSubmissions(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "gpkj_submissions", arg0, arg1)
	return *ret0, err
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.GpkjSubmissions(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// GpkjSubmissions is a free data retrieval call binding the contract method 0xfef001a9.
//
// Solidity: function gpkj_submissions(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) GpkjSubmissions(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.GpkjSubmissions(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) InitialMessage(opts *bind.CallOpts) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "initial_message")
	return *ret0, err
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) InitialMessage() ([]byte, error) {
	return _ETHDKGSubmitMPK.Contract.InitialMessage(&_ETHDKGSubmitMPK.CallOpts)
}

// InitialMessage is a free data retrieval call binding the contract method 0xaa7bd338.
//
// Solidity: function initial_message() view returns(bytes)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) InitialMessage() ([]byte, error) {
	return _ETHDKGSubmitMPK.Contract.InitialMessage(&_ETHDKGSubmitMPK.CallOpts)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) InitialSignatures(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "initial_signatures", arg0, arg1)
	return *ret0, err
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.InitialSignatures(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// InitialSignatures is a free data retrieval call binding the contract method 0x7328f826.
//
// Solidity: function initial_signatures(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) InitialSignatures(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.InitialSignatures(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) IsMalicious(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "is_malicious", arg0)
	return *ret0, err
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGSubmitMPK.Contract.IsMalicious(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// IsMalicious is a free data retrieval call binding the contract method 0xeadfcadc.
//
// Solidity: function is_malicious(address ) view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) IsMalicious(arg0 common.Address) (bool, error) {
	return _ETHDKGSubmitMPK.Contract.IsMalicious(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) KeyShareSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "key_share_submission_check")
	return *ret0, err
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.KeyShareSubmissionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// KeyShareSubmissionCheck is a free data retrieval call binding the contract method 0x836889dc.
//
// Solidity: function key_share_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) KeyShareSubmissionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.KeyShareSubmissionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) KeyShares(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "key_shares", arg0, arg1)
	return *ret0, err
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.KeyShares(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// KeyShares is a free data retrieval call binding the contract method 0xa88c9e1c.
//
// Solidity: function key_shares(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) KeyShares(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.KeyShares(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) MasterPublicKey(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "master_public_key", arg0)
	return *ret0, err
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.MasterPublicKey(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// MasterPublicKey is a free data retrieval call binding the contract method 0xe6511378.
//
// Solidity: function master_public_key(uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) MasterPublicKey(arg0 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.MasterPublicKey(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) MpkSubmissionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "mpk_submission_check")
	return *ret0, err
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.MpkSubmissionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// MpkSubmissionCheck is a free data retrieval call binding the contract method 0x050a54f0.
//
// Solidity: function mpk_submission_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) MpkSubmissionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.MpkSubmissionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) PublicKeys(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "public_keys", arg0, arg1)
	return *ret0, err
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.PublicKeys(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// PublicKeys is a free data retrieval call binding the contract method 0x92896b2d.
//
// Solidity: function public_keys(address , uint256 ) view returns(uint256)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) PublicKeys(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _ETHDKGSubmitMPK.Contract.PublicKeys(&_ETHDKGSubmitMPK.CallOpts, arg0, arg1)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) RegistrationCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "registration_check")
	return *ret0, err
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) RegistrationCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.RegistrationCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// RegistrationCheck is a free data retrieval call binding the contract method 0xb7b09ed6.
//
// Solidity: function registration_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) RegistrationCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.RegistrationCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) ShareDistributionCheck(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "share_distribution_check")
	return *ret0, err
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.ShareDistributionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// ShareDistributionCheck is a free data retrieval call binding the contract method 0x2f11b985.
//
// Solidity: function share_distribution_check() view returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) ShareDistributionCheck() (bool, error) {
	return _ETHDKGSubmitMPK.Contract.ShareDistributionCheck(&_ETHDKGSubmitMPK.CallOpts)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCaller) ShareDistributionHashes(opts *bind.CallOpts, arg0 common.Address) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ETHDKGSubmitMPK.contract.Call(opts, out, "share_distribution_hashes", arg0)
	return *ret0, err
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGSubmitMPK.Contract.ShareDistributionHashes(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// ShareDistributionHashes is a free data retrieval call binding the contract method 0xc21bee83.
//
// Solidity: function share_distribution_hashes(address ) view returns(bytes32)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKCallerSession) ShareDistributionHashes(arg0 common.Address) ([32]byte, error) {
	return _ETHDKGSubmitMPK.Contract.ShareDistributionHashes(&_ETHDKGSubmitMPK.CallOpts, arg0)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKTransactor) SubmitMasterPublicKey(opts *bind.TransactOpts, _master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.contract.Transact(opts, "submit_master_public_key", _master_public_key)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKSession) SubmitMasterPublicKey(_master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.SubmitMasterPublicKey(&_ETHDKGSubmitMPK.TransactOpts, _master_public_key)
}

// SubmitMasterPublicKey is a paid mutator transaction binding the contract method 0xf47ae6a9.
//
// Solidity: function submit_master_public_key(uint256[4] _master_public_key) returns(bool)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKTransactorSession) SubmitMasterPublicKey(_master_public_key [4]*big.Int) (*types.Transaction, error) {
	return _ETHDKGSubmitMPK.Contract.SubmitMasterPublicKey(&_ETHDKGSubmitMPK.TransactOpts, _master_public_key)
}

// ETHDKGSubmitMPKKeyShareSubmissionIterator is returned from FilterKeyShareSubmission and is used to iterate over the raw logs and unpacked data for KeyShareSubmission events raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKKeyShareSubmissionIterator struct {
	Event *ETHDKGSubmitMPKKeyShareSubmission // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGSubmitMPKKeyShareSubmissionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGSubmitMPKKeyShareSubmission)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGSubmitMPKKeyShareSubmission)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGSubmitMPKKeyShareSubmissionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGSubmitMPKKeyShareSubmissionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGSubmitMPKKeyShareSubmission represents a KeyShareSubmission event raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKKeyShareSubmission struct {
	Issuer                     common.Address
	KeyShareG1                 [2]*big.Int
	KeyShareG1CorrectnessProof [2]*big.Int
	KeyShareG2                 [4]*big.Int
	Raw                        types.Log // Blockchain specific contextual infos
}

// FilterKeyShareSubmission is a free log retrieval operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) FilterKeyShareSubmission(opts *bind.FilterOpts) (*ETHDKGSubmitMPKKeyShareSubmissionIterator, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.FilterLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKKeyShareSubmissionIterator{contract: _ETHDKGSubmitMPK.contract, event: "KeyShareSubmission", logs: logs, sub: sub}, nil
}

// WatchKeyShareSubmission is a free log subscription operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) WatchKeyShareSubmission(opts *bind.WatchOpts, sink chan<- *ETHDKGSubmitMPKKeyShareSubmission) (event.Subscription, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.WatchLogs(opts, "KeyShareSubmission")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGSubmitMPKKeyShareSubmission)
				if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKeyShareSubmission is a log parse operation binding the contract event 0xb0ee36c3780de716eb6c83687f433ae2558a6923e090fd238b657fb6c896badc.
//
// Solidity: event KeyShareSubmission(address issuer, uint256[2] key_share_G1, uint256[2] key_share_G1_correctness_proof, uint256[4] key_share_G2)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) ParseKeyShareSubmission(log types.Log) (*ETHDKGSubmitMPKKeyShareSubmission, error) {
	event := new(ETHDKGSubmitMPKKeyShareSubmission)
	if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "KeyShareSubmission", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGSubmitMPKRegistrationOpenIterator is returned from FilterRegistrationOpen and is used to iterate over the raw logs and unpacked data for RegistrationOpen events raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKRegistrationOpenIterator struct {
	Event *ETHDKGSubmitMPKRegistrationOpen // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGSubmitMPKRegistrationOpenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGSubmitMPKRegistrationOpen)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGSubmitMPKRegistrationOpen)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGSubmitMPKRegistrationOpenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGSubmitMPKRegistrationOpenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGSubmitMPKRegistrationOpen represents a RegistrationOpen event raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKRegistrationOpen struct {
	DkgStarts              *big.Int
	RegistrationEnds       *big.Int
	ShareDistributionEnds  *big.Int
	DisputeEnds            *big.Int
	KeyShareSubmissionEnds *big.Int
	MpkSubmissionEnds      *big.Int
	GpkjSubmissionEnds     *big.Int
	GpkjDisputeEnds        *big.Int
	DkgComplete            *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterRegistrationOpen is a free log retrieval operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) FilterRegistrationOpen(opts *bind.FilterOpts) (*ETHDKGSubmitMPKRegistrationOpenIterator, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.FilterLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKRegistrationOpenIterator{contract: _ETHDKGSubmitMPK.contract, event: "RegistrationOpen", logs: logs, sub: sub}, nil
}

// WatchRegistrationOpen is a free log subscription operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) WatchRegistrationOpen(opts *bind.WatchOpts, sink chan<- *ETHDKGSubmitMPKRegistrationOpen) (event.Subscription, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.WatchLogs(opts, "RegistrationOpen")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGSubmitMPKRegistrationOpen)
				if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrationOpen is a log parse operation binding the contract event 0x9c6f8368fe7e77e8cb9438744581403bcb3f53298e517f04c1b8475487402e97.
//
// Solidity: event RegistrationOpen(uint256 dkgStarts, uint256 registrationEnds, uint256 shareDistributionEnds, uint256 disputeEnds, uint256 keyShareSubmissionEnds, uint256 mpkSubmissionEnds, uint256 gpkjSubmissionEnds, uint256 gpkjDisputeEnds, uint256 dkgComplete)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) ParseRegistrationOpen(log types.Log) (*ETHDKGSubmitMPKRegistrationOpen, error) {
	event := new(ETHDKGSubmitMPKRegistrationOpen)
	if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "RegistrationOpen", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGSubmitMPKShareDistributionIterator is returned from FilterShareDistribution and is used to iterate over the raw logs and unpacked data for ShareDistribution events raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKShareDistributionIterator struct {
	Event *ETHDKGSubmitMPKShareDistribution // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGSubmitMPKShareDistributionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGSubmitMPKShareDistribution)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGSubmitMPKShareDistribution)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGSubmitMPKShareDistributionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGSubmitMPKShareDistributionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGSubmitMPKShareDistribution represents a ShareDistribution event raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKShareDistribution struct {
	Issuer          common.Address
	Index           *big.Int
	EncryptedShares []*big.Int
	Commitments     [][2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterShareDistribution is a free log retrieval operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) FilterShareDistribution(opts *bind.FilterOpts) (*ETHDKGSubmitMPKShareDistributionIterator, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.FilterLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKShareDistributionIterator{contract: _ETHDKGSubmitMPK.contract, event: "ShareDistribution", logs: logs, sub: sub}, nil
}

// WatchShareDistribution is a free log subscription operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) WatchShareDistribution(opts *bind.WatchOpts, sink chan<- *ETHDKGSubmitMPKShareDistribution) (event.Subscription, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.WatchLogs(opts, "ShareDistribution")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGSubmitMPKShareDistribution)
				if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseShareDistribution is a log parse operation binding the contract event 0xa84d294194d6169652a99150fd2ef10e18b0d2caa10beeea237bbddcc6e22b10.
//
// Solidity: event ShareDistribution(address issuer, uint256 index, uint256[] encrypted_shares, uint256[2][] commitments)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) ParseShareDistribution(log types.Log) (*ETHDKGSubmitMPKShareDistribution, error) {
	event := new(ETHDKGSubmitMPKShareDistribution)
	if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ShareDistribution", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGSubmitMPKValidatorMemberIterator is returned from FilterValidatorMember and is used to iterate over the raw logs and unpacked data for ValidatorMember events raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKValidatorMemberIterator struct {
	Event *ETHDKGSubmitMPKValidatorMember // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGSubmitMPKValidatorMemberIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGSubmitMPKValidatorMember)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGSubmitMPKValidatorMember)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGSubmitMPKValidatorMemberIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGSubmitMPKValidatorMemberIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGSubmitMPKValidatorMember represents a ValidatorMember event raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKValidatorMember struct {
	Account common.Address
	Epoch   *big.Int
	Index   *big.Int
	Share0  *big.Int
	Share1  *big.Int
	Share2  *big.Int
	Share3  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterValidatorMember is a free log retrieval operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) FilterValidatorMember(opts *bind.FilterOpts) (*ETHDKGSubmitMPKValidatorMemberIterator, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.FilterLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKValidatorMemberIterator{contract: _ETHDKGSubmitMPK.contract, event: "ValidatorMember", logs: logs, sub: sub}, nil
}

// WatchValidatorMember is a free log subscription operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) WatchValidatorMember(opts *bind.WatchOpts, sink chan<- *ETHDKGSubmitMPKValidatorMember) (event.Subscription, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.WatchLogs(opts, "ValidatorMember")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGSubmitMPKValidatorMember)
				if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorMember is a log parse operation binding the contract event 0x113b129fac2dde341b9fbbec2bb79a95b9945b0e80fda711fc8ae5c7b0ea83b0.
//
// Solidity: event ValidatorMember(address account, uint256 epoch, uint256 index, uint256 share0, uint256 share1, uint256 share2, uint256 share3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) ParseValidatorMember(log types.Log) (*ETHDKGSubmitMPKValidatorMember, error) {
	event := new(ETHDKGSubmitMPKValidatorMember)
	if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ValidatorMember", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ETHDKGSubmitMPKValidatorSetIterator is returned from FilterValidatorSet and is used to iterate over the raw logs and unpacked data for ValidatorSet events raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKValidatorSetIterator struct {
	Event *ETHDKGSubmitMPKValidatorSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ETHDKGSubmitMPKValidatorSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ETHDKGSubmitMPKValidatorSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ETHDKGSubmitMPKValidatorSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ETHDKGSubmitMPKValidatorSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ETHDKGSubmitMPKValidatorSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ETHDKGSubmitMPKValidatorSet represents a ValidatorSet event raised by the ETHDKGSubmitMPK contract.
type ETHDKGSubmitMPKValidatorSet struct {
	ValidatorCount uint8
	Epoch          *big.Int
	EthHeight      uint32
	MadHeight      uint32
	GroupKey0      *big.Int
	GroupKey1      *big.Int
	GroupKey2      *big.Int
	GroupKey3      *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterValidatorSet is a free log retrieval operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) FilterValidatorSet(opts *bind.FilterOpts) (*ETHDKGSubmitMPKValidatorSetIterator, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.FilterLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return &ETHDKGSubmitMPKValidatorSetIterator{contract: _ETHDKGSubmitMPK.contract, event: "ValidatorSet", logs: logs, sub: sub}, nil
}

// WatchValidatorSet is a free log subscription operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) WatchValidatorSet(opts *bind.WatchOpts, sink chan<- *ETHDKGSubmitMPKValidatorSet) (event.Subscription, error) {

	logs, sub, err := _ETHDKGSubmitMPK.contract.WatchLogs(opts, "ValidatorSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ETHDKGSubmitMPKValidatorSet)
				if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorSet is a log parse operation binding the contract event 0x1c85ff1efe0a905f8feca811e617102cb7ec896aded693eb96366c8ef22bb09f.
//
// Solidity: event ValidatorSet(uint8 validatorCount, uint256 epoch, uint32 ethHeight, uint32 madHeight, uint256 groupKey0, uint256 groupKey1, uint256 groupKey2, uint256 groupKey3)
func (_ETHDKGSubmitMPK *ETHDKGSubmitMPKFilterer) ParseValidatorSet(log types.Log) (*ETHDKGSubmitMPKValidatorSet, error) {
	event := new(ETHDKGSubmitMPKValidatorSet)
	if err := _ETHDKGSubmitMPK.contract.UnpackLog(event, "ValidatorSet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MerkleProofABI is the input ABI used to generate the binding from.
const MerkleProofABI = "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"self\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"bitSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"}],\"name\":\"checkProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]"

// MerkleProofBin is the compiled bytecode used for deploying new contracts.
var MerkleProofBin = "0x608060405234801561001057600080fd5b5061028e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806360938ac81461003b578063e3f9c6c41461012c575b600080fd5b6101126004803603608081101561005157600080fd5b810190808035906020019064010000000081111561006e57600080fd5b82018360208201111561008057600080fd5b803590602001918460018302840111640100000000831117156100a257600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190803590602001909291908035906020019092919050505061017f565b604051808215151515815260200191505060405180910390f35b6101656004803603604081101561014257600080fd5b8101908080359060200190929190803560ff16906020019092919050505061023f565b604051808215151515815260200191505060405180910390f35b600080600084905060008090506000602090505b8851811161022e578089015193506101ae868360ff0361023f565b156101e9578383604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120925061021b565b828460405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092505b8180600101925050602081019050610193565b508682149350505050949350505050565b60006001808360ff0360ff1685901c161490509291505056fea2646970667358221220c673eeb0a36be4ebc0b06ed19194e113bd43a2524135814aa0ddb902ab5efcfa64736f6c63430006070033"

// DeployMerkleProof deploys a new Ethereum contract, binding an instance of MerkleProof to it.
func DeployMerkleProof(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MerkleProof, error) {
	parsed, err := abi.JSON(strings.NewReader(MerkleProofABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MerkleProofBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MerkleProof{MerkleProofCaller: MerkleProofCaller{contract: contract}, MerkleProofTransactor: MerkleProofTransactor{contract: contract}, MerkleProofFilterer: MerkleProofFilterer{contract: contract}}, nil
}

// MerkleProof is an auto generated Go binding around an Ethereum contract.
type MerkleProof struct {
	MerkleProofCaller     // Read-only binding to the contract
	MerkleProofTransactor // Write-only binding to the contract
	MerkleProofFilterer   // Log filterer for contract events
}

// MerkleProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type MerkleProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MerkleProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MerkleProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MerkleProofSession struct {
	Contract     *MerkleProof      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MerkleProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MerkleProofCallerSession struct {
	Contract *MerkleProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// MerkleProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MerkleProofTransactorSession struct {
	Contract     *MerkleProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// MerkleProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type MerkleProofRaw struct {
	Contract *MerkleProof // Generic contract binding to access the raw methods on
}

// MerkleProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MerkleProofCallerRaw struct {
	Contract *MerkleProofCaller // Generic read-only contract binding to access the raw methods on
}

// MerkleProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MerkleProofTransactorRaw struct {
	Contract *MerkleProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMerkleProof creates a new instance of MerkleProof, bound to a specific deployed contract.
func NewMerkleProof(address common.Address, backend bind.ContractBackend) (*MerkleProof, error) {
	contract, err := bindMerkleProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MerkleProof{MerkleProofCaller: MerkleProofCaller{contract: contract}, MerkleProofTransactor: MerkleProofTransactor{contract: contract}, MerkleProofFilterer: MerkleProofFilterer{contract: contract}}, nil
}

// NewMerkleProofCaller creates a new read-only instance of MerkleProof, bound to a specific deployed contract.
func NewMerkleProofCaller(address common.Address, caller bind.ContractCaller) (*MerkleProofCaller, error) {
	contract, err := bindMerkleProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofCaller{contract: contract}, nil
}

// NewMerkleProofTransactor creates a new write-only instance of MerkleProof, bound to a specific deployed contract.
func NewMerkleProofTransactor(address common.Address, transactor bind.ContractTransactor) (*MerkleProofTransactor, error) {
	contract, err := bindMerkleProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTransactor{contract: contract}, nil
}

// NewMerkleProofFilterer creates a new log filterer instance of MerkleProof, bound to a specific deployed contract.
func NewMerkleProofFilterer(address common.Address, filterer bind.ContractFilterer) (*MerkleProofFilterer, error) {
	contract, err := bindMerkleProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MerkleProofFilterer{contract: contract}, nil
}

// bindMerkleProof binds a generic wrapper to an already deployed contract.
func bindMerkleProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MerkleProofABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProof *MerkleProofRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MerkleProof.Contract.MerkleProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProof *MerkleProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProof.Contract.MerkleProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProof *MerkleProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProof.Contract.MerkleProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProof *MerkleProofCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MerkleProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProof *MerkleProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProof *MerkleProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProof.Contract.contract.Transact(opts, method, params...)
}

// BitSet is a free data retrieval call binding the contract method 0xe3f9c6c4.
//
// Solidity: function bitSet(uint256 self, uint8 index) pure returns(bool)
func (_MerkleProof *MerkleProofCaller) BitSet(opts *bind.CallOpts, self *big.Int, index uint8) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _MerkleProof.contract.Call(opts, out, "bitSet", self, index)
	return *ret0, err
}

// BitSet is a free data retrieval call binding the contract method 0xe3f9c6c4.
//
// Solidity: function bitSet(uint256 self, uint8 index) pure returns(bool)
func (_MerkleProof *MerkleProofSession) BitSet(self *big.Int, index uint8) (bool, error) {
	return _MerkleProof.Contract.BitSet(&_MerkleProof.CallOpts, self, index)
}

// BitSet is a free data retrieval call binding the contract method 0xe3f9c6c4.
//
// Solidity: function bitSet(uint256 self, uint8 index) pure returns(bool)
func (_MerkleProof *MerkleProofCallerSession) BitSet(self *big.Int, index uint8) (bool, error) {
	return _MerkleProof.Contract.BitSet(&_MerkleProof.CallOpts, self, index)
}

// CheckProof is a free data retrieval call binding the contract method 0x60938ac8.
//
// Solidity: function checkProof(bytes proof, bytes32 root, bytes32 hash, uint256 key) pure returns(bool)
func (_MerkleProof *MerkleProofCaller) CheckProof(opts *bind.CallOpts, proof []byte, root [32]byte, hash [32]byte, key *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _MerkleProof.contract.Call(opts, out, "checkProof", proof, root, hash, key)
	return *ret0, err
}

// CheckProof is a free data retrieval call binding the contract method 0x60938ac8.
//
// Solidity: function checkProof(bytes proof, bytes32 root, bytes32 hash, uint256 key) pure returns(bool)
func (_MerkleProof *MerkleProofSession) CheckProof(proof []byte, root [32]byte, hash [32]byte, key *big.Int) (bool, error) {
	return _MerkleProof.Contract.CheckProof(&_MerkleProof.CallOpts, proof, root, hash, key)
}

// CheckProof is a free data retrieval call binding the contract method 0x60938ac8.
//
// Solidity: function checkProof(bytes proof, bytes32 root, bytes32 hash, uint256 key) pure returns(bool)
func (_MerkleProof *MerkleProofCallerSession) CheckProof(proof []byte, root [32]byte, hash [32]byte, key *big.Int) (bool, error) {
	return _MerkleProof.Contract.CheckProof(&_MerkleProof.CallOpts, proof, root, hash, key)
}

// MintableERC20ABI is the input ABI used to generate the binding from.
const MintableERC20ABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// MintableERC20 is an auto generated Go binding around an Ethereum contract.
type MintableERC20 struct {
	MintableERC20Caller     // Read-only binding to the contract
	MintableERC20Transactor // Write-only binding to the contract
	MintableERC20Filterer   // Log filterer for contract events
}

// MintableERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type MintableERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type MintableERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MintableERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MintableERC20Session struct {
	Contract     *MintableERC20    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MintableERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MintableERC20CallerSession struct {
	Contract *MintableERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// MintableERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MintableERC20TransactorSession struct {
	Contract     *MintableERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// MintableERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type MintableERC20Raw struct {
	Contract *MintableERC20 // Generic contract binding to access the raw methods on
}

// MintableERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MintableERC20CallerRaw struct {
	Contract *MintableERC20Caller // Generic read-only contract binding to access the raw methods on
}

// MintableERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MintableERC20TransactorRaw struct {
	Contract *MintableERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewMintableERC20 creates a new instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20(address common.Address, backend bind.ContractBackend) (*MintableERC20, error) {
	contract, err := bindMintableERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MintableERC20{MintableERC20Caller: MintableERC20Caller{contract: contract}, MintableERC20Transactor: MintableERC20Transactor{contract: contract}, MintableERC20Filterer: MintableERC20Filterer{contract: contract}}, nil
}

// NewMintableERC20Caller creates a new read-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Caller(address common.Address, caller bind.ContractCaller) (*MintableERC20Caller, error) {
	contract, err := bindMintableERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Caller{contract: contract}, nil
}

// NewMintableERC20Transactor creates a new write-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*MintableERC20Transactor, error) {
	contract, err := bindMintableERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Transactor{contract: contract}, nil
}

// NewMintableERC20Filterer creates a new log filterer instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*MintableERC20Filterer, error) {
	contract, err := bindMintableERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Filterer{contract: contract}, nil
}

// bindMintableERC20 binds a generic wrapper to an already deployed contract.
func bindMintableERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MintableERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.MintableERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) Allowance(opts *bind.CallOpts, src common.Address, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _MintableERC20.contract.Call(opts, out, "allowance", src, who)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) Allowance(src common.Address, who common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, src, who)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address src, address who) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) Allowance(src common.Address, who common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, src, who)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) BalanceOf(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _MintableERC20.contract.Call(opts, out, "balanceOf", who)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) BalanceOf(who common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, who)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address who) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) BalanceOf(who common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, who)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _MintableERC20.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Session) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Approve(opts *bind.TransactOpts, who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "approve", who, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Session) Approve(who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, who, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address who, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Approve(who common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, who, wad)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_MintableERC20 *MintableERC20Transactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_MintableERC20 *MintableERC20Session) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.GrantOperator(&_MintableERC20.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_MintableERC20 *MintableERC20TransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.GrantOperator(&_MintableERC20.TransactOpts, _operator)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_MintableERC20 *MintableERC20Transactor) Mint(opts *bind.TransactOpts, guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "mint", guy, wad)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_MintableERC20 *MintableERC20Session) Mint(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, guy, wad)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_MintableERC20 *MintableERC20TransactorSession) Mint(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, guy, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Transfer(opts *bind.TransactOpts, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transfer", dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Session) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) TransferFrom(opts *bind.TransactOpts, src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transferFrom", src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20Session) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, src, dst, wad)
}

// QueueLibraryABI is the input ABI used to generate the binding from.
const QueueLibraryABI = "[]"

// QueueLibraryBin is the compiled bytecode used for deploying new contracts.
var QueueLibraryBin = "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201b6ff3f539195f98f06e09aff271b9937d829d56fd1f042ca627b7e3f1901edc64736f6c63430006070033"

// DeployQueueLibrary deploys a new Ethereum contract, binding an instance of QueueLibrary to it.
func DeployQueueLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *QueueLibrary, error) {
	parsed, err := abi.JSON(strings.NewReader(QueueLibraryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(QueueLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &QueueLibrary{QueueLibraryCaller: QueueLibraryCaller{contract: contract}, QueueLibraryTransactor: QueueLibraryTransactor{contract: contract}, QueueLibraryFilterer: QueueLibraryFilterer{contract: contract}}, nil
}

// QueueLibrary is an auto generated Go binding around an Ethereum contract.
type QueueLibrary struct {
	QueueLibraryCaller     // Read-only binding to the contract
	QueueLibraryTransactor // Write-only binding to the contract
	QueueLibraryFilterer   // Log filterer for contract events
}

// QueueLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type QueueLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// QueueLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type QueueLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// QueueLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type QueueLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// QueueLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type QueueLibrarySession struct {
	Contract     *QueueLibrary     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// QueueLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type QueueLibraryCallerSession struct {
	Contract *QueueLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// QueueLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type QueueLibraryTransactorSession struct {
	Contract     *QueueLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// QueueLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type QueueLibraryRaw struct {
	Contract *QueueLibrary // Generic contract binding to access the raw methods on
}

// QueueLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type QueueLibraryCallerRaw struct {
	Contract *QueueLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// QueueLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type QueueLibraryTransactorRaw struct {
	Contract *QueueLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewQueueLibrary creates a new instance of QueueLibrary, bound to a specific deployed contract.
func NewQueueLibrary(address common.Address, backend bind.ContractBackend) (*QueueLibrary, error) {
	contract, err := bindQueueLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &QueueLibrary{QueueLibraryCaller: QueueLibraryCaller{contract: contract}, QueueLibraryTransactor: QueueLibraryTransactor{contract: contract}, QueueLibraryFilterer: QueueLibraryFilterer{contract: contract}}, nil
}

// NewQueueLibraryCaller creates a new read-only instance of QueueLibrary, bound to a specific deployed contract.
func NewQueueLibraryCaller(address common.Address, caller bind.ContractCaller) (*QueueLibraryCaller, error) {
	contract, err := bindQueueLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &QueueLibraryCaller{contract: contract}, nil
}

// NewQueueLibraryTransactor creates a new write-only instance of QueueLibrary, bound to a specific deployed contract.
func NewQueueLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*QueueLibraryTransactor, error) {
	contract, err := bindQueueLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &QueueLibraryTransactor{contract: contract}, nil
}

// NewQueueLibraryFilterer creates a new log filterer instance of QueueLibrary, bound to a specific deployed contract.
func NewQueueLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*QueueLibraryFilterer, error) {
	contract, err := bindQueueLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &QueueLibraryFilterer{contract: contract}, nil
}

// bindQueueLibrary binds a generic wrapper to an already deployed contract.
func bindQueueLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(QueueLibraryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_QueueLibrary *QueueLibraryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _QueueLibrary.Contract.QueueLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_QueueLibrary *QueueLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _QueueLibrary.Contract.QueueLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_QueueLibrary *QueueLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _QueueLibrary.Contract.QueueLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_QueueLibrary *QueueLibraryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _QueueLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_QueueLibrary *QueueLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _QueueLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_QueueLibrary *QueueLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _QueueLibrary.Contract.contract.Transact(opts, method, params...)
}

// RegistryABI is the input ABI used to generate the binding from.
const RegistryABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"lookup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// RegistryBin is the compiled bytecode used for deploying new contracts.
var RegistryBin = "0x608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610cc46031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610ad5806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80631e59c5291461005c57806380599e4b14610137578063e348da13146101f2578063f67187ac14610236578063fad8b32a14610331575b600080fd5b6101356004803603604081101561007257600080fd5b810190808035906020019064010000000081111561008f57600080fd5b8201836020820111156100a157600080fd5b803590602001918460018302840111640100000000831117156100c357600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610375565b005b6101f06004803603602081101561014d57600080fd5b810190808035906020019064010000000081111561016a57600080fd5b82018360208201111561017c57600080fd5b8035906020019184600183028401116401000000008311171561019e57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929050505061051a565b005b6102346004803603602081101561020857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506106a2565b005b6102ef6004803603602081101561024c57600080fd5b810190808035906020019064010000000081111561026957600080fd5b82018360208201111561027b57600080fd5b8035906020019184600183028401116401000000008311171561029d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050610807565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6103736004803603602081101561034757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061089a565b005b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061041957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61046e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b806003836040518082805190602001908083835b602083106104a55780518252602082019150602081019050602083039250610482565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806105be57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610613576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b6003816040518082805190602001908083835b602083106106495780518252602082019150602081019050602083039250610626565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905550565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061074657506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61079b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b60006003826040518082805190602001908083835b6020831061083f578051825260208201915060208101905060208303925061081c565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061093e57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610993576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b6001805411610a0a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220be763e61fb8fcfccd2e45ce2eac7d233032af16f418b1b3539134a1d9af9f37164736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployRegistry deploys a new Ethereum contract, binding an instance of Registry to it.
func DeployRegistry(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Registry, error) {
	parsed, err := abi.JSON(strings.NewReader(RegistryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RegistryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Registry{RegistryCaller: RegistryCaller{contract: contract}, RegistryTransactor: RegistryTransactor{contract: contract}, RegistryFilterer: RegistryFilterer{contract: contract}}, nil
}

// Registry is an auto generated Go binding around an Ethereum contract.
type Registry struct {
	RegistryCaller     // Read-only binding to the contract
	RegistryTransactor // Write-only binding to the contract
	RegistryFilterer   // Log filterer for contract events
}

// RegistryCaller is an auto generated read-only Go binding around an Ethereum contract.
type RegistryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RegistryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RegistryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistrySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RegistrySession struct {
	Contract     *Registry         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RegistryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RegistryCallerSession struct {
	Contract *RegistryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// RegistryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RegistryTransactorSession struct {
	Contract     *RegistryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// RegistryRaw is an auto generated low-level Go binding around an Ethereum contract.
type RegistryRaw struct {
	Contract *Registry // Generic contract binding to access the raw methods on
}

// RegistryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RegistryCallerRaw struct {
	Contract *RegistryCaller // Generic read-only contract binding to access the raw methods on
}

// RegistryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RegistryTransactorRaw struct {
	Contract *RegistryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRegistry creates a new instance of Registry, bound to a specific deployed contract.
func NewRegistry(address common.Address, backend bind.ContractBackend) (*Registry, error) {
	contract, err := bindRegistry(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Registry{RegistryCaller: RegistryCaller{contract: contract}, RegistryTransactor: RegistryTransactor{contract: contract}, RegistryFilterer: RegistryFilterer{contract: contract}}, nil
}

// NewRegistryCaller creates a new read-only instance of Registry, bound to a specific deployed contract.
func NewRegistryCaller(address common.Address, caller bind.ContractCaller) (*RegistryCaller, error) {
	contract, err := bindRegistry(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryCaller{contract: contract}, nil
}

// NewRegistryTransactor creates a new write-only instance of Registry, bound to a specific deployed contract.
func NewRegistryTransactor(address common.Address, transactor bind.ContractTransactor) (*RegistryTransactor, error) {
	contract, err := bindRegistry(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryTransactor{contract: contract}, nil
}

// NewRegistryFilterer creates a new log filterer instance of Registry, bound to a specific deployed contract.
func NewRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*RegistryFilterer, error) {
	contract, err := bindRegistry(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RegistryFilterer{contract: contract}, nil
}

// bindRegistry binds a generic wrapper to an already deployed contract.
func bindRegistry(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RegistryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Registry *RegistryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Registry.Contract.RegistryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Registry *RegistryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Registry.Contract.RegistryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Registry *RegistryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Registry.Contract.RegistryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Registry *RegistryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Registry.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Registry *RegistryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Registry.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Registry *RegistryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Registry.Contract.contract.Transact(opts, method, params...)
}

// Lookup is a free data retrieval call binding the contract method 0xf67187ac.
//
// Solidity: function lookup(string name) view returns(address)
func (_Registry *RegistryCaller) Lookup(opts *bind.CallOpts, name string) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Registry.contract.Call(opts, out, "lookup", name)
	return *ret0, err
}

// Lookup is a free data retrieval call binding the contract method 0xf67187ac.
//
// Solidity: function lookup(string name) view returns(address)
func (_Registry *RegistrySession) Lookup(name string) (common.Address, error) {
	return _Registry.Contract.Lookup(&_Registry.CallOpts, name)
}

// Lookup is a free data retrieval call binding the contract method 0xf67187ac.
//
// Solidity: function lookup(string name) view returns(address)
func (_Registry *RegistryCallerSession) Lookup(name string) (common.Address, error) {
	return _Registry.Contract.Lookup(&_Registry.CallOpts, name)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Registry *RegistryTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Registry.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Registry *RegistrySession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Registry.Contract.GrantOperator(&_Registry.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Registry *RegistryTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Registry.Contract.GrantOperator(&_Registry.TransactOpts, _operator)
}

// Register is a paid mutator transaction binding the contract method 0x1e59c529.
//
// Solidity: function register(string name, address dst) returns()
func (_Registry *RegistryTransactor) Register(opts *bind.TransactOpts, name string, dst common.Address) (*types.Transaction, error) {
	return _Registry.contract.Transact(opts, "register", name, dst)
}

// Register is a paid mutator transaction binding the contract method 0x1e59c529.
//
// Solidity: function register(string name, address dst) returns()
func (_Registry *RegistrySession) Register(name string, dst common.Address) (*types.Transaction, error) {
	return _Registry.Contract.Register(&_Registry.TransactOpts, name, dst)
}

// Register is a paid mutator transaction binding the contract method 0x1e59c529.
//
// Solidity: function register(string name, address dst) returns()
func (_Registry *RegistryTransactorSession) Register(name string, dst common.Address) (*types.Transaction, error) {
	return _Registry.Contract.Register(&_Registry.TransactOpts, name, dst)
}

// Remove is a paid mutator transaction binding the contract method 0x80599e4b.
//
// Solidity: function remove(string name) returns()
func (_Registry *RegistryTransactor) Remove(opts *bind.TransactOpts, name string) (*types.Transaction, error) {
	return _Registry.contract.Transact(opts, "remove", name)
}

// Remove is a paid mutator transaction binding the contract method 0x80599e4b.
//
// Solidity: function remove(string name) returns()
func (_Registry *RegistrySession) Remove(name string) (*types.Transaction, error) {
	return _Registry.Contract.Remove(&_Registry.TransactOpts, name)
}

// Remove is a paid mutator transaction binding the contract method 0x80599e4b.
//
// Solidity: function remove(string name) returns()
func (_Registry *RegistryTransactorSession) Remove(name string) (*types.Transaction, error) {
	return _Registry.Contract.Remove(&_Registry.TransactOpts, name)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Registry *RegistryTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Registry.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Registry *RegistrySession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Registry.Contract.RevokeOperator(&_Registry.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Registry *RegistryTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Registry.Contract.RevokeOperator(&_Registry.TransactOpts, _operator)
}

// RegistryClientABI is the input ABI used to generate the binding from.
const RegistryClientABI = "[{\"inputs\":[],\"name\":\"reloadRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// RegistryClient is an auto generated Go binding around an Ethereum contract.
type RegistryClient struct {
	RegistryClientCaller     // Read-only binding to the contract
	RegistryClientTransactor // Write-only binding to the contract
	RegistryClientFilterer   // Log filterer for contract events
}

// RegistryClientCaller is an auto generated read-only Go binding around an Ethereum contract.
type RegistryClientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryClientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RegistryClientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryClientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RegistryClientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryClientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RegistryClientSession struct {
	Contract     *RegistryClient   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RegistryClientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RegistryClientCallerSession struct {
	Contract *RegistryClientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// RegistryClientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RegistryClientTransactorSession struct {
	Contract     *RegistryClientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// RegistryClientRaw is an auto generated low-level Go binding around an Ethereum contract.
type RegistryClientRaw struct {
	Contract *RegistryClient // Generic contract binding to access the raw methods on
}

// RegistryClientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RegistryClientCallerRaw struct {
	Contract *RegistryClientCaller // Generic read-only contract binding to access the raw methods on
}

// RegistryClientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RegistryClientTransactorRaw struct {
	Contract *RegistryClientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRegistryClient creates a new instance of RegistryClient, bound to a specific deployed contract.
func NewRegistryClient(address common.Address, backend bind.ContractBackend) (*RegistryClient, error) {
	contract, err := bindRegistryClient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RegistryClient{RegistryClientCaller: RegistryClientCaller{contract: contract}, RegistryClientTransactor: RegistryClientTransactor{contract: contract}, RegistryClientFilterer: RegistryClientFilterer{contract: contract}}, nil
}

// NewRegistryClientCaller creates a new read-only instance of RegistryClient, bound to a specific deployed contract.
func NewRegistryClientCaller(address common.Address, caller bind.ContractCaller) (*RegistryClientCaller, error) {
	contract, err := bindRegistryClient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryClientCaller{contract: contract}, nil
}

// NewRegistryClientTransactor creates a new write-only instance of RegistryClient, bound to a specific deployed contract.
func NewRegistryClientTransactor(address common.Address, transactor bind.ContractTransactor) (*RegistryClientTransactor, error) {
	contract, err := bindRegistryClient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryClientTransactor{contract: contract}, nil
}

// NewRegistryClientFilterer creates a new log filterer instance of RegistryClient, bound to a specific deployed contract.
func NewRegistryClientFilterer(address common.Address, filterer bind.ContractFilterer) (*RegistryClientFilterer, error) {
	contract, err := bindRegistryClient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RegistryClientFilterer{contract: contract}, nil
}

// bindRegistryClient binds a generic wrapper to an already deployed contract.
func bindRegistryClient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RegistryClientABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RegistryClient *RegistryClientRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RegistryClient.Contract.RegistryClientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RegistryClient *RegistryClientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryClient.Contract.RegistryClientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RegistryClient *RegistryClientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RegistryClient.Contract.RegistryClientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RegistryClient *RegistryClientCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RegistryClient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RegistryClient *RegistryClientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryClient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RegistryClient *RegistryClientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RegistryClient.Contract.contract.Transact(opts, method, params...)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_RegistryClient *RegistryClientTransactor) ReloadRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryClient.contract.Transact(opts, "reloadRegistry")
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_RegistryClient *RegistryClientSession) ReloadRegistry() (*types.Transaction, error) {
	return _RegistryClient.Contract.ReloadRegistry(&_RegistryClient.TransactOpts)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_RegistryClient *RegistryClientTransactorSession) ReloadRegistry() (*types.Transaction, error) {
	return _RegistryClient.Contract.ReloadRegistry(&_RegistryClient.TransactOpts)
}

// RegistryTestABI is the input ABI used to generate the binding from.
const RegistryTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// RegistryTestBin is the compiled bytecode used for deploying new contracts.
var RegistryTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b506119a48061003a6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80630a38e0041461005c5780630a9254e41461006657806339cfea4a14610070578063ba414fa61461007a578063fa7626d41461009c575b600080fd5b6100646100be565b005b61006e610478565b005b6100786104e3565b005b610082610a42565b604051808215151515815260200191505060405180910390f35b6100a4610a55565b604051808215151515815260200191505060405180910390f35b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631e59c52960016040518263ffffffff1660e01b815260040180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825260038152602001807f6f6e65000000000000000000000000000000000000000000000000000000000081525060200192505050600060405180830381600087803b15801561019957600080fd5b505af11580156101ad573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631e59c52960026040518263ffffffff1660e01b815260040180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825260038152602001807f74776f000000000000000000000000000000000000000000000000000000000081525060200192505050600060405180830381600087803b15801561028c57600080fd5b505af11580156102a0573d6000803e3d6000fd5b5050505061038d6001600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518163ffffffff1660e01b81526004018080602001828103825260038152602001807f6f6e65000000000000000000000000000000000000000000000000000000000081525060200191505060206040518083038186803b15801561034d57600080fd5b505afa158015610361573d6000803e3d6000fd5b505050506040513d602081101561037757600080fd5b8101908080519060200190929190505050610a67565b6104766002600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518163ffffffff1660e01b81526004018080602001828103825260038152602001807f74776f000000000000000000000000000000000000000000000000000000000081525060200191505060206040518083038186803b15801561043657600080fd5b505afa15801561044a573d6000803e3d6000fd5b505050506040513d602081101561046057600080fd5b8101908080519060200190929190505050610a67565b565b60405161048490610c47565b604051809103906000f0801580156104a0573d6000803e3d6000fd5b50600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631e59c52960016040518263ffffffff1660e01b815260040180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825260038152602001807f6f6e65000000000000000000000000000000000000000000000000000000000081525060200192505050600060405180830381600087803b1580156105be57600080fd5b505af11580156105d2573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631e59c52960026040518263ffffffff1660e01b815260040180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825260038152602001807f74776f000000000000000000000000000000000000000000000000000000000081525060200192505050600060405180830381600087803b1580156106b157600080fd5b505af11580156106c5573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166380599e4b6040518163ffffffff1660e01b81526004018080602001828103825260038152602001807f74776f0000000000000000000000000000000000000000000000000000000000815250602001915050600060405180830381600087803b15801561076f57600080fd5b505af1158015610783573d6000803e3d6000fd5b505050506108706001600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518163ffffffff1660e01b81526004018080602001828103825260038152602001807f6f6e65000000000000000000000000000000000000000000000000000000000081525060200191505060206040518083038186803b15801561083057600080fd5b505afa158015610844573d6000803e3d6000fd5b505050506040513d602081101561085a57600080fd5b8101908080519060200190929190505050610a67565b61095860008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518163ffffffff1660e01b81526004018080602001828103825260038152602001807f74776f000000000000000000000000000000000000000000000000000000000081525060200191505060206040518083038186803b15801561091857600080fd5b505afa15801561092c573d6000803e3d6000fd5b505050506040513d602081101561094257600080fd5b8101908080519060200190929190505050610a67565b610a4060008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518163ffffffff1660e01b81526004018080602001828103825260058152602001807f746872656500000000000000000000000000000000000000000000000000000081525060200191505060206040518083038186803b158015610a0057600080fd5b505afa158015610a14573d6000803e3d6000fd5b505050506040513d6020811015610a2a57600080fd5b8101908080519060200190929190505050610a67565b565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614610c26577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405180806020018281038252602581526020018061194a6025913960400191505060405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f8160405180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281038252600a8152602001807f20204578706563746564000000000000000000000000000000000000000000008152506020019250505060405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f8260405180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281038252600a8152602001807f2020202041637475616c000000000000000000000000000000000000000000008152506020019250505060405180910390a1610c25610c2a565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b610cf580610c558339019056fe608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610cc46031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610ad5806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80631e59c5291461005c57806380599e4b14610137578063e348da13146101f2578063f67187ac14610236578063fad8b32a14610331575b600080fd5b6101356004803603604081101561007257600080fd5b810190808035906020019064010000000081111561008f57600080fd5b8201836020820111156100a157600080fd5b803590602001918460018302840111640100000000831117156100c357600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610375565b005b6101f06004803603602081101561014d57600080fd5b810190808035906020019064010000000081111561016a57600080fd5b82018360208201111561017c57600080fd5b8035906020019184600183028401116401000000008311171561019e57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929050505061051a565b005b6102346004803603602081101561020857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506106a2565b005b6102ef6004803603602081101561024c57600080fd5b810190808035906020019064010000000081111561026957600080fd5b82018360208201111561027b57600080fd5b8035906020019184600183028401116401000000008311171561029d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050610807565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6103736004803603602081101561034757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061089a565b005b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061041957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61046e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b806003836040518082805190602001908083835b602083106104a55780518252602082019150602081019050602083039250610482565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806105be57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610613576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b6003816040518082805190602001908083835b602083106106495780518252602082019150602081019050602083039250610626565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905550565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061074657506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61079b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b60006003826040518082805190602001908083835b6020831061083f578051825260208201915060208101905060208303925061081c565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061093e57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610993576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180610a6f6031913960400191505060405180910390fd5b6001805411610a0a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220be763e61fb8fcfccd2e45ce2eac7d233032af16f418b1b3539134a1d9af9f37164736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e4572726f723a2061203d3d2062206e6f7420736174697366696564205b616464726573735da264697066735822122012938f3fb962c6dc1c2399fb6654cda1490a8981af4e8b1d6243c8ae4ccafd3064736f6c63430006070033"

// DeployRegistryTest deploys a new Ethereum contract, binding an instance of RegistryTest to it.
func DeployRegistryTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RegistryTest, error) {
	parsed, err := abi.JSON(strings.NewReader(RegistryTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RegistryTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RegistryTest{RegistryTestCaller: RegistryTestCaller{contract: contract}, RegistryTestTransactor: RegistryTestTransactor{contract: contract}, RegistryTestFilterer: RegistryTestFilterer{contract: contract}}, nil
}

// RegistryTest is an auto generated Go binding around an Ethereum contract.
type RegistryTest struct {
	RegistryTestCaller     // Read-only binding to the contract
	RegistryTestTransactor // Write-only binding to the contract
	RegistryTestFilterer   // Log filterer for contract events
}

// RegistryTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type RegistryTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RegistryTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RegistryTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RegistryTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RegistryTestSession struct {
	Contract     *RegistryTest     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RegistryTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RegistryTestCallerSession struct {
	Contract *RegistryTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// RegistryTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RegistryTestTransactorSession struct {
	Contract     *RegistryTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// RegistryTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type RegistryTestRaw struct {
	Contract *RegistryTest // Generic contract binding to access the raw methods on
}

// RegistryTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RegistryTestCallerRaw struct {
	Contract *RegistryTestCaller // Generic read-only contract binding to access the raw methods on
}

// RegistryTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RegistryTestTransactorRaw struct {
	Contract *RegistryTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRegistryTest creates a new instance of RegistryTest, bound to a specific deployed contract.
func NewRegistryTest(address common.Address, backend bind.ContractBackend) (*RegistryTest, error) {
	contract, err := bindRegistryTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RegistryTest{RegistryTestCaller: RegistryTestCaller{contract: contract}, RegistryTestTransactor: RegistryTestTransactor{contract: contract}, RegistryTestFilterer: RegistryTestFilterer{contract: contract}}, nil
}

// NewRegistryTestCaller creates a new read-only instance of RegistryTest, bound to a specific deployed contract.
func NewRegistryTestCaller(address common.Address, caller bind.ContractCaller) (*RegistryTestCaller, error) {
	contract, err := bindRegistryTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryTestCaller{contract: contract}, nil
}

// NewRegistryTestTransactor creates a new write-only instance of RegistryTest, bound to a specific deployed contract.
func NewRegistryTestTransactor(address common.Address, transactor bind.ContractTransactor) (*RegistryTestTransactor, error) {
	contract, err := bindRegistryTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RegistryTestTransactor{contract: contract}, nil
}

// NewRegistryTestFilterer creates a new log filterer instance of RegistryTest, bound to a specific deployed contract.
func NewRegistryTestFilterer(address common.Address, filterer bind.ContractFilterer) (*RegistryTestFilterer, error) {
	contract, err := bindRegistryTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RegistryTestFilterer{contract: contract}, nil
}

// bindRegistryTest binds a generic wrapper to an already deployed contract.
func bindRegistryTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RegistryTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RegistryTest *RegistryTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RegistryTest.Contract.RegistryTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RegistryTest *RegistryTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryTest.Contract.RegistryTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RegistryTest *RegistryTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RegistryTest.Contract.RegistryTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RegistryTest *RegistryTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RegistryTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RegistryTest *RegistryTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RegistryTest *RegistryTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RegistryTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_RegistryTest *RegistryTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _RegistryTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_RegistryTest *RegistryTestSession) ISTEST() (bool, error) {
	return _RegistryTest.Contract.ISTEST(&_RegistryTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_RegistryTest *RegistryTestCallerSession) ISTEST() (bool, error) {
	return _RegistryTest.Contract.ISTEST(&_RegistryTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_RegistryTest *RegistryTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _RegistryTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_RegistryTest *RegistryTestSession) Failed() (bool, error) {
	return _RegistryTest.Contract.Failed(&_RegistryTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_RegistryTest *RegistryTestCallerSession) Failed() (bool, error) {
	return _RegistryTest.Contract.Failed(&_RegistryTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_RegistryTest *RegistryTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_RegistryTest *RegistryTestSession) SetUp() (*types.Transaction, error) {
	return _RegistryTest.Contract.SetUp(&_RegistryTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_RegistryTest *RegistryTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _RegistryTest.Contract.SetUp(&_RegistryTest.TransactOpts)
}

// TestRegister is a paid mutator transaction binding the contract method 0x0a38e004.
//
// Solidity: function testRegister() returns()
func (_RegistryTest *RegistryTestTransactor) TestRegister(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryTest.contract.Transact(opts, "testRegister")
}

// TestRegister is a paid mutator transaction binding the contract method 0x0a38e004.
//
// Solidity: function testRegister() returns()
func (_RegistryTest *RegistryTestSession) TestRegister() (*types.Transaction, error) {
	return _RegistryTest.Contract.TestRegister(&_RegistryTest.TransactOpts)
}

// TestRegister is a paid mutator transaction binding the contract method 0x0a38e004.
//
// Solidity: function testRegister() returns()
func (_RegistryTest *RegistryTestTransactorSession) TestRegister() (*types.Transaction, error) {
	return _RegistryTest.Contract.TestRegister(&_RegistryTest.TransactOpts)
}

// TestRemove is a paid mutator transaction binding the contract method 0x39cfea4a.
//
// Solidity: function testRemove() returns()
func (_RegistryTest *RegistryTestTransactor) TestRemove(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RegistryTest.contract.Transact(opts, "testRemove")
}

// TestRemove is a paid mutator transaction binding the contract method 0x39cfea4a.
//
// Solidity: function testRemove() returns()
func (_RegistryTest *RegistryTestSession) TestRemove() (*types.Transaction, error) {
	return _RegistryTest.Contract.TestRemove(&_RegistryTest.TransactOpts)
}

// TestRemove is a paid mutator transaction binding the contract method 0x39cfea4a.
//
// Solidity: function testRemove() returns()
func (_RegistryTest *RegistryTestTransactorSession) TestRemove() (*types.Transaction, error) {
	return _RegistryTest.Contract.TestRemove(&_RegistryTest.TransactOpts)
}

// RegistryTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the RegistryTest contract.
type RegistryTestLogIterator struct {
	Event *RegistryTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLog represents a Log event raised by the RegistryTest contract.
type RegistryTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLog(opts *bind.FilterOpts) (*RegistryTestLogIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogIterator{contract: _RegistryTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *RegistryTestLog) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLog)
				if err := _RegistryTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLog(log types.Log) (*RegistryTestLog, error) {
	event := new(RegistryTestLog)
	if err := _RegistryTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the RegistryTest contract.
type RegistryTestLogAddressIterator struct {
	Event *RegistryTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogAddress represents a LogAddress event raised by the RegistryTest contract.
type RegistryTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*RegistryTestLogAddressIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogAddressIterator{contract: _RegistryTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *RegistryTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogAddress)
				if err := _RegistryTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogAddress(log types.Log) (*RegistryTestLogAddress, error) {
	event := new(RegistryTestLogAddress)
	if err := _RegistryTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the RegistryTest contract.
type RegistryTestLogBytesIterator struct {
	Event *RegistryTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogBytes represents a LogBytes event raised by the RegistryTest contract.
type RegistryTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*RegistryTestLogBytesIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogBytesIterator{contract: _RegistryTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *RegistryTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogBytes)
				if err := _RegistryTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogBytes(log types.Log) (*RegistryTestLogBytes, error) {
	event := new(RegistryTestLogBytes)
	if err := _RegistryTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the RegistryTest contract.
type RegistryTestLogBytes32Iterator struct {
	Event *RegistryTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogBytes32 represents a LogBytes32 event raised by the RegistryTest contract.
type RegistryTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*RegistryTestLogBytes32Iterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogBytes32Iterator{contract: _RegistryTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *RegistryTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogBytes32)
				if err := _RegistryTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogBytes32(log types.Log) (*RegistryTestLogBytes32, error) {
	event := new(RegistryTestLogBytes32)
	if err := _RegistryTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the RegistryTest contract.
type RegistryTestLogIntIterator struct {
	Event *RegistryTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogInt represents a LogInt event raised by the RegistryTest contract.
type RegistryTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*RegistryTestLogIntIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogIntIterator{contract: _RegistryTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *RegistryTestLogInt) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogInt)
				if err := _RegistryTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogInt(log types.Log) (*RegistryTestLogInt, error) {
	event := new(RegistryTestLogInt)
	if err := _RegistryTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the RegistryTest contract.
type RegistryTestLogNamedAddressIterator struct {
	Event *RegistryTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedAddress represents a LogNamedAddress event raised by the RegistryTest contract.
type RegistryTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*RegistryTestLogNamedAddressIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedAddressIterator{contract: _RegistryTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedAddress)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedAddress(log types.Log) (*RegistryTestLogNamedAddress, error) {
	event := new(RegistryTestLogNamedAddress)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the RegistryTest contract.
type RegistryTestLogNamedBytesIterator struct {
	Event *RegistryTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedBytes represents a LogNamedBytes event raised by the RegistryTest contract.
type RegistryTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*RegistryTestLogNamedBytesIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedBytesIterator{contract: _RegistryTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedBytes)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedBytes(log types.Log) (*RegistryTestLogNamedBytes, error) {
	event := new(RegistryTestLogNamedBytes)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the RegistryTest contract.
type RegistryTestLogNamedBytes32Iterator struct {
	Event *RegistryTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the RegistryTest contract.
type RegistryTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*RegistryTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedBytes32Iterator{contract: _RegistryTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedBytes32)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedBytes32(log types.Log) (*RegistryTestLogNamedBytes32, error) {
	event := new(RegistryTestLogNamedBytes32)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the RegistryTest contract.
type RegistryTestLogNamedDecimalIntIterator struct {
	Event *RegistryTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the RegistryTest contract.
type RegistryTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*RegistryTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedDecimalIntIterator{contract: _RegistryTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedDecimalInt)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*RegistryTestLogNamedDecimalInt, error) {
	event := new(RegistryTestLogNamedDecimalInt)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the RegistryTest contract.
type RegistryTestLogNamedDecimalUintIterator struct {
	Event *RegistryTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the RegistryTest contract.
type RegistryTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*RegistryTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedDecimalUintIterator{contract: _RegistryTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedDecimalUint)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*RegistryTestLogNamedDecimalUint, error) {
	event := new(RegistryTestLogNamedDecimalUint)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the RegistryTest contract.
type RegistryTestLogNamedIntIterator struct {
	Event *RegistryTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedInt represents a LogNamedInt event raised by the RegistryTest contract.
type RegistryTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*RegistryTestLogNamedIntIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedIntIterator{contract: _RegistryTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedInt)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedInt(log types.Log) (*RegistryTestLogNamedInt, error) {
	event := new(RegistryTestLogNamedInt)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the RegistryTest contract.
type RegistryTestLogNamedStringIterator struct {
	Event *RegistryTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedString represents a LogNamedString event raised by the RegistryTest contract.
type RegistryTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*RegistryTestLogNamedStringIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedStringIterator{contract: _RegistryTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedString)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedString(log types.Log) (*RegistryTestLogNamedString, error) {
	event := new(RegistryTestLogNamedString)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the RegistryTest contract.
type RegistryTestLogNamedUintIterator struct {
	Event *RegistryTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogNamedUint represents a LogNamedUint event raised by the RegistryTest contract.
type RegistryTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_RegistryTest *RegistryTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*RegistryTestLogNamedUintIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogNamedUintIterator{contract: _RegistryTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_RegistryTest *RegistryTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *RegistryTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogNamedUint)
				if err := _RegistryTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_RegistryTest *RegistryTestFilterer) ParseLogNamedUint(log types.Log) (*RegistryTestLogNamedUint, error) {
	event := new(RegistryTestLogNamedUint)
	if err := _RegistryTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the RegistryTest contract.
type RegistryTestLogStringIterator struct {
	Event *RegistryTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogString represents a LogString event raised by the RegistryTest contract.
type RegistryTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogString(opts *bind.FilterOpts) (*RegistryTestLogStringIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogStringIterator{contract: _RegistryTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *RegistryTestLogString) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogString)
				if err := _RegistryTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogString(log types.Log) (*RegistryTestLogString, error) {
	event := new(RegistryTestLogString)
	if err := _RegistryTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the RegistryTest contract.
type RegistryTestLogUintIterator struct {
	Event *RegistryTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogUint represents a LogUint event raised by the RegistryTest contract.
type RegistryTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*RegistryTestLogUintIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogUintIterator{contract: _RegistryTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *RegistryTestLogUint) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogUint)
				if err := _RegistryTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogUint(log types.Log) (*RegistryTestLogUint, error) {
	event := new(RegistryTestLogUint)
	if err := _RegistryTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// RegistryTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the RegistryTest contract.
type RegistryTestLogsIterator struct {
	Event *RegistryTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RegistryTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RegistryTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RegistryTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RegistryTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RegistryTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RegistryTestLogs represents a Logs event raised by the RegistryTest contract.
type RegistryTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) FilterLogs(opts *bind.FilterOpts) (*RegistryTestLogsIterator, error) {

	logs, sub, err := _RegistryTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &RegistryTestLogsIterator{contract: _RegistryTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *RegistryTestLogs) (event.Subscription, error) {

	logs, sub, err := _RegistryTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RegistryTestLogs)
				if err := _RegistryTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_RegistryTest *RegistryTestFilterer) ParseLogs(log types.Log) (*RegistryTestLogs, error) {
	event := new(RegistryTestLogs)
	if err := _RegistryTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
var SafeMathBin = "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f4e50b6f15dc11a2a8b725daea8ce6d09f0931ec87dbb805f62d0737e85b6ec364736f6c63430006070033"

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}

// SignatureLibraryABI is the input ABI used to generate the binding from.
const SignatureLibraryABI = "[]"

// SignatureLibraryBin is the compiled bytecode used for deploying new contracts.
var SignatureLibraryBin = "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122044c44b27385c1b17f75c171d463e925bd5f1f84478aa5320d84a6937610149ff64736f6c63430006070033"

// DeploySignatureLibrary deploys a new Ethereum contract, binding an instance of SignatureLibrary to it.
func DeploySignatureLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SignatureLibrary, error) {
	parsed, err := abi.JSON(strings.NewReader(SignatureLibraryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SignatureLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SignatureLibrary{SignatureLibraryCaller: SignatureLibraryCaller{contract: contract}, SignatureLibraryTransactor: SignatureLibraryTransactor{contract: contract}, SignatureLibraryFilterer: SignatureLibraryFilterer{contract: contract}}, nil
}

// SignatureLibrary is an auto generated Go binding around an Ethereum contract.
type SignatureLibrary struct {
	SignatureLibraryCaller     // Read-only binding to the contract
	SignatureLibraryTransactor // Write-only binding to the contract
	SignatureLibraryFilterer   // Log filterer for contract events
}

// SignatureLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type SignatureLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignatureLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SignatureLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignatureLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SignatureLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SignatureLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SignatureLibrarySession struct {
	Contract     *SignatureLibrary // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SignatureLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SignatureLibraryCallerSession struct {
	Contract *SignatureLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// SignatureLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SignatureLibraryTransactorSession struct {
	Contract     *SignatureLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// SignatureLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type SignatureLibraryRaw struct {
	Contract *SignatureLibrary // Generic contract binding to access the raw methods on
}

// SignatureLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SignatureLibraryCallerRaw struct {
	Contract *SignatureLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// SignatureLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SignatureLibraryTransactorRaw struct {
	Contract *SignatureLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSignatureLibrary creates a new instance of SignatureLibrary, bound to a specific deployed contract.
func NewSignatureLibrary(address common.Address, backend bind.ContractBackend) (*SignatureLibrary, error) {
	contract, err := bindSignatureLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SignatureLibrary{SignatureLibraryCaller: SignatureLibraryCaller{contract: contract}, SignatureLibraryTransactor: SignatureLibraryTransactor{contract: contract}, SignatureLibraryFilterer: SignatureLibraryFilterer{contract: contract}}, nil
}

// NewSignatureLibraryCaller creates a new read-only instance of SignatureLibrary, bound to a specific deployed contract.
func NewSignatureLibraryCaller(address common.Address, caller bind.ContractCaller) (*SignatureLibraryCaller, error) {
	contract, err := bindSignatureLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SignatureLibraryCaller{contract: contract}, nil
}

// NewSignatureLibraryTransactor creates a new write-only instance of SignatureLibrary, bound to a specific deployed contract.
func NewSignatureLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*SignatureLibraryTransactor, error) {
	contract, err := bindSignatureLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SignatureLibraryTransactor{contract: contract}, nil
}

// NewSignatureLibraryFilterer creates a new log filterer instance of SignatureLibrary, bound to a specific deployed contract.
func NewSignatureLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*SignatureLibraryFilterer, error) {
	contract, err := bindSignatureLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SignatureLibraryFilterer{contract: contract}, nil
}

// bindSignatureLibrary binds a generic wrapper to an already deployed contract.
func bindSignatureLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SignatureLibraryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SignatureLibrary *SignatureLibraryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SignatureLibrary.Contract.SignatureLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SignatureLibrary *SignatureLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SignatureLibrary.Contract.SignatureLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SignatureLibrary *SignatureLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SignatureLibrary.Contract.SignatureLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SignatureLibrary *SignatureLibraryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SignatureLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SignatureLibrary *SignatureLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SignatureLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SignatureLibrary *SignatureLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SignatureLibrary.Contract.contract.Transact(opts, method, params...)
}

// SimpleAuthABI is the input ABI used to generate the binding from.
const SimpleAuthABI = "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// SimpleAuthBin is the compiled bytecode used for deploying new contracts.
var SimpleAuthBin = "0x608060405234801561001057600080fd5b5033600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610083600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661008860201b60201c565b6101ed565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061012c57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610181576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018061065f6031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610463806101fc6000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c8063e348da131461003b578063fad8b32a1461007f575b600080fd5b61007d6004803603602081101561005157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506100c3565b005b6100c16004803603602081101561009557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610228565b005b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061016757506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6101bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806103fd6031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806102cc57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610321576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806103fd6031913960400191505060405180910390fd5b6001805411610398576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220a368f6e8b1599f46175ed42ff860b72cf4d5aa7ddd6eda4ff67dc963af6aa52964736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeploySimpleAuth deploys a new Ethereum contract, binding an instance of SimpleAuth to it.
func DeploySimpleAuth(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SimpleAuth, error) {
	parsed, err := abi.JSON(strings.NewReader(SimpleAuthABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SimpleAuthBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SimpleAuth{SimpleAuthCaller: SimpleAuthCaller{contract: contract}, SimpleAuthTransactor: SimpleAuthTransactor{contract: contract}, SimpleAuthFilterer: SimpleAuthFilterer{contract: contract}}, nil
}

// SimpleAuth is an auto generated Go binding around an Ethereum contract.
type SimpleAuth struct {
	SimpleAuthCaller     // Read-only binding to the contract
	SimpleAuthTransactor // Write-only binding to the contract
	SimpleAuthFilterer   // Log filterer for contract events
}

// SimpleAuthCaller is an auto generated read-only Go binding around an Ethereum contract.
type SimpleAuthCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SimpleAuthTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SimpleAuthTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SimpleAuthFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SimpleAuthFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SimpleAuthSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SimpleAuthSession struct {
	Contract     *SimpleAuth       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SimpleAuthCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SimpleAuthCallerSession struct {
	Contract *SimpleAuthCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// SimpleAuthTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SimpleAuthTransactorSession struct {
	Contract     *SimpleAuthTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// SimpleAuthRaw is an auto generated low-level Go binding around an Ethereum contract.
type SimpleAuthRaw struct {
	Contract *SimpleAuth // Generic contract binding to access the raw methods on
}

// SimpleAuthCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SimpleAuthCallerRaw struct {
	Contract *SimpleAuthCaller // Generic read-only contract binding to access the raw methods on
}

// SimpleAuthTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SimpleAuthTransactorRaw struct {
	Contract *SimpleAuthTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSimpleAuth creates a new instance of SimpleAuth, bound to a specific deployed contract.
func NewSimpleAuth(address common.Address, backend bind.ContractBackend) (*SimpleAuth, error) {
	contract, err := bindSimpleAuth(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SimpleAuth{SimpleAuthCaller: SimpleAuthCaller{contract: contract}, SimpleAuthTransactor: SimpleAuthTransactor{contract: contract}, SimpleAuthFilterer: SimpleAuthFilterer{contract: contract}}, nil
}

// NewSimpleAuthCaller creates a new read-only instance of SimpleAuth, bound to a specific deployed contract.
func NewSimpleAuthCaller(address common.Address, caller bind.ContractCaller) (*SimpleAuthCaller, error) {
	contract, err := bindSimpleAuth(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SimpleAuthCaller{contract: contract}, nil
}

// NewSimpleAuthTransactor creates a new write-only instance of SimpleAuth, bound to a specific deployed contract.
func NewSimpleAuthTransactor(address common.Address, transactor bind.ContractTransactor) (*SimpleAuthTransactor, error) {
	contract, err := bindSimpleAuth(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SimpleAuthTransactor{contract: contract}, nil
}

// NewSimpleAuthFilterer creates a new log filterer instance of SimpleAuth, bound to a specific deployed contract.
func NewSimpleAuthFilterer(address common.Address, filterer bind.ContractFilterer) (*SimpleAuthFilterer, error) {
	contract, err := bindSimpleAuth(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SimpleAuthFilterer{contract: contract}, nil
}

// bindSimpleAuth binds a generic wrapper to an already deployed contract.
func bindSimpleAuth(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SimpleAuthABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SimpleAuth *SimpleAuthRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SimpleAuth.Contract.SimpleAuthCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SimpleAuth *SimpleAuthRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SimpleAuth.Contract.SimpleAuthTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SimpleAuth *SimpleAuthRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SimpleAuth.Contract.SimpleAuthTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SimpleAuth *SimpleAuthCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SimpleAuth.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SimpleAuth *SimpleAuthTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SimpleAuth.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SimpleAuth *SimpleAuthTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SimpleAuth.Contract.contract.Transact(opts, method, params...)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.Contract.GrantOperator(&_SimpleAuth.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.Contract.GrantOperator(&_SimpleAuth.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.Contract.RevokeOperator(&_SimpleAuth.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_SimpleAuth *SimpleAuthTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _SimpleAuth.Contract.RevokeOperator(&_SimpleAuth.TransactOpts, _operator)
}

// SnapshotsFacetABI is the input ABI used to generate the binding from.
const SnapshotsFacetABI = "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"src\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"extractUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"src\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"extractUint32\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"val\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signatureGroup\",\"type\":\"bytes\"}],\"name\":\"parseSignatureGroup\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"publicKey\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"signature\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"orig\",\"type\":\"bytes\"}],\"name\":\"reverse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"reversed\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ns\",\"type\":\"uint256\"}],\"name\":\"setNextSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// SnapshotsFacetBin is the compiled bytecode used for deploying new contracts.
var SnapshotsFacetBin = "0x608060405234801561001057600080fd5b50610989806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631c8c8ba4146100675780633df8c1dc146100975780639be2f2df146100b3578063c1312f4d146100e4578063e0cf48f914610114578063ec11c82314610132575b600080fd5b610081600480360381019061007c9190610576565b610162565b60405161008e91906107bf565b60405180910390f35b6100b160048036038101906100ac91906105ca565b6101d3565b005b6100cd60048036038101906100c89190610535565b6101ec565b6040516100db929190610774565b60405180910390f35b6100fe60048036038101906100f99190610576565b6102d5565b60405161010b91906107da565b60405180910390f35b61011c610386565b60405161012991906107bf565b60405180910390f35b61014c60048036038101906101479190610535565b61039e565b604051610159919061079d565b60405180910390f35b600080601f830190505b828111156101a757600882901b84828151811061018557fe5b602001015160f81c60f81b60f81c60ff1617915080806001900391505061016c565b50600881901b8383815181106101b957fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b60006101dd610468565b90508181600101819055505050565b6101f4610488565b6101fc6104aa565b60606102078461039e565b9050610214816000610162565b8260016002811061022157fe5b602002018181525050610235816020610162565b8260006002811061024257fe5b602002018181525050610256816040610162565b8360036004811061026357fe5b602002018181525050610277816060610162565b8360026004811061028457fe5b602002018181525050610298816080610162565b836001600481106102a557fe5b6020020181815250506102b98160a0610162565b836000600481106102c657fe5b60200201818152505050915091565b60008260038301815181106102e657fe5b602001015160f81c60f81b60f81c60ff16905082600283018151811061030857fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082600183018151811061033657fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082828151811061036157fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600080610391610468565b9050806001015491505090565b6060815167ffffffffffffffff811180156103b857600080fd5b506040519080825280601f01601f1916602001820160405280156103eb5781602001600182028036833780820191505090505b50905060008090505b82518110156104625782818151811061040957fe5b602001015160f81c60f81b82600183865103038151811061042657fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506103f4565b50919050565b6000806040516104779061075f565b604051809103902090508091505090565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b600082601f8301126104dd57600080fd5b81356104f06104eb82610822565b6107f5565b9150808252602083016020830185838301111561050c57600080fd5b6105178382846108e9565b50505092915050565b60008135905061052f8161093c565b92915050565b60006020828403121561054757600080fd5b600082013567ffffffffffffffff81111561056157600080fd5b61056d848285016104cc565b91505092915050565b6000806040838503121561058957600080fd5b600083013567ffffffffffffffff8111156105a357600080fd5b6105af858286016104cc565b92505060206105c085828601610520565b9150509250929050565b6000602082840312156105dc57600080fd5b60006105ea84828501610520565b91505092915050565b60006105ff8383610732565b60208301905092915050565b61061481610862565b61061e818461089d565b92506106298261084e565b8060005b8381101561065a57815161064187826105f3565b965061064c83610883565b92505060018101905061062d565b505050505050565b61066b8161086d565b61067581846108a8565b925061068082610858565b8060005b838110156106b157815161069887826105f3565b96506106a383610890565b925050600181019050610684565b505050505050565b60006106c482610878565b6106ce81856108b3565b93506106de8185602086016108f8565b6106e78161092b565b840191505092915050565b60006106ff6010836108c4565b91507f736e617073686f742e73746f72616765000000000000000000000000000000006000830152601082019050919050565b61073b816108cf565b82525050565b61074a816108cf565b82525050565b610759816108d9565b82525050565b600061076a826106f2565b9150819050919050565b600060c0820190506107896000830185610662565b610796608083018461060b565b9392505050565b600060208201905081810360008301526107b781846106b9565b905092915050565b60006020820190506107d46000830184610741565b92915050565b60006020820190506107ef6000830184610750565b92915050565b6000604051905081810181811067ffffffffffffffff8211171561081857600080fd5b8060405250919050565b600067ffffffffffffffff82111561083957600080fd5b601f19601f8301169050602081019050919050565b6000819050919050565b6000819050919050565b600060029050919050565b600060049050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b600081905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b600063ffffffff82169050919050565b82818337600083830152505050565b60005b838110156109165780820151818401526020810190506108fb565b83811115610925576000848401525b50505050565b6000601f19601f8301169050919050565b610945816108cf565b811461095057600080fd5b5056fea2646970667358221220d3a42afcfb530ca38bf9c8eaa7444566e97bb61415216736c0338c52b1f9f94264736f6c63430006070033"

// DeploySnapshotsFacet deploys a new Ethereum contract, binding an instance of SnapshotsFacet to it.
func DeploySnapshotsFacet(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SnapshotsFacet, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsFacetABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SnapshotsFacetBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SnapshotsFacet{SnapshotsFacetCaller: SnapshotsFacetCaller{contract: contract}, SnapshotsFacetTransactor: SnapshotsFacetTransactor{contract: contract}, SnapshotsFacetFilterer: SnapshotsFacetFilterer{contract: contract}}, nil
}

// SnapshotsFacet is an auto generated Go binding around an Ethereum contract.
type SnapshotsFacet struct {
	SnapshotsFacetCaller     // Read-only binding to the contract
	SnapshotsFacetTransactor // Write-only binding to the contract
	SnapshotsFacetFilterer   // Log filterer for contract events
}

// SnapshotsFacetCaller is an auto generated read-only Go binding around an Ethereum contract.
type SnapshotsFacetCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SnapshotsFacetTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SnapshotsFacetFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SnapshotsFacetSession struct {
	Contract     *SnapshotsFacet   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SnapshotsFacetCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SnapshotsFacetCallerSession struct {
	Contract *SnapshotsFacetCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// SnapshotsFacetTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SnapshotsFacetTransactorSession struct {
	Contract     *SnapshotsFacetTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// SnapshotsFacetRaw is an auto generated low-level Go binding around an Ethereum contract.
type SnapshotsFacetRaw struct {
	Contract *SnapshotsFacet // Generic contract binding to access the raw methods on
}

// SnapshotsFacetCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SnapshotsFacetCallerRaw struct {
	Contract *SnapshotsFacetCaller // Generic read-only contract binding to access the raw methods on
}

// SnapshotsFacetTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SnapshotsFacetTransactorRaw struct {
	Contract *SnapshotsFacetTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSnapshotsFacet creates a new instance of SnapshotsFacet, bound to a specific deployed contract.
func NewSnapshotsFacet(address common.Address, backend bind.ContractBackend) (*SnapshotsFacet, error) {
	contract, err := bindSnapshotsFacet(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacet{SnapshotsFacetCaller: SnapshotsFacetCaller{contract: contract}, SnapshotsFacetTransactor: SnapshotsFacetTransactor{contract: contract}, SnapshotsFacetFilterer: SnapshotsFacetFilterer{contract: contract}}, nil
}

// NewSnapshotsFacetCaller creates a new read-only instance of SnapshotsFacet, bound to a specific deployed contract.
func NewSnapshotsFacetCaller(address common.Address, caller bind.ContractCaller) (*SnapshotsFacetCaller, error) {
	contract, err := bindSnapshotsFacet(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetCaller{contract: contract}, nil
}

// NewSnapshotsFacetTransactor creates a new write-only instance of SnapshotsFacet, bound to a specific deployed contract.
func NewSnapshotsFacetTransactor(address common.Address, transactor bind.ContractTransactor) (*SnapshotsFacetTransactor, error) {
	contract, err := bindSnapshotsFacet(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTransactor{contract: contract}, nil
}

// NewSnapshotsFacetFilterer creates a new log filterer instance of SnapshotsFacet, bound to a specific deployed contract.
func NewSnapshotsFacetFilterer(address common.Address, filterer bind.ContractFilterer) (*SnapshotsFacetFilterer, error) {
	contract, err := bindSnapshotsFacet(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetFilterer{contract: contract}, nil
}

// bindSnapshotsFacet binds a generic wrapper to an already deployed contract.
func bindSnapshotsFacet(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsFacetABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsFacet *SnapshotsFacetRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsFacet.Contract.SnapshotsFacetCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsFacet *SnapshotsFacetRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.SnapshotsFacetTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsFacet *SnapshotsFacetRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.SnapshotsFacetTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsFacet *SnapshotsFacetCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsFacet.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsFacet *SnapshotsFacetTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsFacet *SnapshotsFacetTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.contract.Transact(opts, method, params...)
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_SnapshotsFacet *SnapshotsFacetCaller) ExtractUint256(opts *bind.CallOpts, src []byte, offset *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _SnapshotsFacet.contract.Call(opts, out, "extractUint256", src, offset)
	return *ret0, err
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_SnapshotsFacet *SnapshotsFacetSession) ExtractUint256(src []byte, offset *big.Int) (*big.Int, error) {
	return _SnapshotsFacet.Contract.ExtractUint256(&_SnapshotsFacet.CallOpts, src, offset)
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_SnapshotsFacet *SnapshotsFacetCallerSession) ExtractUint256(src []byte, offset *big.Int) (*big.Int, error) {
	return _SnapshotsFacet.Contract.ExtractUint256(&_SnapshotsFacet.CallOpts, src, offset)
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_SnapshotsFacet *SnapshotsFacetCaller) ExtractUint32(opts *bind.CallOpts, src []byte, idx *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _SnapshotsFacet.contract.Call(opts, out, "extractUint32", src, idx)
	return *ret0, err
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_SnapshotsFacet *SnapshotsFacetSession) ExtractUint32(src []byte, idx *big.Int) (uint32, error) {
	return _SnapshotsFacet.Contract.ExtractUint32(&_SnapshotsFacet.CallOpts, src, idx)
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_SnapshotsFacet *SnapshotsFacetCallerSession) ExtractUint32(src []byte, idx *big.Int) (uint32, error) {
	return _SnapshotsFacet.Contract.ExtractUint32(&_SnapshotsFacet.CallOpts, src, idx)
}

// NextSnapshot is a free data retrieval call binding the contract method 0xe0cf48f9.
//
// Solidity: function nextSnapshot() view returns(uint256)
func (_SnapshotsFacet *SnapshotsFacetCaller) NextSnapshot(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _SnapshotsFacet.contract.Call(opts, out, "nextSnapshot")
	return *ret0, err
}

// NextSnapshot is a free data retrieval call binding the contract method 0xe0cf48f9.
//
// Solidity: function nextSnapshot() view returns(uint256)
func (_SnapshotsFacet *SnapshotsFacetSession) NextSnapshot() (*big.Int, error) {
	return _SnapshotsFacet.Contract.NextSnapshot(&_SnapshotsFacet.CallOpts)
}

// NextSnapshot is a free data retrieval call binding the contract method 0xe0cf48f9.
//
// Solidity: function nextSnapshot() view returns(uint256)
func (_SnapshotsFacet *SnapshotsFacetCallerSession) NextSnapshot() (*big.Int, error) {
	return _SnapshotsFacet.Contract.NextSnapshot(&_SnapshotsFacet.CallOpts)
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_SnapshotsFacet *SnapshotsFacetCaller) ParseSignatureGroup(opts *bind.CallOpts, _signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	ret := new(struct {
		PublicKey [4]*big.Int
		Signature [2]*big.Int
	})
	out := ret
	err := _SnapshotsFacet.contract.Call(opts, out, "parseSignatureGroup", _signatureGroup)
	return *ret, err
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_SnapshotsFacet *SnapshotsFacetSession) ParseSignatureGroup(_signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	return _SnapshotsFacet.Contract.ParseSignatureGroup(&_SnapshotsFacet.CallOpts, _signatureGroup)
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_SnapshotsFacet *SnapshotsFacetCallerSession) ParseSignatureGroup(_signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	return _SnapshotsFacet.Contract.ParseSignatureGroup(&_SnapshotsFacet.CallOpts, _signatureGroup)
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_SnapshotsFacet *SnapshotsFacetCaller) Reverse(opts *bind.CallOpts, orig []byte) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _SnapshotsFacet.contract.Call(opts, out, "reverse", orig)
	return *ret0, err
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_SnapshotsFacet *SnapshotsFacetSession) Reverse(orig []byte) ([]byte, error) {
	return _SnapshotsFacet.Contract.Reverse(&_SnapshotsFacet.CallOpts, orig)
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_SnapshotsFacet *SnapshotsFacetCallerSession) Reverse(orig []byte) ([]byte, error) {
	return _SnapshotsFacet.Contract.Reverse(&_SnapshotsFacet.CallOpts, orig)
}

// SetNextSnapshot is a paid mutator transaction binding the contract method 0x3df8c1dc.
//
// Solidity: function setNextSnapshot(uint256 ns) returns()
func (_SnapshotsFacet *SnapshotsFacetTransactor) SetNextSnapshot(opts *bind.TransactOpts, ns *big.Int) (*types.Transaction, error) {
	return _SnapshotsFacet.contract.Transact(opts, "setNextSnapshot", ns)
}

// SetNextSnapshot is a paid mutator transaction binding the contract method 0x3df8c1dc.
//
// Solidity: function setNextSnapshot(uint256 ns) returns()
func (_SnapshotsFacet *SnapshotsFacetSession) SetNextSnapshot(ns *big.Int) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.SetNextSnapshot(&_SnapshotsFacet.TransactOpts, ns)
}

// SetNextSnapshot is a paid mutator transaction binding the contract method 0x3df8c1dc.
//
// Solidity: function setNextSnapshot(uint256 ns) returns()
func (_SnapshotsFacet *SnapshotsFacetTransactorSession) SetNextSnapshot(ns *big.Int) (*types.Transaction, error) {
	return _SnapshotsFacet.Contract.SetNextSnapshot(&_SnapshotsFacet.TransactOpts, ns)
}

// SnapshotsFacetTestABI is the input ABI used to generate the binding from.
const SnapshotsFacetTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint256\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint32\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testNextSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// SnapshotsFacetTestBin is the compiled bytecode used for deploying new contracts.
var SnapshotsFacetTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b506113818061003a6000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80630a9254e4146100675780631e3e3deb146100715780633e6fe2761461007b5780638350596914610085578063ba414fa61461008f578063fa7626d4146100ad575b600080fd5b61006f6100cb565b005b610079610136565b005b610083610270565b005b61008d610372565b005b61009761047a565b6040516100a49190610757565b60405180910390f35b6100b561048d565b6040516100c29190610757565b60405180910390f35b6040516100d790610573565b604051809103906000f0801580156100f3573d6000803e3d6000fd5b50600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633df8c1dc600d6040518263ffffffff1660e01b815260040161019291906107a2565b600060405180830381600087803b1580156101ac57600080fd5b505af11580156101c0573d6000803e3d6000fd5b5050505061026e600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e0cf48f96040518163ffffffff1660e01b815260040160206040518083038186803b15801561022f57600080fd5b505afa158015610243573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061026791906105aa565b600d61049f565b565b60606040518060a00160405280608081526020016112cc60809139905060007fd8d6b02811ca34cef0bcbc79cc5dfaf2dc6b8133ea46d552ebfc96f1c2b2d710905060008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631c8c8ba48460006040518363ffffffff1660e01b8152600401610311929190610772565b60206040518083038186803b15801561032957600080fd5b505afa15801561033d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036191906105aa565b905061036d818361049f565b505050565b60606040518060400160405280600481526020017f01020400000000000000000000000000000000000000000000000000000000008152509050600062040201905060008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c1312f4d8460006040518363ffffffff1660e01b8152600401610413929190610772565b60206040518083038186803b15801561042b57600080fd5b505afa15801561043f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046391906105d3565b90506104758163ffffffff168361049f565b505050565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b808214610552577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516104d3906107bd565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88160405161050a91906107dd565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a882604051610541919061080b565b60405180910390a1610551610556565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b6109a98061092383390190565b60008151905061058f816108f4565b92915050565b6000815190506105a48161090b565b92915050565b6000602082840312156105bc57600080fd5b60006105ca84828501610580565b91505092915050565b6000602082840312156105e557600080fd5b60006105f384828501610595565b91505092915050565b61060581610866565b82525050565b600061061682610839565b6106208185610844565b93506106308185602086016108b0565b610639816108e3565b840191505092915050565b61064d8161088c565b82525050565b61065c8161089e565b82525050565b600061066f602283610855565b91507f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008301527f745d0000000000000000000000000000000000000000000000000000000000006020830152604082019050919050565b60006106d5600a83610855565b91507f20204578706563746564000000000000000000000000000000000000000000006000830152602082019050919050565b6000610715600a83610855565b91507f2020202041637475616c000000000000000000000000000000000000000000006000830152602082019050919050565b61075181610872565b82525050565b600060208201905061076c60008301846105fc565b92915050565b6000604082019050818103600083015261078c818561060b565b905061079b6020830184610644565b9392505050565b60006020820190506107b76000830184610653565b92915050565b600060208201905081810360008301526107d681610662565b9050919050565b600060408201905081810360008301526107f6816106c8565b90506108056020830184610748565b92915050565b6000604082019050818103600083015261082481610708565b90506108336020830184610748565b92915050565b600081519050919050565b600082825260208201905092915050565b600082825260208201905092915050565b60008115159050919050565b6000819050919050565b600063ffffffff82169050919050565b600061089782610872565b9050919050565b60006108a982610872565b9050919050565b60005b838110156108ce5780820151818401526020810190506108b3565b838111156108dd576000848401525b50505050565b6000601f19601f8301169050919050565b6108fd81610872565b811461090857600080fd5b50565b6109148161087c565b811461091f57600080fd5b5056fe608060405234801561001057600080fd5b50610989806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631c8c8ba4146100675780633df8c1dc146100975780639be2f2df146100b3578063c1312f4d146100e4578063e0cf48f914610114578063ec11c82314610132575b600080fd5b610081600480360381019061007c9190610576565b610162565b60405161008e91906107bf565b60405180910390f35b6100b160048036038101906100ac91906105ca565b6101d3565b005b6100cd60048036038101906100c89190610535565b6101ec565b6040516100db929190610774565b60405180910390f35b6100fe60048036038101906100f99190610576565b6102d5565b60405161010b91906107da565b60405180910390f35b61011c610386565b60405161012991906107bf565b60405180910390f35b61014c60048036038101906101479190610535565b61039e565b604051610159919061079d565b60405180910390f35b600080601f830190505b828111156101a757600882901b84828151811061018557fe5b602001015160f81c60f81b60f81c60ff1617915080806001900391505061016c565b50600881901b8383815181106101b957fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b60006101dd610468565b90508181600101819055505050565b6101f4610488565b6101fc6104aa565b60606102078461039e565b9050610214816000610162565b8260016002811061022157fe5b602002018181525050610235816020610162565b8260006002811061024257fe5b602002018181525050610256816040610162565b8360036004811061026357fe5b602002018181525050610277816060610162565b8360026004811061028457fe5b602002018181525050610298816080610162565b836001600481106102a557fe5b6020020181815250506102b98160a0610162565b836000600481106102c657fe5b60200201818152505050915091565b60008260038301815181106102e657fe5b602001015160f81c60f81b60f81c60ff16905082600283018151811061030857fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082600183018151811061033657fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082828151811061036157fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600080610391610468565b9050806001015491505090565b6060815167ffffffffffffffff811180156103b857600080fd5b506040519080825280601f01601f1916602001820160405280156103eb5781602001600182028036833780820191505090505b50905060008090505b82518110156104625782818151811061040957fe5b602001015160f81c60f81b82600183865103038151811061042657fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506103f4565b50919050565b6000806040516104779061075f565b604051809103902090508091505090565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b600082601f8301126104dd57600080fd5b81356104f06104eb82610822565b6107f5565b9150808252602083016020830185838301111561050c57600080fd5b6105178382846108e9565b50505092915050565b60008135905061052f8161093c565b92915050565b60006020828403121561054757600080fd5b600082013567ffffffffffffffff81111561056157600080fd5b61056d848285016104cc565b91505092915050565b6000806040838503121561058957600080fd5b600083013567ffffffffffffffff8111156105a357600080fd5b6105af858286016104cc565b92505060206105c085828601610520565b9150509250929050565b6000602082840312156105dc57600080fd5b60006105ea84828501610520565b91505092915050565b60006105ff8383610732565b60208301905092915050565b61061481610862565b61061e818461089d565b92506106298261084e565b8060005b8381101561065a57815161064187826105f3565b965061064c83610883565b92505060018101905061062d565b505050505050565b61066b8161086d565b61067581846108a8565b925061068082610858565b8060005b838110156106b157815161069887826105f3565b96506106a383610890565b925050600181019050610684565b505050505050565b60006106c482610878565b6106ce81856108b3565b93506106de8185602086016108f8565b6106e78161092b565b840191505092915050565b60006106ff6010836108c4565b91507f736e617073686f742e73746f72616765000000000000000000000000000000006000830152601082019050919050565b61073b816108cf565b82525050565b61074a816108cf565b82525050565b610759816108d9565b82525050565b600061076a826106f2565b9150819050919050565b600060c0820190506107896000830185610662565b610796608083018461060b565b9392505050565b600060208201905081810360008301526107b781846106b9565b905092915050565b60006020820190506107d46000830184610741565b92915050565b60006020820190506107ef6000830184610750565b92915050565b6000604051905081810181811067ffffffffffffffff8211171561081857600080fd5b8060405250919050565b600067ffffffffffffffff82111561083957600080fd5b601f19601f8301169050602081019050919050565b6000819050919050565b6000819050919050565b600060029050919050565b600060049050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b600081905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b600063ffffffff82169050919050565b82818337600083830152505050565b60005b838110156109165780820151818401526020810190506108fb565b83811115610925576000848401525b50505050565b6000601f19601f8301169050919050565b610945816108cf565b811461095057600080fd5b5056fea2646970667358221220d3a42afcfb530ca38bf9c8eaa7444566e97bb61415216736c0338c52b1f9f94264736f6c6343000607003310d7b2c2f196fceb52d546ea33816bdcf2fa5dcc79bcbcf0ce34ca1128b0d6d82d8652a0c5193001a55c0c43b5e0450297d3824a039d924b08d46520b354251f105a55d55c282005a5813480b48ee1efd61046d06b6084bafcf3c10dac57584b0f0bb886f1f1e04bcfa575020e3f47cceb3c11cd5cba496e5aedddc3a04d5b5ca264697066735822122002ecb0f05a2138184b7ea3b764f52e65dc4049f612e517e75ceebeb15b6b14e364736f6c63430006070033"

// DeploySnapshotsFacetTest deploys a new Ethereum contract, binding an instance of SnapshotsFacetTest to it.
func DeploySnapshotsFacetTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SnapshotsFacetTest, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsFacetTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SnapshotsFacetTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SnapshotsFacetTest{SnapshotsFacetTestCaller: SnapshotsFacetTestCaller{contract: contract}, SnapshotsFacetTestTransactor: SnapshotsFacetTestTransactor{contract: contract}, SnapshotsFacetTestFilterer: SnapshotsFacetTestFilterer{contract: contract}}, nil
}

// SnapshotsFacetTest is an auto generated Go binding around an Ethereum contract.
type SnapshotsFacetTest struct {
	SnapshotsFacetTestCaller     // Read-only binding to the contract
	SnapshotsFacetTestTransactor // Write-only binding to the contract
	SnapshotsFacetTestFilterer   // Log filterer for contract events
}

// SnapshotsFacetTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type SnapshotsFacetTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SnapshotsFacetTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SnapshotsFacetTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsFacetTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SnapshotsFacetTestSession struct {
	Contract     *SnapshotsFacetTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SnapshotsFacetTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SnapshotsFacetTestCallerSession struct {
	Contract *SnapshotsFacetTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// SnapshotsFacetTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SnapshotsFacetTestTransactorSession struct {
	Contract     *SnapshotsFacetTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// SnapshotsFacetTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type SnapshotsFacetTestRaw struct {
	Contract *SnapshotsFacetTest // Generic contract binding to access the raw methods on
}

// SnapshotsFacetTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SnapshotsFacetTestCallerRaw struct {
	Contract *SnapshotsFacetTestCaller // Generic read-only contract binding to access the raw methods on
}

// SnapshotsFacetTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SnapshotsFacetTestTransactorRaw struct {
	Contract *SnapshotsFacetTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSnapshotsFacetTest creates a new instance of SnapshotsFacetTest, bound to a specific deployed contract.
func NewSnapshotsFacetTest(address common.Address, backend bind.ContractBackend) (*SnapshotsFacetTest, error) {
	contract, err := bindSnapshotsFacetTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTest{SnapshotsFacetTestCaller: SnapshotsFacetTestCaller{contract: contract}, SnapshotsFacetTestTransactor: SnapshotsFacetTestTransactor{contract: contract}, SnapshotsFacetTestFilterer: SnapshotsFacetTestFilterer{contract: contract}}, nil
}

// NewSnapshotsFacetTestCaller creates a new read-only instance of SnapshotsFacetTest, bound to a specific deployed contract.
func NewSnapshotsFacetTestCaller(address common.Address, caller bind.ContractCaller) (*SnapshotsFacetTestCaller, error) {
	contract, err := bindSnapshotsFacetTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestCaller{contract: contract}, nil
}

// NewSnapshotsFacetTestTransactor creates a new write-only instance of SnapshotsFacetTest, bound to a specific deployed contract.
func NewSnapshotsFacetTestTransactor(address common.Address, transactor bind.ContractTransactor) (*SnapshotsFacetTestTransactor, error) {
	contract, err := bindSnapshotsFacetTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestTransactor{contract: contract}, nil
}

// NewSnapshotsFacetTestFilterer creates a new log filterer instance of SnapshotsFacetTest, bound to a specific deployed contract.
func NewSnapshotsFacetTestFilterer(address common.Address, filterer bind.ContractFilterer) (*SnapshotsFacetTestFilterer, error) {
	contract, err := bindSnapshotsFacetTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestFilterer{contract: contract}, nil
}

// bindSnapshotsFacetTest binds a generic wrapper to an already deployed contract.
func bindSnapshotsFacetTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsFacetTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsFacetTest *SnapshotsFacetTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsFacetTest.Contract.SnapshotsFacetTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsFacetTest *SnapshotsFacetTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.SnapshotsFacetTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsFacetTest *SnapshotsFacetTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.SnapshotsFacetTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsFacetTest *SnapshotsFacetTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsFacetTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _SnapshotsFacetTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) ISTEST() (bool, error) {
	return _SnapshotsFacetTest.Contract.ISTEST(&_SnapshotsFacetTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestCallerSession) ISTEST() (bool, error) {
	return _SnapshotsFacetTest.Contract.ISTEST(&_SnapshotsFacetTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _SnapshotsFacetTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) Failed() (bool, error) {
	return _SnapshotsFacetTest.Contract.Failed(&_SnapshotsFacetTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_SnapshotsFacetTest *SnapshotsFacetTestCallerSession) Failed() (bool, error) {
	return _SnapshotsFacetTest.Contract.Failed(&_SnapshotsFacetTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) SetUp() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.SetUp(&_SnapshotsFacetTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.SetUp(&_SnapshotsFacetTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactor) TestExtractUint256(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.contract.Transact(opts, "testExtractUint256")
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) TestExtractUint256() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestExtractUint256(&_SnapshotsFacetTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorSession) TestExtractUint256() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestExtractUint256(&_SnapshotsFacetTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactor) TestExtractUint32(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.contract.Transact(opts, "testExtractUint32")
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) TestExtractUint32() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestExtractUint32(&_SnapshotsFacetTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorSession) TestExtractUint32() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestExtractUint32(&_SnapshotsFacetTest.TransactOpts)
}

// TestNextSnapshot is a paid mutator transaction binding the contract method 0x1e3e3deb.
//
// Solidity: function testNextSnapshot() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactor) TestNextSnapshot(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsFacetTest.contract.Transact(opts, "testNextSnapshot")
}

// TestNextSnapshot is a paid mutator transaction binding the contract method 0x1e3e3deb.
//
// Solidity: function testNextSnapshot() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestSession) TestNextSnapshot() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestNextSnapshot(&_SnapshotsFacetTest.TransactOpts)
}

// TestNextSnapshot is a paid mutator transaction binding the contract method 0x1e3e3deb.
//
// Solidity: function testNextSnapshot() returns()
func (_SnapshotsFacetTest *SnapshotsFacetTestTransactorSession) TestNextSnapshot() (*types.Transaction, error) {
	return _SnapshotsFacetTest.Contract.TestNextSnapshot(&_SnapshotsFacetTest.TransactOpts)
}

// SnapshotsFacetTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogIterator struct {
	Event *SnapshotsFacetTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLog represents a Log event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLog(opts *bind.FilterOpts) (*SnapshotsFacetTestLogIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogIterator{contract: _SnapshotsFacetTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLog) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLog)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLog(log types.Log) (*SnapshotsFacetTestLog, error) {
	event := new(SnapshotsFacetTestLog)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogAddressIterator struct {
	Event *SnapshotsFacetTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogAddress represents a LogAddress event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*SnapshotsFacetTestLogAddressIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogAddressIterator{contract: _SnapshotsFacetTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogAddress)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogAddress(log types.Log) (*SnapshotsFacetTestLogAddress, error) {
	event := new(SnapshotsFacetTestLogAddress)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogBytesIterator struct {
	Event *SnapshotsFacetTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogBytes represents a LogBytes event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*SnapshotsFacetTestLogBytesIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogBytesIterator{contract: _SnapshotsFacetTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogBytes)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogBytes(log types.Log) (*SnapshotsFacetTestLogBytes, error) {
	event := new(SnapshotsFacetTestLogBytes)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogBytes32Iterator struct {
	Event *SnapshotsFacetTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogBytes32 represents a LogBytes32 event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*SnapshotsFacetTestLogBytes32Iterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogBytes32Iterator{contract: _SnapshotsFacetTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogBytes32)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogBytes32(log types.Log) (*SnapshotsFacetTestLogBytes32, error) {
	event := new(SnapshotsFacetTestLogBytes32)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogIntIterator struct {
	Event *SnapshotsFacetTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogInt represents a LogInt event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*SnapshotsFacetTestLogIntIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogIntIterator{contract: _SnapshotsFacetTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogInt) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogInt)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogInt(log types.Log) (*SnapshotsFacetTestLogInt, error) {
	event := new(SnapshotsFacetTestLogInt)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedAddressIterator struct {
	Event *SnapshotsFacetTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedAddress represents a LogNamedAddress event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedAddressIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedAddressIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedAddress)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedAddress(log types.Log) (*SnapshotsFacetTestLogNamedAddress, error) {
	event := new(SnapshotsFacetTestLogNamedAddress)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedBytesIterator struct {
	Event *SnapshotsFacetTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedBytes represents a LogNamedBytes event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedBytesIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedBytesIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedBytes)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedBytes(log types.Log) (*SnapshotsFacetTestLogNamedBytes, error) {
	event := new(SnapshotsFacetTestLogNamedBytes)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedBytes32Iterator struct {
	Event *SnapshotsFacetTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedBytes32Iterator{contract: _SnapshotsFacetTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedBytes32)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedBytes32(log types.Log) (*SnapshotsFacetTestLogNamedBytes32, error) {
	event := new(SnapshotsFacetTestLogNamedBytes32)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedDecimalIntIterator struct {
	Event *SnapshotsFacetTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedDecimalIntIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedDecimalInt)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*SnapshotsFacetTestLogNamedDecimalInt, error) {
	event := new(SnapshotsFacetTestLogNamedDecimalInt)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedDecimalUintIterator struct {
	Event *SnapshotsFacetTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedDecimalUintIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedDecimalUint)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*SnapshotsFacetTestLogNamedDecimalUint, error) {
	event := new(SnapshotsFacetTestLogNamedDecimalUint)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedIntIterator struct {
	Event *SnapshotsFacetTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedInt represents a LogNamedInt event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedIntIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedIntIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedInt)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedInt(log types.Log) (*SnapshotsFacetTestLogNamedInt, error) {
	event := new(SnapshotsFacetTestLogNamedInt)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedStringIterator struct {
	Event *SnapshotsFacetTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedString represents a LogNamedString event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedStringIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedStringIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedString)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedString(log types.Log) (*SnapshotsFacetTestLogNamedString, error) {
	event := new(SnapshotsFacetTestLogNamedString)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedUintIterator struct {
	Event *SnapshotsFacetTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogNamedUint represents a LogNamedUint event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*SnapshotsFacetTestLogNamedUintIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogNamedUintIterator{contract: _SnapshotsFacetTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogNamedUint)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogNamedUint(log types.Log) (*SnapshotsFacetTestLogNamedUint, error) {
	event := new(SnapshotsFacetTestLogNamedUint)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogStringIterator struct {
	Event *SnapshotsFacetTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogString represents a LogString event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogString(opts *bind.FilterOpts) (*SnapshotsFacetTestLogStringIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogStringIterator{contract: _SnapshotsFacetTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogString) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogString)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogString(log types.Log) (*SnapshotsFacetTestLogString, error) {
	event := new(SnapshotsFacetTestLogString)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogUintIterator struct {
	Event *SnapshotsFacetTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogUint represents a LogUint event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*SnapshotsFacetTestLogUintIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogUintIterator{contract: _SnapshotsFacetTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogUint) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogUint)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogUint(log types.Log) (*SnapshotsFacetTestLogUint, error) {
	event := new(SnapshotsFacetTestLogUint)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsFacetTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogsIterator struct {
	Event *SnapshotsFacetTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotsFacetTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotsFacetTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotsFacetTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotsFacetTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotsFacetTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotsFacetTestLogs represents a Logs event raised by the SnapshotsFacetTest contract.
type SnapshotsFacetTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) FilterLogs(opts *bind.FilterOpts) (*SnapshotsFacetTestLogsIterator, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &SnapshotsFacetTestLogsIterator{contract: _SnapshotsFacetTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *SnapshotsFacetTestLogs) (event.Subscription, error) {

	logs, sub, err := _SnapshotsFacetTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotsFacetTestLogs)
				if err := _SnapshotsFacetTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_SnapshotsFacetTest *SnapshotsFacetTestFilterer) ParseLogs(log types.Log) (*SnapshotsFacetTestLogs, error) {
	event := new(SnapshotsFacetTestLogs)
	if err := _SnapshotsFacetTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotsStorageLibraryABI is the input ABI used to generate the binding from.
const SnapshotsStorageLibraryABI = "[]"

// SnapshotsStorageLibraryBin is the compiled bytecode used for deploying new contracts.
var SnapshotsStorageLibraryBin = "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206ecca80cf97161766a898b9783eab130ef46a0d24fc4678d4057b96d4f09c4ce64736f6c63430006070033"

// DeploySnapshotsStorageLibrary deploys a new Ethereum contract, binding an instance of SnapshotsStorageLibrary to it.
func DeploySnapshotsStorageLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SnapshotsStorageLibrary, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsStorageLibraryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SnapshotsStorageLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SnapshotsStorageLibrary{SnapshotsStorageLibraryCaller: SnapshotsStorageLibraryCaller{contract: contract}, SnapshotsStorageLibraryTransactor: SnapshotsStorageLibraryTransactor{contract: contract}, SnapshotsStorageLibraryFilterer: SnapshotsStorageLibraryFilterer{contract: contract}}, nil
}

// SnapshotsStorageLibrary is an auto generated Go binding around an Ethereum contract.
type SnapshotsStorageLibrary struct {
	SnapshotsStorageLibraryCaller     // Read-only binding to the contract
	SnapshotsStorageLibraryTransactor // Write-only binding to the contract
	SnapshotsStorageLibraryFilterer   // Log filterer for contract events
}

// SnapshotsStorageLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type SnapshotsStorageLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsStorageLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SnapshotsStorageLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsStorageLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SnapshotsStorageLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotsStorageLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SnapshotsStorageLibrarySession struct {
	Contract     *SnapshotsStorageLibrary // Generic contract binding to set the session for
	CallOpts     bind.CallOpts            // Call options to use throughout this session
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// SnapshotsStorageLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SnapshotsStorageLibraryCallerSession struct {
	Contract *SnapshotsStorageLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                  // Call options to use throughout this session
}

// SnapshotsStorageLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SnapshotsStorageLibraryTransactorSession struct {
	Contract     *SnapshotsStorageLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                  // Transaction auth options to use throughout this session
}

// SnapshotsStorageLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type SnapshotsStorageLibraryRaw struct {
	Contract *SnapshotsStorageLibrary // Generic contract binding to access the raw methods on
}

// SnapshotsStorageLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SnapshotsStorageLibraryCallerRaw struct {
	Contract *SnapshotsStorageLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// SnapshotsStorageLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SnapshotsStorageLibraryTransactorRaw struct {
	Contract *SnapshotsStorageLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSnapshotsStorageLibrary creates a new instance of SnapshotsStorageLibrary, bound to a specific deployed contract.
func NewSnapshotsStorageLibrary(address common.Address, backend bind.ContractBackend) (*SnapshotsStorageLibrary, error) {
	contract, err := bindSnapshotsStorageLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SnapshotsStorageLibrary{SnapshotsStorageLibraryCaller: SnapshotsStorageLibraryCaller{contract: contract}, SnapshotsStorageLibraryTransactor: SnapshotsStorageLibraryTransactor{contract: contract}, SnapshotsStorageLibraryFilterer: SnapshotsStorageLibraryFilterer{contract: contract}}, nil
}

// NewSnapshotsStorageLibraryCaller creates a new read-only instance of SnapshotsStorageLibrary, bound to a specific deployed contract.
func NewSnapshotsStorageLibraryCaller(address common.Address, caller bind.ContractCaller) (*SnapshotsStorageLibraryCaller, error) {
	contract, err := bindSnapshotsStorageLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsStorageLibraryCaller{contract: contract}, nil
}

// NewSnapshotsStorageLibraryTransactor creates a new write-only instance of SnapshotsStorageLibrary, bound to a specific deployed contract.
func NewSnapshotsStorageLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*SnapshotsStorageLibraryTransactor, error) {
	contract, err := bindSnapshotsStorageLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsStorageLibraryTransactor{contract: contract}, nil
}

// NewSnapshotsStorageLibraryFilterer creates a new log filterer instance of SnapshotsStorageLibrary, bound to a specific deployed contract.
func NewSnapshotsStorageLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*SnapshotsStorageLibraryFilterer, error) {
	contract, err := bindSnapshotsStorageLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SnapshotsStorageLibraryFilterer{contract: contract}, nil
}

// bindSnapshotsStorageLibrary binds a generic wrapper to an already deployed contract.
func bindSnapshotsStorageLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotsStorageLibraryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsStorageLibrary.Contract.SnapshotsStorageLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsStorageLibrary.Contract.SnapshotsStorageLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsStorageLibrary.Contract.SnapshotsStorageLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SnapshotsStorageLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SnapshotsStorageLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SnapshotsStorageLibrary *SnapshotsStorageLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SnapshotsStorageLibrary.Contract.contract.Transact(opts, method, params...)
}

// StakingABI is the input ABI used to generate the binding from.
const StakingABI = "[{\"inputs\":[{\"internalType\":\"contractRegistry\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurntStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Fined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedStake\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"RequestedUnlockStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockedStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceRewardFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceStakeFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceUnlockedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceUnlockedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceUnlockedRewardFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockEpoch\",\"type\":\"uint256\"}],\"name\":\"lockRewardFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lockStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lockStakeFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reloadRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestUnlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"requestUnlockStakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"setCurrentEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochDelay\",\"type\":\"uint256\"}],\"name\":\"setEpochDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"unlockRewardFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockStakeFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// StakingBin is the compiled bytecode used for deploying new contracts.
var StakingBin = "0x60806040526002600b553480156200001657600080fd5b506040516200443538038062004435833981810160405260208110156200003c57600080fd5b810190808051906020019092919050505033600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550620000c1600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166200018d60201b60201c565b33600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a280600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050620002f5565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806200023257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000289576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180620044046031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b6140ff80620003056000396000f3fe608060405234801561001057600080fd5b506004361061021c5760003560e01c80638da5cb5b11610125578063c328b464116100ad578063e348da131161007c578063e348da1314610991578063ecd8c06a146109d5578063f1b7f4bf14610a1b578063f50ddb6714610a3d578063fad8b32a14610a835761021c565b8063c328b46414610841578063db1e46621461085f578063db518db2146108c5578063e29dda921461092b5761021c565b8063aeaf8812116100f4578063aeaf881214610797578063bd695a43146107a1578063bd8da917146107cf578063be9a6555146107ed578063bf7e214f146107f75761021c565b80638da5cb5b146106715780639be5d83e146106bb5780639c70287c146107135780639fb69b43146107795761021c565b80634fcf2b72116101a857806375f12b211161017757806375f12b211461057357806376671808146105955780637a9e5e4b146105b35780637f91bd69146105f75780638aa2799c146106535761021c565b80634fcf2b7214610473578063515c31a1146104b7578063523a3f081461050f5780635b6a0d1e146105555761021c565b80631dd6b9b1116101ef5780631dd6b9b1146102e95780632e1a7d4d146103175780632e7133061461035d57806335ba4daf146103b5578063461cbdcf1461040d5761021c565b806307da68f5146102215780630ddb07ad1461022b57806313af40351461029b5780631476601d146102df575b600080fd5b610229610ac7565b005b6102816004803603606081101561024157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190929190505050610c41565b604051808215151515815260200191505060405180910390f35b6102dd600480360360208110156102b157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610f8e565b005b6102e76110d7565b005b610315600480360360208110156102ff57600080fd5b8101908080359060200190929190505050611890565b005b6103436004803603602081101561032d57600080fd5b8101908080359060200190929190505050611a16565b604051808215151515815260200191505060405180910390f35b61039f6004803603602081101561037357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611aac565b6040518082815260200191505060405180910390f35b6103f7600480360360208110156103cb57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611abe565b6040518082815260200191505060405180910390f35b6104596004803603604081101561042357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611ad0565b604051808215151515815260200191505060405180910390f35b6104b56004803603602081101561048957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611c60565b005b6104f9600480360360208110156104cd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611de8565b6040518082815260200191505060405180910390f35b61053b6004803603602081101561052557600080fd5b8101908080359060200190929190505050611dfa565b604051808215151515815260200191505060405180910390f35b61055d61204a565b6040518082815260200191505060405180910390f35b61057b61205a565b604051808215151515815260200191505060405180910390f35b61059d61206d565b6040518082815260200191505060405180910390f35b6105f5600480360360208110156105c957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612073565b005b6106396004803603602081101561060d57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506121bc565b604051808215151515815260200191505060405180910390f35b61065b61234a565b6040518082815260200191505060405180910390f35b61067961235a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6106fd600480360360208110156106d157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612380565b6040518082815260200191505060405180910390f35b61075f6004803603604081101561072957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612392565b604051808215151515815260200191505060405180910390f35b6107816125cb565b6040518082815260200191505060405180910390f35b61079f6125db565b005b6107cd600480360360208110156107b757600080fd5b8101908080359060200190929190505050612669565b005b6107d761276c565b6040518082815260200191505060405180910390f35b6107f5612772565b005b6107ff6128ec565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610849612912565b6040518082815260200191505060405180910390f35b6108ab6004803603604081101561087557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612922565b604051808215151515815260200191505060405180910390f35b610911600480360360408110156108db57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612b5a565b604051808215151515815260200191505060405180910390f35b6109776004803603604081101561094157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612bf1565b604051808215151515815260200191505060405180910390f35b6109d3600480360360208110156109a757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612c88565b005b610a01600480360360208110156109eb57600080fd5b8101908080359060200190929190505050612ded565b604051808215151515815260200191505060405180910390f35b610a23612e83565b604051808215151515815260200191505060405180910390f35b610a6960048036036020811015610a5357600080fd5b8101908080359060200190929190505050612f16565b604051808215151515815260200191505060405180910390f35b610ac560048036036020811015610a9957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612fac565b005b610af5336000357fffffffff0000000000000000000000000000000000000000000000000000000016613180565b610b67576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506001600460146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610ce757506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610d3c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615610dbf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6000600c60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050610e0a614055565b84816000018181525050838160200181815250508160050181908060018154018082558091505060019003906000526020600020906002020160009091909190915060008201518160000155602082015181600101555050600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166340c10f1930876040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b158015610f0b57600080fd5b505af1158015610f1f573d6000803e3d6000fd5b505050508573ffffffffffffffffffffffffffffffffffffffff167f28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915866040518082815260200191505060405180910390a28160010160009054906101000a900460ff16925050509392505050565b610fbc336000357fffffffff0000000000000000000000000000000000000000000000000000000016613180565b61102e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061117b57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6111d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600f81526020017f7374616b696e67546f6b656e2f763100000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561129557808201518184015260208101905061127a565b50505050905090810190601f1680156112c25780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156112df57600080fd5b505afa1580156112f3573d6000803e3d6000fd5b505050506040513d602081101561130957600080fd5b8101908080519060200190929190505050905080600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611400576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260208152602001807f696e76616c6964206164647265737320666f72207374616b696e67546f6b656e81525060200191505060405180910390fd5b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600f81526020017f7574696c697479546f6b656e2f763100000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156114c55780820151818401526020810190506114aa565b50505050905090810190601f1680156114f25780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561150f57600080fd5b505afa158015611523573d6000803e3d6000fd5b505050506040513d602081101561153957600080fd5b8101908080519060200190929190505050905080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611630576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260208152602001807f696e76616c6964206164647265737320666f72207574696c697479546f6b656e81525060200191505060405180910390fd5b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600d81526020017f76616c696461746f72732f7631000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156116f55780820151818401526020810190506116da565b50505050905090810190601f1680156117225780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561173f57600080fd5b505afa158015611753573d6000803e3d6000fd5b505050506040513d602081101561176957600080fd5b8101908080519060200190929190505050905080600860006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611860576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f696e76616c6964206164647265737320666f722076616c696461746f7273000081525060200191505060405180910390fd5b61188b600860009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16612c88565b505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061193457506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611989576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615611a0c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b80600a8190555050565b6000600460149054906101000a900460ff1615611a9b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b611aa533836133db565b9050919050565b6000611ab7826135a8565b9050919050565b6000611ac9826135f4565b9050919050565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611b7657506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611bcb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615611c4e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b611c588383613640565b905092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611d0457506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611d59576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615611ddc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b611de581613886565b50565b6000611df382613a3c565b9050919050565b6000600460149054906101000a900460ff1615611e7f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6000600c60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508281600301541015611f3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f496e73756666696369656e7420756e6c6f636b65642062616c616e63652e000081525060200191505060405180910390fd5b611f53838260030154613a8890919063ffffffff16565b8160030181905550600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33856040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561200457600080fd5b505af1158015612018573d6000803e3d6000fd5b505050506040513d602081101561202e57600080fd5b8101908080519060200190929190505050506001915050919050565b6000612055336135a8565b905090565b600460149054906101000a900460ff1681565b600a5481565b6120a1336000357fffffffff0000000000000000000000000000000000000000000000000000000016613180565b612113576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061226257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6122b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff161561233a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b61234382613b0b565b9050919050565b6000612355336135f4565b905090565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061238b82613c74565b9050919050565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061243857506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61248d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615612510576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061256a838260000154613a8890919063ffffffff16565b81600001819055508373ffffffffffffffffffffffffffffffffffffffff167f54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e846040518082815260200191505060405180910390a2600191505092915050565b60006125d633613c74565b905090565b600460149054906101000a900460ff161561265e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b61266733613886565b565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061270d57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612762576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b80600b8190555050565b600b5481565b6127a0336000357fffffffff0000000000000000000000000000000000000000000000000000000016613180565b612812576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506000600460146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061291d33613a3c565b905090565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806129c857506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612a1d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600460149054906101000a900460ff1615612aa0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050612afa838260000154613a8890919063ffffffff16565b81600001819055508373ffffffffffffffffffffffffffffffffffffffff167e913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae846040518082815260200191505060405180910390a2600191505092915050565b6000600460149054906101000a900460ff1615612bdf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612be983836133db565b905092915050565b6000600460149054906101000a900460ff1615612c76576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612c808383613d16565b905092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480612d2c57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612d81576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b6000600460149054906101000a900460ff1615612e72576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612e7c3383613d16565b9050919050565b6000600460149054906101000a900460ff1615612f08576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612f1133613b0b565b905090565b6000600460149054906101000a900460ff1615612f9b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612fa53383613640565b9050919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061305057506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6130a5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806140996031913960400191505060405180910390fd5b600180541161311c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556001600081548092919060019003919050555050565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156131bf57600190506133d5565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561321e57600190506133d5565b600073ffffffffffffffffffffffffffffffffffffffff16600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141561327e57600090506133d5565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561339757600080fd5b505afa1580156133ab573d6000803e3d6000fd5b505050506040513d60208110156133c157600080fd5b810190808051906020019092919050505090505b92915050565b600080600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508281600401541015613499576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f496e73756666696369656e7420756e6c6f636b65642062616c616e63652e000081525060200191505060405180910390fd5b6134b0838260040154613a8890919063ffffffff16565b8160040181905550600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb85856040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561356157600080fd5b505af1158015613575573d6000803e3d6000fd5b505050506040513d602081101561358b57600080fd5b810190808051906020019092919050505050600191505092915050565b6000600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401549050919050565b6000600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001549050919050565b600080600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061369b838260000154613fd290919063ffffffff16565b81600001819055508373ffffffffffffffffffffffffffffffffffffffff167f1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c846040518082815260200191505060405180910390a2600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8530866040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b1580156137ce57600080fd5b505af11580156137e2573d6000803e3d6000fd5b505050506040513d60208110156137f857600080fd5b810190808051906020019092919050505061387b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f5472616e73666572206661696c6564000000000000000000000000000000000081525060200191505060405180910390fd5b600191505092915050565b6000600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001541161393e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260088152602001807f4e6f207374616b6500000000000000000000000000000000000000000000000081525060200191505060405180910390fd5b6001600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160006101000a81548160ff0219169083151502179055506139b0600b54600a54613fd290919063ffffffff16565b600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600201819055508073ffffffffffffffffffffffffffffffffffffffff167f1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc60405160405180910390a250565b6000600c60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600301549050919050565b6000828284039150811115613b05576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f64732d6d6174682d7375622d756e646572666c6f77000000000000000000000081525060200191505060405180910390fd5b92915050565b600080600c60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160050190506000805b8280549050811015613c48576000838281548110613b7557fe5b90600052602060002090600202019050600a54816001015411613c3a57613ba9816000015484613fd290919063ffffffff16565b925083600185805490500381548110613bbe57fe5b9060005260206000209060020201848381548110613bd857fe5b9060005260206000209060020201600082015481600001556001820154816001015590505083805480613c0757fe5b60019003818190600052602060002090600202016000808201600090556001820160009055505090558180600190039250505b508080600101915050613b5b565b50613c60818460030154613fd290919063ffffffff16565b836003018190555060019350505050919050565b6000806000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501905060005b8180549050811015613d0b57613cfc828281548110613cdb57fe5b90600052602060002090600202016000015484613fd290919063ffffffff16565b92508080600101915050613cc0565b508192505050919050565b6000600460149054906101000a900460ff1615613d9b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060010160009054906101000a900460ff16613e62576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f5374616b6520756e6c6f636b206e6f742072657175657374656400000000000081525060200191505060405180910390fd5b8281600001541015613ebf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260298152602001806140706029913960400191505060405180910390fd5b600a5481600201541115613f3b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260098152602001807f4e6f74207265616479000000000000000000000000000000000000000000000081525060200191505060405180910390fd5b613f52838260040154613fd290919063ffffffff16565b8160040181905550613f71838260000154613a8890919063ffffffff16565b81600001819055508373ffffffffffffffffffffffffffffffffffffffff167f252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c846040518082815260200191505060405180910390a2600191505092915050565b600082828401915081101561404f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b60405180604001604052806000815260200160008152509056fe5374616b6520756e6c6f636b207265717565737465642067726561746572207468616e207374616b6546756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea26469706673582212207b0da15ea36ab5bb524afb60a8e1a9aedc7387808cc24c9645bd07db28b7a2c064736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployStaking deploys a new Ethereum contract, binding an instance of Staking to it.
func DeployStaking(auth *bind.TransactOpts, backend bind.ContractBackend, registry_ common.Address) (common.Address, *types.Transaction, *Staking, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingBin), backend, registry_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// Staking is an auto generated Go binding around an Ethereum contract.
type Staking struct {
	StakingCaller     // Read-only binding to the contract
	StakingTransactor // Write-only binding to the contract
	StakingFilterer   // Log filterer for contract events
}

// StakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingSession struct {
	Contract     *Staking          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingCallerSession struct {
	Contract *StakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingTransactorSession struct {
	Contract     *StakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingRaw struct {
	Contract *Staking // Generic contract binding to access the raw methods on
}

// StakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingCallerRaw struct {
	Contract *StakingCaller // Generic read-only contract binding to access the raw methods on
}

// StakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingTransactorRaw struct {
	Contract *StakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaking creates a new instance of Staking, bound to a specific deployed contract.
func NewStaking(address common.Address, backend bind.ContractBackend) (*Staking, error) {
	contract, err := bindStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// NewStakingCaller creates a new read-only instance of Staking, bound to a specific deployed contract.
func NewStakingCaller(address common.Address, caller bind.ContractCaller) (*StakingCaller, error) {
	contract, err := bindStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingCaller{contract: contract}, nil
}

// NewStakingTransactor creates a new write-only instance of Staking, bound to a specific deployed contract.
func NewStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTransactor, error) {
	contract, err := bindStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingTransactor{contract: contract}, nil
}

// NewStakingFilterer creates a new log filterer instance of Staking, bound to a specific deployed contract.
func NewStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingFilterer, error) {
	contract, err := bindStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingFilterer{contract: contract}, nil
}

// bindStaking binds a generic wrapper to an already deployed contract.
func bindStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.StakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transact(opts, method, params...)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Staking *StakingCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Staking *StakingSession) Authority() (common.Address, error) {
	return _Staking.Contract.Authority(&_Staking.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Staking *StakingCallerSession) Authority() (common.Address, error) {
	return _Staking.Contract.Authority(&_Staking.CallOpts)
}

// BalanceReward is a free data retrieval call binding the contract method 0x9fb69b43.
//
// Solidity: function balanceReward() view returns(uint256)
func (_Staking *StakingCaller) BalanceReward(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceReward")
	return *ret0, err
}

// BalanceReward is a free data retrieval call binding the contract method 0x9fb69b43.
//
// Solidity: function balanceReward() view returns(uint256)
func (_Staking *StakingSession) BalanceReward() (*big.Int, error) {
	return _Staking.Contract.BalanceReward(&_Staking.CallOpts)
}

// BalanceReward is a free data retrieval call binding the contract method 0x9fb69b43.
//
// Solidity: function balanceReward() view returns(uint256)
func (_Staking *StakingCallerSession) BalanceReward() (*big.Int, error) {
	return _Staking.Contract.BalanceReward(&_Staking.CallOpts)
}

// BalanceRewardFor is a free data retrieval call binding the contract method 0x9be5d83e.
//
// Solidity: function balanceRewardFor(address who) view returns(uint256)
func (_Staking *StakingCaller) BalanceRewardFor(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceRewardFor", who)
	return *ret0, err
}

// BalanceRewardFor is a free data retrieval call binding the contract method 0x9be5d83e.
//
// Solidity: function balanceRewardFor(address who) view returns(uint256)
func (_Staking *StakingSession) BalanceRewardFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceRewardFor(&_Staking.CallOpts, who)
}

// BalanceRewardFor is a free data retrieval call binding the contract method 0x9be5d83e.
//
// Solidity: function balanceRewardFor(address who) view returns(uint256)
func (_Staking *StakingCallerSession) BalanceRewardFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceRewardFor(&_Staking.CallOpts, who)
}

// BalanceStake is a free data retrieval call binding the contract method 0x8aa2799c.
//
// Solidity: function balanceStake() view returns(uint256)
func (_Staking *StakingCaller) BalanceStake(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceStake")
	return *ret0, err
}

// BalanceStake is a free data retrieval call binding the contract method 0x8aa2799c.
//
// Solidity: function balanceStake() view returns(uint256)
func (_Staking *StakingSession) BalanceStake() (*big.Int, error) {
	return _Staking.Contract.BalanceStake(&_Staking.CallOpts)
}

// BalanceStake is a free data retrieval call binding the contract method 0x8aa2799c.
//
// Solidity: function balanceStake() view returns(uint256)
func (_Staking *StakingCallerSession) BalanceStake() (*big.Int, error) {
	return _Staking.Contract.BalanceStake(&_Staking.CallOpts)
}

// BalanceStakeFor is a free data retrieval call binding the contract method 0x35ba4daf.
//
// Solidity: function balanceStakeFor(address who) view returns(uint256)
func (_Staking *StakingCaller) BalanceStakeFor(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceStakeFor", who)
	return *ret0, err
}

// BalanceStakeFor is a free data retrieval call binding the contract method 0x35ba4daf.
//
// Solidity: function balanceStakeFor(address who) view returns(uint256)
func (_Staking *StakingSession) BalanceStakeFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceStakeFor(&_Staking.CallOpts, who)
}

// BalanceStakeFor is a free data retrieval call binding the contract method 0x35ba4daf.
//
// Solidity: function balanceStakeFor(address who) view returns(uint256)
func (_Staking *StakingCallerSession) BalanceStakeFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceStakeFor(&_Staking.CallOpts, who)
}

// BalanceUnlocked is a free data retrieval call binding the contract method 0x5b6a0d1e.
//
// Solidity: function balanceUnlocked() view returns(uint256)
func (_Staking *StakingCaller) BalanceUnlocked(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceUnlocked")
	return *ret0, err
}

// BalanceUnlocked is a free data retrieval call binding the contract method 0x5b6a0d1e.
//
// Solidity: function balanceUnlocked() view returns(uint256)
func (_Staking *StakingSession) BalanceUnlocked() (*big.Int, error) {
	return _Staking.Contract.BalanceUnlocked(&_Staking.CallOpts)
}

// BalanceUnlocked is a free data retrieval call binding the contract method 0x5b6a0d1e.
//
// Solidity: function balanceUnlocked() view returns(uint256)
func (_Staking *StakingCallerSession) BalanceUnlocked() (*big.Int, error) {
	return _Staking.Contract.BalanceUnlocked(&_Staking.CallOpts)
}

// BalanceUnlockedFor is a free data retrieval call binding the contract method 0x2e713306.
//
// Solidity: function balanceUnlockedFor(address who) view returns(uint256)
func (_Staking *StakingCaller) BalanceUnlockedFor(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceUnlockedFor", who)
	return *ret0, err
}

// BalanceUnlockedFor is a free data retrieval call binding the contract method 0x2e713306.
//
// Solidity: function balanceUnlockedFor(address who) view returns(uint256)
func (_Staking *StakingSession) BalanceUnlockedFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedFor(&_Staking.CallOpts, who)
}

// BalanceUnlockedFor is a free data retrieval call binding the contract method 0x2e713306.
//
// Solidity: function balanceUnlockedFor(address who) view returns(uint256)
func (_Staking *StakingCallerSession) BalanceUnlockedFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedFor(&_Staking.CallOpts, who)
}

// BalanceUnlockedReward is a free data retrieval call binding the contract method 0xc328b464.
//
// Solidity: function balanceUnlockedReward() view returns(uint256)
func (_Staking *StakingCaller) BalanceUnlockedReward(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceUnlockedReward")
	return *ret0, err
}

// BalanceUnlockedReward is a free data retrieval call binding the contract method 0xc328b464.
//
// Solidity: function balanceUnlockedReward() view returns(uint256)
func (_Staking *StakingSession) BalanceUnlockedReward() (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedReward(&_Staking.CallOpts)
}

// BalanceUnlockedReward is a free data retrieval call binding the contract method 0xc328b464.
//
// Solidity: function balanceUnlockedReward() view returns(uint256)
func (_Staking *StakingCallerSession) BalanceUnlockedReward() (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedReward(&_Staking.CallOpts)
}

// BalanceUnlockedRewardFor is a free data retrieval call binding the contract method 0x515c31a1.
//
// Solidity: function balanceUnlockedRewardFor(address who) view returns(uint256)
func (_Staking *StakingCaller) BalanceUnlockedRewardFor(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "balanceUnlockedRewardFor", who)
	return *ret0, err
}

// BalanceUnlockedRewardFor is a free data retrieval call binding the contract method 0x515c31a1.
//
// Solidity: function balanceUnlockedRewardFor(address who) view returns(uint256)
func (_Staking *StakingSession) BalanceUnlockedRewardFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedRewardFor(&_Staking.CallOpts, who)
}

// BalanceUnlockedRewardFor is a free data retrieval call binding the contract method 0x515c31a1.
//
// Solidity: function balanceUnlockedRewardFor(address who) view returns(uint256)
func (_Staking *StakingCallerSession) BalanceUnlockedRewardFor(who common.Address) (*big.Int, error) {
	return _Staking.Contract.BalanceUnlockedRewardFor(&_Staking.CallOpts, who)
}

// CurrentEpoch is a free data retrieval call binding the contract method 0x76671808.
//
// Solidity: function currentEpoch() view returns(uint256)
func (_Staking *StakingCaller) CurrentEpoch(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "currentEpoch")
	return *ret0, err
}

// CurrentEpoch is a free data retrieval call binding the contract method 0x76671808.
//
// Solidity: function currentEpoch() view returns(uint256)
func (_Staking *StakingSession) CurrentEpoch() (*big.Int, error) {
	return _Staking.Contract.CurrentEpoch(&_Staking.CallOpts)
}

// CurrentEpoch is a free data retrieval call binding the contract method 0x76671808.
//
// Solidity: function currentEpoch() view returns(uint256)
func (_Staking *StakingCallerSession) CurrentEpoch() (*big.Int, error) {
	return _Staking.Contract.CurrentEpoch(&_Staking.CallOpts)
}

// EpochDelay is a free data retrieval call binding the contract method 0xbd8da917.
//
// Solidity: function epochDelay() view returns(uint256)
func (_Staking *StakingCaller) EpochDelay(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "epochDelay")
	return *ret0, err
}

// EpochDelay is a free data retrieval call binding the contract method 0xbd8da917.
//
// Solidity: function epochDelay() view returns(uint256)
func (_Staking *StakingSession) EpochDelay() (*big.Int, error) {
	return _Staking.Contract.EpochDelay(&_Staking.CallOpts)
}

// EpochDelay is a free data retrieval call binding the contract method 0xbd8da917.
//
// Solidity: function epochDelay() view returns(uint256)
func (_Staking *StakingCallerSession) EpochDelay() (*big.Int, error) {
	return _Staking.Contract.EpochDelay(&_Staking.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Staking *StakingCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Staking *StakingSession) Owner() (common.Address, error) {
	return _Staking.Contract.Owner(&_Staking.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Staking *StakingCallerSession) Owner() (common.Address, error) {
	return _Staking.Contract.Owner(&_Staking.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Staking *StakingCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Staking *StakingSession) Stopped() (bool, error) {
	return _Staking.Contract.Stopped(&_Staking.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Staking *StakingCallerSession) Stopped() (bool, error) {
	return _Staking.Contract.Stopped(&_Staking.CallOpts)
}

// BurnStake is a paid mutator transaction binding the contract method 0x9c70287c.
//
// Solidity: function burnStake(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactor) BurnStake(opts *bind.TransactOpts, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "burnStake", who, amount)
}

// BurnStake is a paid mutator transaction binding the contract method 0x9c70287c.
//
// Solidity: function burnStake(address who, uint256 amount) returns(bool)
func (_Staking *StakingSession) BurnStake(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.BurnStake(&_Staking.TransactOpts, who, amount)
}

// BurnStake is a paid mutator transaction binding the contract method 0x9c70287c.
//
// Solidity: function burnStake(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) BurnStake(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.BurnStake(&_Staking.TransactOpts, who, amount)
}

// Fine is a paid mutator transaction binding the contract method 0xdb1e4662.
//
// Solidity: function fine(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactor) Fine(opts *bind.TransactOpts, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "fine", who, amount)
}

// Fine is a paid mutator transaction binding the contract method 0xdb1e4662.
//
// Solidity: function fine(address who, uint256 amount) returns(bool)
func (_Staking *StakingSession) Fine(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.Fine(&_Staking.TransactOpts, who, amount)
}

// Fine is a paid mutator transaction binding the contract method 0xdb1e4662.
//
// Solidity: function fine(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) Fine(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.Fine(&_Staking.TransactOpts, who, amount)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Staking *StakingTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Staking *StakingSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Staking.Contract.GrantOperator(&_Staking.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Staking *StakingTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Staking.Contract.GrantOperator(&_Staking.TransactOpts, _operator)
}

// LockRewardFor is a paid mutator transaction binding the contract method 0x0ddb07ad.
//
// Solidity: function lockRewardFor(address who, uint256 amountReward, uint256 unlockEpoch) returns(bool)
func (_Staking *StakingTransactor) LockRewardFor(opts *bind.TransactOpts, who common.Address, amountReward *big.Int, unlockEpoch *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "lockRewardFor", who, amountReward, unlockEpoch)
}

// LockRewardFor is a paid mutator transaction binding the contract method 0x0ddb07ad.
//
// Solidity: function lockRewardFor(address who, uint256 amountReward, uint256 unlockEpoch) returns(bool)
func (_Staking *StakingSession) LockRewardFor(who common.Address, amountReward *big.Int, unlockEpoch *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockRewardFor(&_Staking.TransactOpts, who, amountReward, unlockEpoch)
}

// LockRewardFor is a paid mutator transaction binding the contract method 0x0ddb07ad.
//
// Solidity: function lockRewardFor(address who, uint256 amountReward, uint256 unlockEpoch) returns(bool)
func (_Staking *StakingTransactorSession) LockRewardFor(who common.Address, amountReward *big.Int, unlockEpoch *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockRewardFor(&_Staking.TransactOpts, who, amountReward, unlockEpoch)
}

// LockStake is a paid mutator transaction binding the contract method 0xf50ddb67.
//
// Solidity: function lockStake(uint256 amount) returns(bool)
func (_Staking *StakingTransactor) LockStake(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "lockStake", amount)
}

// LockStake is a paid mutator transaction binding the contract method 0xf50ddb67.
//
// Solidity: function lockStake(uint256 amount) returns(bool)
func (_Staking *StakingSession) LockStake(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockStake(&_Staking.TransactOpts, amount)
}

// LockStake is a paid mutator transaction binding the contract method 0xf50ddb67.
//
// Solidity: function lockStake(uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) LockStake(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockStake(&_Staking.TransactOpts, amount)
}

// LockStakeFor is a paid mutator transaction binding the contract method 0x461cbdcf.
//
// Solidity: function lockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactor) LockStakeFor(opts *bind.TransactOpts, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "lockStakeFor", who, amount)
}

// LockStakeFor is a paid mutator transaction binding the contract method 0x461cbdcf.
//
// Solidity: function lockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingSession) LockStakeFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockStakeFor(&_Staking.TransactOpts, who, amount)
}

// LockStakeFor is a paid mutator transaction binding the contract method 0x461cbdcf.
//
// Solidity: function lockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) LockStakeFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.LockStakeFor(&_Staking.TransactOpts, who, amount)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Staking *StakingTransactor) ReloadRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "reloadRegistry")
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Staking *StakingSession) ReloadRegistry() (*types.Transaction, error) {
	return _Staking.Contract.ReloadRegistry(&_Staking.TransactOpts)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Staking *StakingTransactorSession) ReloadRegistry() (*types.Transaction, error) {
	return _Staking.Contract.ReloadRegistry(&_Staking.TransactOpts)
}

// RequestUnlockStake is a paid mutator transaction binding the contract method 0xaeaf8812.
//
// Solidity: function requestUnlockStake() returns()
func (_Staking *StakingTransactor) RequestUnlockStake(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "requestUnlockStake")
}

// RequestUnlockStake is a paid mutator transaction binding the contract method 0xaeaf8812.
//
// Solidity: function requestUnlockStake() returns()
func (_Staking *StakingSession) RequestUnlockStake() (*types.Transaction, error) {
	return _Staking.Contract.RequestUnlockStake(&_Staking.TransactOpts)
}

// RequestUnlockStake is a paid mutator transaction binding the contract method 0xaeaf8812.
//
// Solidity: function requestUnlockStake() returns()
func (_Staking *StakingTransactorSession) RequestUnlockStake() (*types.Transaction, error) {
	return _Staking.Contract.RequestUnlockStake(&_Staking.TransactOpts)
}

// RequestUnlockStakeFor is a paid mutator transaction binding the contract method 0x4fcf2b72.
//
// Solidity: function requestUnlockStakeFor(address who) returns()
func (_Staking *StakingTransactor) RequestUnlockStakeFor(opts *bind.TransactOpts, who common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "requestUnlockStakeFor", who)
}

// RequestUnlockStakeFor is a paid mutator transaction binding the contract method 0x4fcf2b72.
//
// Solidity: function requestUnlockStakeFor(address who) returns()
func (_Staking *StakingSession) RequestUnlockStakeFor(who common.Address) (*types.Transaction, error) {
	return _Staking.Contract.RequestUnlockStakeFor(&_Staking.TransactOpts, who)
}

// RequestUnlockStakeFor is a paid mutator transaction binding the contract method 0x4fcf2b72.
//
// Solidity: function requestUnlockStakeFor(address who) returns()
func (_Staking *StakingTransactorSession) RequestUnlockStakeFor(who common.Address) (*types.Transaction, error) {
	return _Staking.Contract.RequestUnlockStakeFor(&_Staking.TransactOpts, who)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Staking *StakingTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Staking *StakingSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Staking.Contract.RevokeOperator(&_Staking.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Staking *StakingTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Staking.Contract.RevokeOperator(&_Staking.TransactOpts, _operator)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Staking *StakingTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Staking *StakingSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SetAuthority(&_Staking.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Staking *StakingTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SetAuthority(&_Staking.TransactOpts, authority_)
}

// SetCurrentEpoch is a paid mutator transaction binding the contract method 0x1dd6b9b1.
//
// Solidity: function setCurrentEpoch(uint256 epoch) returns()
func (_Staking *StakingTransactor) SetCurrentEpoch(opts *bind.TransactOpts, epoch *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setCurrentEpoch", epoch)
}

// SetCurrentEpoch is a paid mutator transaction binding the contract method 0x1dd6b9b1.
//
// Solidity: function setCurrentEpoch(uint256 epoch) returns()
func (_Staking *StakingSession) SetCurrentEpoch(epoch *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetCurrentEpoch(&_Staking.TransactOpts, epoch)
}

// SetCurrentEpoch is a paid mutator transaction binding the contract method 0x1dd6b9b1.
//
// Solidity: function setCurrentEpoch(uint256 epoch) returns()
func (_Staking *StakingTransactorSession) SetCurrentEpoch(epoch *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetCurrentEpoch(&_Staking.TransactOpts, epoch)
}

// SetEpochDelay is a paid mutator transaction binding the contract method 0xbd695a43.
//
// Solidity: function setEpochDelay(uint256 _epochDelay) returns()
func (_Staking *StakingTransactor) SetEpochDelay(opts *bind.TransactOpts, _epochDelay *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setEpochDelay", _epochDelay)
}

// SetEpochDelay is a paid mutator transaction binding the contract method 0xbd695a43.
//
// Solidity: function setEpochDelay(uint256 _epochDelay) returns()
func (_Staking *StakingSession) SetEpochDelay(_epochDelay *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetEpochDelay(&_Staking.TransactOpts, _epochDelay)
}

// SetEpochDelay is a paid mutator transaction binding the contract method 0xbd695a43.
//
// Solidity: function setEpochDelay(uint256 _epochDelay) returns()
func (_Staking *StakingTransactorSession) SetEpochDelay(_epochDelay *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetEpochDelay(&_Staking.TransactOpts, _epochDelay)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Staking *StakingTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Staking *StakingSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SetOwner(&_Staking.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Staking *StakingTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SetOwner(&_Staking.TransactOpts, owner_)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Staking *StakingTransactor) Start(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "start")
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Staking *StakingSession) Start() (*types.Transaction, error) {
	return _Staking.Contract.Start(&_Staking.TransactOpts)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Staking *StakingTransactorSession) Start() (*types.Transaction, error) {
	return _Staking.Contract.Start(&_Staking.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Staking *StakingTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Staking *StakingSession) Stop() (*types.Transaction, error) {
	return _Staking.Contract.Stop(&_Staking.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Staking *StakingTransactorSession) Stop() (*types.Transaction, error) {
	return _Staking.Contract.Stop(&_Staking.TransactOpts)
}

// UnlockReward is a paid mutator transaction binding the contract method 0xf1b7f4bf.
//
// Solidity: function unlockReward() returns(bool)
func (_Staking *StakingTransactor) UnlockReward(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "unlockReward")
}

// UnlockReward is a paid mutator transaction binding the contract method 0xf1b7f4bf.
//
// Solidity: function unlockReward() returns(bool)
func (_Staking *StakingSession) UnlockReward() (*types.Transaction, error) {
	return _Staking.Contract.UnlockReward(&_Staking.TransactOpts)
}

// UnlockReward is a paid mutator transaction binding the contract method 0xf1b7f4bf.
//
// Solidity: function unlockReward() returns(bool)
func (_Staking *StakingTransactorSession) UnlockReward() (*types.Transaction, error) {
	return _Staking.Contract.UnlockReward(&_Staking.TransactOpts)
}

// UnlockRewardFor is a paid mutator transaction binding the contract method 0x7f91bd69.
//
// Solidity: function unlockRewardFor(address who) returns(bool)
func (_Staking *StakingTransactor) UnlockRewardFor(opts *bind.TransactOpts, who common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "unlockRewardFor", who)
}

// UnlockRewardFor is a paid mutator transaction binding the contract method 0x7f91bd69.
//
// Solidity: function unlockRewardFor(address who) returns(bool)
func (_Staking *StakingSession) UnlockRewardFor(who common.Address) (*types.Transaction, error) {
	return _Staking.Contract.UnlockRewardFor(&_Staking.TransactOpts, who)
}

// UnlockRewardFor is a paid mutator transaction binding the contract method 0x7f91bd69.
//
// Solidity: function unlockRewardFor(address who) returns(bool)
func (_Staking *StakingTransactorSession) UnlockRewardFor(who common.Address) (*types.Transaction, error) {
	return _Staking.Contract.UnlockRewardFor(&_Staking.TransactOpts, who)
}

// UnlockStake is a paid mutator transaction binding the contract method 0xecd8c06a.
//
// Solidity: function unlockStake(uint256 amount) returns(bool)
func (_Staking *StakingTransactor) UnlockStake(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "unlockStake", amount)
}

// UnlockStake is a paid mutator transaction binding the contract method 0xecd8c06a.
//
// Solidity: function unlockStake(uint256 amount) returns(bool)
func (_Staking *StakingSession) UnlockStake(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UnlockStake(&_Staking.TransactOpts, amount)
}

// UnlockStake is a paid mutator transaction binding the contract method 0xecd8c06a.
//
// Solidity: function unlockStake(uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) UnlockStake(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UnlockStake(&_Staking.TransactOpts, amount)
}

// UnlockStakeFor is a paid mutator transaction binding the contract method 0xe29dda92.
//
// Solidity: function unlockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactor) UnlockStakeFor(opts *bind.TransactOpts, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "unlockStakeFor", who, amount)
}

// UnlockStakeFor is a paid mutator transaction binding the contract method 0xe29dda92.
//
// Solidity: function unlockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingSession) UnlockStakeFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UnlockStakeFor(&_Staking.TransactOpts, who, amount)
}

// UnlockStakeFor is a paid mutator transaction binding the contract method 0xe29dda92.
//
// Solidity: function unlockStakeFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) UnlockStakeFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UnlockStakeFor(&_Staking.TransactOpts, who, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 amount) returns(bool)
func (_Staking *StakingTransactor) Withdraw(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "withdraw", amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 amount) returns(bool)
func (_Staking *StakingSession) Withdraw(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.Withdraw(&_Staking.TransactOpts, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) Withdraw(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.Withdraw(&_Staking.TransactOpts, amount)
}

// WithdrawFor is a paid mutator transaction binding the contract method 0xdb518db2.
//
// Solidity: function withdrawFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactor) WithdrawFor(opts *bind.TransactOpts, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "withdrawFor", who, amount)
}

// WithdrawFor is a paid mutator transaction binding the contract method 0xdb518db2.
//
// Solidity: function withdrawFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingSession) WithdrawFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.WithdrawFor(&_Staking.TransactOpts, who, amount)
}

// WithdrawFor is a paid mutator transaction binding the contract method 0xdb518db2.
//
// Solidity: function withdrawFor(address who, uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) WithdrawFor(who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.WithdrawFor(&_Staking.TransactOpts, who, amount)
}

// WithdrawReward is a paid mutator transaction binding the contract method 0x523a3f08.
//
// Solidity: function withdrawReward(uint256 amount) returns(bool)
func (_Staking *StakingTransactor) WithdrawReward(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "withdrawReward", amount)
}

// WithdrawReward is a paid mutator transaction binding the contract method 0x523a3f08.
//
// Solidity: function withdrawReward(uint256 amount) returns(bool)
func (_Staking *StakingSession) WithdrawReward(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.WithdrawReward(&_Staking.TransactOpts, amount)
}

// WithdrawReward is a paid mutator transaction binding the contract method 0x523a3f08.
//
// Solidity: function withdrawReward(uint256 amount) returns(bool)
func (_Staking *StakingTransactorSession) WithdrawReward(amount *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.WithdrawReward(&_Staking.TransactOpts, amount)
}

// StakingBurntStakeIterator is returned from FilterBurntStake and is used to iterate over the raw logs and unpacked data for BurntStake events raised by the Staking contract.
type StakingBurntStakeIterator struct {
	Event *StakingBurntStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingBurntStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingBurntStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingBurntStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingBurntStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingBurntStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingBurntStake represents a BurntStake event raised by the Staking contract.
type StakingBurntStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBurntStake is a free log retrieval operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterBurntStake(opts *bind.FilterOpts, who []common.Address) (*StakingBurntStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "BurntStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingBurntStakeIterator{contract: _Staking.contract, event: "BurntStake", logs: logs, sub: sub}, nil
}

// WatchBurntStake is a free log subscription operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchBurntStake(opts *bind.WatchOpts, sink chan<- *StakingBurntStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "BurntStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingBurntStake)
				if err := _Staking.contract.UnpackLog(event, "BurntStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurntStake is a log parse operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseBurntStake(log types.Log) (*StakingBurntStake, error) {
	event := new(StakingBurntStake)
	if err := _Staking.contract.UnpackLog(event, "BurntStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingFinedIterator is returned from FilterFined and is used to iterate over the raw logs and unpacked data for Fined events raised by the Staking contract.
type StakingFinedIterator struct {
	Event *StakingFined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingFinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingFined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingFined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingFinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingFinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingFined represents a Fined event raised by the Staking contract.
type StakingFined struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFined is a free log retrieval operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterFined(opts *bind.FilterOpts, who []common.Address) (*StakingFinedIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "Fined", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingFinedIterator{contract: _Staking.contract, event: "Fined", logs: logs, sub: sub}, nil
}

// WatchFined is a free log subscription operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchFined(opts *bind.WatchOpts, sink chan<- *StakingFined, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "Fined", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingFined)
				if err := _Staking.contract.UnpackLog(event, "Fined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFined is a log parse operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseFined(log types.Log) (*StakingFined, error) {
	event := new(StakingFined)
	if err := _Staking.contract.UnpackLog(event, "Fined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingLockedRewardIterator is returned from FilterLockedReward and is used to iterate over the raw logs and unpacked data for LockedReward events raised by the Staking contract.
type StakingLockedRewardIterator struct {
	Event *StakingLockedReward // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingLockedRewardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingLockedReward)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingLockedReward)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingLockedRewardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingLockedRewardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingLockedReward represents a LockedReward event raised by the Staking contract.
type StakingLockedReward struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLockedReward is a free log retrieval operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterLockedReward(opts *bind.FilterOpts, who []common.Address) (*StakingLockedRewardIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "LockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingLockedRewardIterator{contract: _Staking.contract, event: "LockedReward", logs: logs, sub: sub}, nil
}

// WatchLockedReward is a free log subscription operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchLockedReward(opts *bind.WatchOpts, sink chan<- *StakingLockedReward, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "LockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingLockedReward)
				if err := _Staking.contract.UnpackLog(event, "LockedReward", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLockedReward is a log parse operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseLockedReward(log types.Log) (*StakingLockedReward, error) {
	event := new(StakingLockedReward)
	if err := _Staking.contract.UnpackLog(event, "LockedReward", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingLockedStakeIterator is returned from FilterLockedStake and is used to iterate over the raw logs and unpacked data for LockedStake events raised by the Staking contract.
type StakingLockedStakeIterator struct {
	Event *StakingLockedStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingLockedStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingLockedStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingLockedStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingLockedStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingLockedStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingLockedStake represents a LockedStake event raised by the Staking contract.
type StakingLockedStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLockedStake is a free log retrieval operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterLockedStake(opts *bind.FilterOpts, who []common.Address) (*StakingLockedStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "LockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingLockedStakeIterator{contract: _Staking.contract, event: "LockedStake", logs: logs, sub: sub}, nil
}

// WatchLockedStake is a free log subscription operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchLockedStake(opts *bind.WatchOpts, sink chan<- *StakingLockedStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "LockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingLockedStake)
				if err := _Staking.contract.UnpackLog(event, "LockedStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLockedStake is a log parse operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseLockedStake(log types.Log) (*StakingLockedStake, error) {
	event := new(StakingLockedStake)
	if err := _Staking.contract.UnpackLog(event, "LockedStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the Staking contract.
type StakingLogSetAuthorityIterator struct {
	Event *StakingLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingLogSetAuthority represents a LogSetAuthority event raised by the Staking contract.
type StakingLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Staking *StakingFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*StakingLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &StakingLogSetAuthorityIterator{contract: _Staking.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Staking *StakingFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *StakingLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingLogSetAuthority)
				if err := _Staking.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetAuthority is a log parse operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Staking *StakingFilterer) ParseLogSetAuthority(log types.Log) (*StakingLogSetAuthority, error) {
	event := new(StakingLogSetAuthority)
	if err := _Staking.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the Staking contract.
type StakingLogSetOwnerIterator struct {
	Event *StakingLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingLogSetOwner represents a LogSetOwner event raised by the Staking contract.
type StakingLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Staking *StakingFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*StakingLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &StakingLogSetOwnerIterator{contract: _Staking.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Staking *StakingFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *StakingLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingLogSetOwner)
				if err := _Staking.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetOwner is a log parse operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Staking *StakingFilterer) ParseLogSetOwner(log types.Log) (*StakingLogSetOwner, error) {
	event := new(StakingLogSetOwner)
	if err := _Staking.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRequestedUnlockStakeIterator is returned from FilterRequestedUnlockStake and is used to iterate over the raw logs and unpacked data for RequestedUnlockStake events raised by the Staking contract.
type StakingRequestedUnlockStakeIterator struct {
	Event *StakingRequestedUnlockStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRequestedUnlockStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRequestedUnlockStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRequestedUnlockStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRequestedUnlockStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRequestedUnlockStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRequestedUnlockStake represents a RequestedUnlockStake event raised by the Staking contract.
type StakingRequestedUnlockStake struct {
	Who common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterRequestedUnlockStake is a free log retrieval operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_Staking *StakingFilterer) FilterRequestedUnlockStake(opts *bind.FilterOpts, who []common.Address) (*StakingRequestedUnlockStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RequestedUnlockStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingRequestedUnlockStakeIterator{contract: _Staking.contract, event: "RequestedUnlockStake", logs: logs, sub: sub}, nil
}

// WatchRequestedUnlockStake is a free log subscription operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_Staking *StakingFilterer) WatchRequestedUnlockStake(opts *bind.WatchOpts, sink chan<- *StakingRequestedUnlockStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RequestedUnlockStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRequestedUnlockStake)
				if err := _Staking.contract.UnpackLog(event, "RequestedUnlockStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestedUnlockStake is a log parse operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_Staking *StakingFilterer) ParseRequestedUnlockStake(log types.Log) (*StakingRequestedUnlockStake, error) {
	event := new(StakingRequestedUnlockStake)
	if err := _Staking.contract.UnpackLog(event, "RequestedUnlockStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingUnlockedRewardIterator is returned from FilterUnlockedReward and is used to iterate over the raw logs and unpacked data for UnlockedReward events raised by the Staking contract.
type StakingUnlockedRewardIterator struct {
	Event *StakingUnlockedReward // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUnlockedRewardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUnlockedReward)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUnlockedReward)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUnlockedRewardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUnlockedRewardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUnlockedReward represents a UnlockedReward event raised by the Staking contract.
type StakingUnlockedReward struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterUnlockedReward is a free log retrieval operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterUnlockedReward(opts *bind.FilterOpts, who []common.Address) (*StakingUnlockedRewardIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UnlockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingUnlockedRewardIterator{contract: _Staking.contract, event: "UnlockedReward", logs: logs, sub: sub}, nil
}

// WatchUnlockedReward is a free log subscription operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchUnlockedReward(opts *bind.WatchOpts, sink chan<- *StakingUnlockedReward, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UnlockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUnlockedReward)
				if err := _Staking.contract.UnpackLog(event, "UnlockedReward", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnlockedReward is a log parse operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseUnlockedReward(log types.Log) (*StakingUnlockedReward, error) {
	event := new(StakingUnlockedReward)
	if err := _Staking.contract.UnpackLog(event, "UnlockedReward", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingUnlockedStakeIterator is returned from FilterUnlockedStake and is used to iterate over the raw logs and unpacked data for UnlockedStake events raised by the Staking contract.
type StakingUnlockedStakeIterator struct {
	Event *StakingUnlockedStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUnlockedStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUnlockedStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUnlockedStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUnlockedStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUnlockedStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUnlockedStake represents a UnlockedStake event raised by the Staking contract.
type StakingUnlockedStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterUnlockedStake is a free log retrieval operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) FilterUnlockedStake(opts *bind.FilterOpts, who []common.Address) (*StakingUnlockedStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UnlockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingUnlockedStakeIterator{contract: _Staking.contract, event: "UnlockedStake", logs: logs, sub: sub}, nil
}

// WatchUnlockedStake is a free log subscription operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) WatchUnlockedStake(opts *bind.WatchOpts, sink chan<- *StakingUnlockedStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UnlockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUnlockedStake)
				if err := _Staking.contract.UnpackLog(event, "UnlockedStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnlockedStake is a log parse operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_Staking *StakingFilterer) ParseUnlockedStake(log types.Log) (*StakingUnlockedStake, error) {
	event := new(StakingUnlockedStake)
	if err := _Staking.contract.UnpackLog(event, "UnlockedStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsABI is the input ABI used to generate the binding from.
const StakingEventsABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurntStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Fined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"RequestedUnlockStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockedStake\",\"type\":\"event\"}]"

// StakingEventsBin is the compiled bytecode used for deploying new contracts.
var StakingEventsBin = "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220468557bf3d71246e0f6fc297163217e8a1f2c9103ede2b40f8814b1addd75ab864736f6c63430006070033"

// DeployStakingEvents deploys a new Ethereum contract, binding an instance of StakingEvents to it.
func DeployStakingEvents(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *StakingEvents, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingEventsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingEventsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &StakingEvents{StakingEventsCaller: StakingEventsCaller{contract: contract}, StakingEventsTransactor: StakingEventsTransactor{contract: contract}, StakingEventsFilterer: StakingEventsFilterer{contract: contract}}, nil
}

// StakingEvents is an auto generated Go binding around an Ethereum contract.
type StakingEvents struct {
	StakingEventsCaller     // Read-only binding to the contract
	StakingEventsTransactor // Write-only binding to the contract
	StakingEventsFilterer   // Log filterer for contract events
}

// StakingEventsCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingEventsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingEventsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingEventsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingEventsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingEventsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingEventsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingEventsSession struct {
	Contract     *StakingEvents    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingEventsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingEventsCallerSession struct {
	Contract *StakingEventsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// StakingEventsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingEventsTransactorSession struct {
	Contract     *StakingEventsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// StakingEventsRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingEventsRaw struct {
	Contract *StakingEvents // Generic contract binding to access the raw methods on
}

// StakingEventsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingEventsCallerRaw struct {
	Contract *StakingEventsCaller // Generic read-only contract binding to access the raw methods on
}

// StakingEventsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingEventsTransactorRaw struct {
	Contract *StakingEventsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStakingEvents creates a new instance of StakingEvents, bound to a specific deployed contract.
func NewStakingEvents(address common.Address, backend bind.ContractBackend) (*StakingEvents, error) {
	contract, err := bindStakingEvents(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &StakingEvents{StakingEventsCaller: StakingEventsCaller{contract: contract}, StakingEventsTransactor: StakingEventsTransactor{contract: contract}, StakingEventsFilterer: StakingEventsFilterer{contract: contract}}, nil
}

// NewStakingEventsCaller creates a new read-only instance of StakingEvents, bound to a specific deployed contract.
func NewStakingEventsCaller(address common.Address, caller bind.ContractCaller) (*StakingEventsCaller, error) {
	contract, err := bindStakingEvents(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingEventsCaller{contract: contract}, nil
}

// NewStakingEventsTransactor creates a new write-only instance of StakingEvents, bound to a specific deployed contract.
func NewStakingEventsTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingEventsTransactor, error) {
	contract, err := bindStakingEvents(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingEventsTransactor{contract: contract}, nil
}

// NewStakingEventsFilterer creates a new log filterer instance of StakingEvents, bound to a specific deployed contract.
func NewStakingEventsFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingEventsFilterer, error) {
	contract, err := bindStakingEvents(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingEventsFilterer{contract: contract}, nil
}

// bindStakingEvents binds a generic wrapper to an already deployed contract.
func bindStakingEvents(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingEventsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StakingEvents *StakingEventsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _StakingEvents.Contract.StakingEventsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StakingEvents *StakingEventsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StakingEvents.Contract.StakingEventsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StakingEvents *StakingEventsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StakingEvents.Contract.StakingEventsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StakingEvents *StakingEventsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _StakingEvents.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StakingEvents *StakingEventsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StakingEvents.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StakingEvents *StakingEventsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StakingEvents.Contract.contract.Transact(opts, method, params...)
}

// StakingEventsBurntStakeIterator is returned from FilterBurntStake and is used to iterate over the raw logs and unpacked data for BurntStake events raised by the StakingEvents contract.
type StakingEventsBurntStakeIterator struct {
	Event *StakingEventsBurntStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsBurntStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsBurntStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsBurntStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsBurntStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsBurntStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsBurntStake represents a BurntStake event raised by the StakingEvents contract.
type StakingEventsBurntStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBurntStake is a free log retrieval operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterBurntStake(opts *bind.FilterOpts, who []common.Address) (*StakingEventsBurntStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "BurntStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsBurntStakeIterator{contract: _StakingEvents.contract, event: "BurntStake", logs: logs, sub: sub}, nil
}

// WatchBurntStake is a free log subscription operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchBurntStake(opts *bind.WatchOpts, sink chan<- *StakingEventsBurntStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "BurntStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsBurntStake)
				if err := _StakingEvents.contract.UnpackLog(event, "BurntStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurntStake is a log parse operation binding the contract event 0x54420ac6a7570cfba30d2f88982f0749811f67103de3a63ad8b82cb754e8680e.
//
// Solidity: event BurntStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseBurntStake(log types.Log) (*StakingEventsBurntStake, error) {
	event := new(StakingEventsBurntStake)
	if err := _StakingEvents.contract.UnpackLog(event, "BurntStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsFinedIterator is returned from FilterFined and is used to iterate over the raw logs and unpacked data for Fined events raised by the StakingEvents contract.
type StakingEventsFinedIterator struct {
	Event *StakingEventsFined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsFinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsFined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsFined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsFinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsFinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsFined represents a Fined event raised by the StakingEvents contract.
type StakingEventsFined struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFined is a free log retrieval operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterFined(opts *bind.FilterOpts, who []common.Address) (*StakingEventsFinedIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "Fined", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsFinedIterator{contract: _StakingEvents.contract, event: "Fined", logs: logs, sub: sub}, nil
}

// WatchFined is a free log subscription operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchFined(opts *bind.WatchOpts, sink chan<- *StakingEventsFined, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "Fined", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsFined)
				if err := _StakingEvents.contract.UnpackLog(event, "Fined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFined is a log parse operation binding the contract event 0x00913d46aef0f0d115d70ea1c7c23198505f577d1d1916cc60710ca2204ae6ae.
//
// Solidity: event Fined(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseFined(log types.Log) (*StakingEventsFined, error) {
	event := new(StakingEventsFined)
	if err := _StakingEvents.contract.UnpackLog(event, "Fined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsLockedRewardIterator is returned from FilterLockedReward and is used to iterate over the raw logs and unpacked data for LockedReward events raised by the StakingEvents contract.
type StakingEventsLockedRewardIterator struct {
	Event *StakingEventsLockedReward // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsLockedRewardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsLockedReward)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsLockedReward)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsLockedRewardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsLockedRewardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsLockedReward represents a LockedReward event raised by the StakingEvents contract.
type StakingEventsLockedReward struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLockedReward is a free log retrieval operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterLockedReward(opts *bind.FilterOpts, who []common.Address) (*StakingEventsLockedRewardIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "LockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsLockedRewardIterator{contract: _StakingEvents.contract, event: "LockedReward", logs: logs, sub: sub}, nil
}

// WatchLockedReward is a free log subscription operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchLockedReward(opts *bind.WatchOpts, sink chan<- *StakingEventsLockedReward, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "LockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsLockedReward)
				if err := _StakingEvents.contract.UnpackLog(event, "LockedReward", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLockedReward is a log parse operation binding the contract event 0x28dc9c0ffa672df041cad84edbee41508284600c9394bda0f8586d012c5e0915.
//
// Solidity: event LockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseLockedReward(log types.Log) (*StakingEventsLockedReward, error) {
	event := new(StakingEventsLockedReward)
	if err := _StakingEvents.contract.UnpackLog(event, "LockedReward", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsLockedStakeIterator is returned from FilterLockedStake and is used to iterate over the raw logs and unpacked data for LockedStake events raised by the StakingEvents contract.
type StakingEventsLockedStakeIterator struct {
	Event *StakingEventsLockedStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsLockedStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsLockedStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsLockedStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsLockedStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsLockedStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsLockedStake represents a LockedStake event raised by the StakingEvents contract.
type StakingEventsLockedStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLockedStake is a free log retrieval operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterLockedStake(opts *bind.FilterOpts, who []common.Address) (*StakingEventsLockedStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "LockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsLockedStakeIterator{contract: _StakingEvents.contract, event: "LockedStake", logs: logs, sub: sub}, nil
}

// WatchLockedStake is a free log subscription operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchLockedStake(opts *bind.WatchOpts, sink chan<- *StakingEventsLockedStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "LockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsLockedStake)
				if err := _StakingEvents.contract.UnpackLog(event, "LockedStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLockedStake is a log parse operation binding the contract event 0x1de2f07b0a1c69916a8b25b889051644192307ea08444a2e11f8654d1db3ab0c.
//
// Solidity: event LockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseLockedStake(log types.Log) (*StakingEventsLockedStake, error) {
	event := new(StakingEventsLockedStake)
	if err := _StakingEvents.contract.UnpackLog(event, "LockedStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsRequestedUnlockStakeIterator is returned from FilterRequestedUnlockStake and is used to iterate over the raw logs and unpacked data for RequestedUnlockStake events raised by the StakingEvents contract.
type StakingEventsRequestedUnlockStakeIterator struct {
	Event *StakingEventsRequestedUnlockStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsRequestedUnlockStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsRequestedUnlockStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsRequestedUnlockStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsRequestedUnlockStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsRequestedUnlockStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsRequestedUnlockStake represents a RequestedUnlockStake event raised by the StakingEvents contract.
type StakingEventsRequestedUnlockStake struct {
	Who common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterRequestedUnlockStake is a free log retrieval operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_StakingEvents *StakingEventsFilterer) FilterRequestedUnlockStake(opts *bind.FilterOpts, who []common.Address) (*StakingEventsRequestedUnlockStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "RequestedUnlockStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsRequestedUnlockStakeIterator{contract: _StakingEvents.contract, event: "RequestedUnlockStake", logs: logs, sub: sub}, nil
}

// WatchRequestedUnlockStake is a free log subscription operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_StakingEvents *StakingEventsFilterer) WatchRequestedUnlockStake(opts *bind.WatchOpts, sink chan<- *StakingEventsRequestedUnlockStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "RequestedUnlockStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsRequestedUnlockStake)
				if err := _StakingEvents.contract.UnpackLog(event, "RequestedUnlockStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestedUnlockStake is a log parse operation binding the contract event 0x1fde0d8a6620647f5c7b5632a87b23101ba553c9b474caf1134fb24d92bf6ddc.
//
// Solidity: event RequestedUnlockStake(address indexed who)
func (_StakingEvents *StakingEventsFilterer) ParseRequestedUnlockStake(log types.Log) (*StakingEventsRequestedUnlockStake, error) {
	event := new(StakingEventsRequestedUnlockStake)
	if err := _StakingEvents.contract.UnpackLog(event, "RequestedUnlockStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsUnlockedRewardIterator is returned from FilterUnlockedReward and is used to iterate over the raw logs and unpacked data for UnlockedReward events raised by the StakingEvents contract.
type StakingEventsUnlockedRewardIterator struct {
	Event *StakingEventsUnlockedReward // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsUnlockedRewardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsUnlockedReward)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsUnlockedReward)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsUnlockedRewardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsUnlockedRewardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsUnlockedReward represents a UnlockedReward event raised by the StakingEvents contract.
type StakingEventsUnlockedReward struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterUnlockedReward is a free log retrieval operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterUnlockedReward(opts *bind.FilterOpts, who []common.Address) (*StakingEventsUnlockedRewardIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "UnlockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsUnlockedRewardIterator{contract: _StakingEvents.contract, event: "UnlockedReward", logs: logs, sub: sub}, nil
}

// WatchUnlockedReward is a free log subscription operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchUnlockedReward(opts *bind.WatchOpts, sink chan<- *StakingEventsUnlockedReward, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "UnlockedReward", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsUnlockedReward)
				if err := _StakingEvents.contract.UnpackLog(event, "UnlockedReward", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnlockedReward is a log parse operation binding the contract event 0x496a1c9a1a9ac29d87ecb4e563683ebd0ee80798869f36c86175059eb5dc7304.
//
// Solidity: event UnlockedReward(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseUnlockedReward(log types.Log) (*StakingEventsUnlockedReward, error) {
	event := new(StakingEventsUnlockedReward)
	if err := _StakingEvents.contract.UnpackLog(event, "UnlockedReward", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingEventsUnlockedStakeIterator is returned from FilterUnlockedStake and is used to iterate over the raw logs and unpacked data for UnlockedStake events raised by the StakingEvents contract.
type StakingEventsUnlockedStakeIterator struct {
	Event *StakingEventsUnlockedStake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingEventsUnlockedStakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingEventsUnlockedStake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingEventsUnlockedStake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingEventsUnlockedStakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingEventsUnlockedStakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingEventsUnlockedStake represents a UnlockedStake event raised by the StakingEvents contract.
type StakingEventsUnlockedStake struct {
	Who    common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterUnlockedStake is a free log retrieval operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) FilterUnlockedStake(opts *bind.FilterOpts, who []common.Address) (*StakingEventsUnlockedStakeIterator, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.FilterLogs(opts, "UnlockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return &StakingEventsUnlockedStakeIterator{contract: _StakingEvents.contract, event: "UnlockedStake", logs: logs, sub: sub}, nil
}

// WatchUnlockedStake is a free log subscription operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) WatchUnlockedStake(opts *bind.WatchOpts, sink chan<- *StakingEventsUnlockedStake, who []common.Address) (event.Subscription, error) {

	var whoRule []interface{}
	for _, whoItem := range who {
		whoRule = append(whoRule, whoItem)
	}

	logs, sub, err := _StakingEvents.contract.WatchLogs(opts, "UnlockedStake", whoRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingEventsUnlockedStake)
				if err := _StakingEvents.contract.UnpackLog(event, "UnlockedStake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnlockedStake is a log parse operation binding the contract event 0x252a696583e35c4d61332829d3bb2a8236f2500140258f089951799c9b999a9c.
//
// Solidity: event UnlockedStake(address indexed who, uint256 amount)
func (_StakingEvents *StakingEventsFilterer) ParseUnlockedStake(log types.Log) (*StakingEventsUnlockedStake, error) {
	event := new(StakingEventsUnlockedStake)
	if err := _StakingEvents.contract.UnpackLog(event, "UnlockedStake", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenABI is the input ABI used to generate the binding from.
const TokenABI = "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbol_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name_\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenBin is the compiled bytecode used for deploying new contracts.
var TokenBin = "0x6080604052601260065560006007556040516200001c9062000c8b565b604051809103906000f08015801562000039573d6000803e3d6000fd5b50600b60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156200008757600080fd5b5060405162003d5238038062003d5283398181016040526040811015620000ad57600080fd5b8101908080519060200190929190805190602001909291905050508133600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a2806005819055505033600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550620001c9600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620002ed60201b60201c565b620001fc600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620004be60201b60201c565b80600781905550600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13336040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015620002a557600080fd5b505af1158015620002ba573d6000803e3d6000fd5b505050506012600681905550620002e5336c0c9f2c9cd04674edea400000006200060e60201b60201c565b505062000c99565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620003935750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b620003ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156200048c57600080fd5b505af1158015620004a1573d6000803e3d6000fd5b50505050620004bb816200083b60201b6200249a1760201c565b50565b620004f4336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b62000567576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b62000644336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b620006b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff16156200073b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6200078c600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548262000c0760201b60201c565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620007e36002548262000c0760201b60201c565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620008e15750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000938576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415620009e6576001905062000c01565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141562000a47576001905062000c01565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141562000aa8576000905062000c01565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801562000bc157600080fd5b505afa15801562000bd6573d6000803e3d6000fd5b505050506040513d602081101562000bed57600080fd5b810190808051906020019092919050505090505b92915050565b600082828401915081101562000c85576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b61083980620034e883390190565b61283f8062000ca96000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80638da5cb5b116100f9578063be9a655511610097578063dd62ed3e11610071578063dd62ed3e14610760578063e348da13146107d8578063f2d5d56b1461081c578063fad8b32a1461086a576101a9565b8063be9a6555146106b0578063bf7e214f146106ba578063daea85c514610704576101a9565b8063a0712d68116100d3578063a0712d6814610560578063a9059cbb1461058e578063b753a98c146105f4578063bb35783b14610642576101a9565b80638da5cb5b146104aa57806395d89b41146104f45780639dc29fac14610512576101a9565b8063313ce567116101665780635ac801fe116101405780635ac801fe146103be57806370a08231146103ec57806375f12b21146104445780637a9e5e4b14610466576101a9565b8063313ce5671461032457806340c10f191461034257806342966c6814610390576101a9565b806306fdde03146101ae57806307da68f5146101cc578063095ea7b3146101d657806313af40351461023c57806318160ddd1461028057806323b872dd1461029e575b600080fd5b6101b66108ae565b6040518082815260200191505060405180910390f35b6101d46108b4565b005b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061099c565b604051808215151515815260200191505060405180910390f35b61027e6004803603602081101561025257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b11565b005b610288610c5a565b6040518082815260200191505060405180910390f35b61030a600480360360608110156102b457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610c60565b604051808215151515815260200191505060405180910390f35b61032c6111f8565b6040518082815260200191505060405180910390f35b61038e6004803603604081101561035857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506111fe565b005b6103bc600480360360208110156103a657600080fd5b8101908080359060200190929190505050611411565b005b6103ea600480360360208110156103d457600080fd5b810190808035906020019092919050505061141e565b005b61042e6004803603602081101561040257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114c8565b6040518082815260200191505060405180910390f35b61044c6114e0565b604051808215151515815260200191505060405180910390f35b6104a86004803603602081101561047c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114f3565b005b6104b261163a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6104fc611660565b6040518082815260200191505060405180910390f35b61055e6004803603604081101561052857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611666565b005b61058c6004803603602081101561057657600080fd5b8101908080359060200190929190505050611c04565b005b6105da600480360360408110156105a457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c11565b604051808215151515815260200191505060405180910390f35b6106406004803603604081101561060a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c26565b005b6106ae6004803603606081101561065857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c36565b005b6106b8611c47565b005b6106c2611d30565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6107466004803603602081101561071a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d55565b604051808215151515815260200191505060405180910390f35b6107c26004803603604081101561077657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d88565b6040518082815260200191505060405180910390f35b61081a600480360360208110156107ee57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611dad565b005b6108686004803603604081101561083257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611f6c565b005b6108ac6004803603602081101561088057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611f7c565b005b60075481565b6108e2336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610954576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60018060146101000a81548160ff0219169083151502179055507fbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b60405160405180910390a1565b6000600160149054906101000a900460ff1615610a21576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b610b3f336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610bb1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b60025481565b6000600160149054906101000a900460ff1615610ce5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614158015610dbd57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15610fbb5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610eb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b610f3a600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611070576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b6110b9600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611145600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612417565b600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b60065481565b61122c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b61129e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611321576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b61136a600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612417565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506113b960025482612417565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b61141b3382611666565b50565b61144c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b6114be576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b8060078190555050565b60036020528060005260406000206000915090505481565b600160149054906101000a900460ff1681565b611521336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611593576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b611694336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611706576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611789576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415801561186157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15611a5f5780600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611958576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b6119de600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611b14576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b611b5d600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611bac60025482612394565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5826040518082815260200191505060405180910390a25050565b611c0e33826111fe565b50565b6000611c1e338484610c60565b905092915050565b611c31338383610c60565b505050565b611c41838383610c60565b50505050565b611c75336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611ce7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000600160146101000a81548160ff0219169083151502179055507f1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b60405160405180910390a1565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000611d81827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61099c565b9050919050565b6004602052816000526040600020602052806000526040600020600091509150505481565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611e525750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611ea7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50505050611f698161249a565b50565b611f77823383610c60565b505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806120215750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612076576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fad8b32a826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561211757600080fd5b505af115801561212b573d6000803e3d6000fd5b5050505061213881612601565b50565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561217a576001905061238e565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156121d9576001905061238e565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415612238576000905061238e565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561235057600080fd5b505afa158015612364573d6000803e3d6000fd5b505050506040513d602081101561237a57600080fd5b810190808051906020019092919050505090505b92915050565b6000828284039150811115612411576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f64732d6d6174682d7375622d756e646572666c6f77000000000000000000000081525060200191505060405180910390fd5b92915050565b6000828284019150811015612494576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061253f5750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612594576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806126a65750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6126fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600160095411612773576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600960008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea264697066735822122082e300604a10aacaee1f89b3d629b05643e878ab42c4fb218fb6a45d82449f3064736f6c63430006070033608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806108086031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610619806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063b700961314610046578063e348da13146100eb578063fad8b32a1461012f575b600080fd5b6100d16004803603606081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610173565b604051808215151515815260200191505060405180910390f35b61012d6004803603602081101561010157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610279565b005b6101716004803603602081101561014557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506103de565b005b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061021957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61026e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600190509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061031d57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610372576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061048257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6104d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600180541161054e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220e7b320aefb1d184f7676dc65708a2ba5fbb27dfa7b0b34c702cf84c84818fd2c64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployToken deploys a new Ethereum contract, binding an instance of Token to it.
func DeployToken(auth *bind.TransactOpts, backend bind.ContractBackend, symbol_ [32]byte, name_ [32]byte) (common.Address, *types.Transaction, *Token, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenBin), backend, symbol_, name_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Token{TokenCaller: TokenCaller{contract: contract}, TokenTransactor: TokenTransactor{contract: contract}, TokenFilterer: TokenFilterer{contract: contract}}, nil
}

// Token is an auto generated Go binding around an Ethereum contract.
type Token struct {
	TokenCaller     // Read-only binding to the contract
	TokenTransactor // Write-only binding to the contract
	TokenFilterer   // Log filterer for contract events
}

// TokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenSession struct {
	Contract     *Token            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenCallerSession struct {
	Contract *TokenCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// TokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenTransactorSession struct {
	Contract     *TokenTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenRaw struct {
	Contract *Token // Generic contract binding to access the raw methods on
}

// TokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenCallerRaw struct {
	Contract *TokenCaller // Generic read-only contract binding to access the raw methods on
}

// TokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenTransactorRaw struct {
	Contract *TokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewToken creates a new instance of Token, bound to a specific deployed contract.
func NewToken(address common.Address, backend bind.ContractBackend) (*Token, error) {
	contract, err := bindToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Token{TokenCaller: TokenCaller{contract: contract}, TokenTransactor: TokenTransactor{contract: contract}, TokenFilterer: TokenFilterer{contract: contract}}, nil
}

// NewTokenCaller creates a new read-only instance of Token, bound to a specific deployed contract.
func NewTokenCaller(address common.Address, caller bind.ContractCaller) (*TokenCaller, error) {
	contract, err := bindToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenCaller{contract: contract}, nil
}

// NewTokenTransactor creates a new write-only instance of Token, bound to a specific deployed contract.
func NewTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenTransactor, error) {
	contract, err := bindToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenTransactor{contract: contract}, nil
}

// NewTokenFilterer creates a new log filterer instance of Token, bound to a specific deployed contract.
func NewTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenFilterer, error) {
	contract, err := bindToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenFilterer{contract: contract}, nil
}

// bindToken binds a generic wrapper to an already deployed contract.
func bindToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Token *TokenRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Token.Contract.TokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Token *TokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Token.Contract.TokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Token *TokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Token.Contract.TokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Token *TokenCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Token.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Token *TokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Token.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Token *TokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Token.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address , address ) view returns(uint256)
func (_Token *TokenCaller) Allowance(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "allowance", arg0, arg1)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address , address ) view returns(uint256)
func (_Token *TokenSession) Allowance(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Token.Contract.Allowance(&_Token.CallOpts, arg0, arg1)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address , address ) view returns(uint256)
func (_Token *TokenCallerSession) Allowance(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Token.Contract.Allowance(&_Token.CallOpts, arg0, arg1)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Token *TokenCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Token *TokenSession) Authority() (common.Address, error) {
	return _Token.Contract.Authority(&_Token.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Token *TokenCallerSession) Authority() (common.Address, error) {
	return _Token.Contract.Authority(&_Token.CallOpts)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address ) view returns(uint256)
func (_Token *TokenCaller) BalanceOf(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "balanceOf", arg0)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address ) view returns(uint256)
func (_Token *TokenSession) BalanceOf(arg0 common.Address) (*big.Int, error) {
	return _Token.Contract.BalanceOf(&_Token.CallOpts, arg0)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address ) view returns(uint256)
func (_Token *TokenCallerSession) BalanceOf(arg0 common.Address) (*big.Int, error) {
	return _Token.Contract.BalanceOf(&_Token.CallOpts, arg0)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint256)
func (_Token *TokenCaller) Decimals(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "decimals")
	return *ret0, err
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint256)
func (_Token *TokenSession) Decimals() (*big.Int, error) {
	return _Token.Contract.Decimals(&_Token.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint256)
func (_Token *TokenCallerSession) Decimals() (*big.Int, error) {
	return _Token.Contract.Decimals(&_Token.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(bytes32)
func (_Token *TokenCaller) Name(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(bytes32)
func (_Token *TokenSession) Name() ([32]byte, error) {
	return _Token.Contract.Name(&_Token.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(bytes32)
func (_Token *TokenCallerSession) Name() ([32]byte, error) {
	return _Token.Contract.Name(&_Token.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Token *TokenCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Token *TokenSession) Owner() (common.Address, error) {
	return _Token.Contract.Owner(&_Token.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Token *TokenCallerSession) Owner() (common.Address, error) {
	return _Token.Contract.Owner(&_Token.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Token *TokenCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Token *TokenSession) Stopped() (bool, error) {
	return _Token.Contract.Stopped(&_Token.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Token *TokenCallerSession) Stopped() (bool, error) {
	return _Token.Contract.Stopped(&_Token.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(bytes32)
func (_Token *TokenCaller) Symbol(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(bytes32)
func (_Token *TokenSession) Symbol() ([32]byte, error) {
	return _Token.Contract.Symbol(&_Token.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(bytes32)
func (_Token *TokenCallerSession) Symbol() ([32]byte, error) {
	return _Token.Contract.Symbol(&_Token.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Token *TokenCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Token.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Token *TokenSession) TotalSupply() (*big.Int, error) {
	return _Token.Contract.TotalSupply(&_Token.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Token *TokenCallerSession) TotalSupply() (*big.Int, error) {
	return _Token.Contract.TotalSupply(&_Token.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address guy, uint256 wad) returns(bool)
func (_Token *TokenTransactor) Approve(opts *bind.TransactOpts, guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "approve", guy, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address guy, uint256 wad) returns(bool)
func (_Token *TokenSession) Approve(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Approve(&_Token.TransactOpts, guy, wad)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address guy, uint256 wad) returns(bool)
func (_Token *TokenTransactorSession) Approve(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Approve(&_Token.TransactOpts, guy, wad)
}

// Approve0 is a paid mutator transaction binding the contract method 0xdaea85c5.
//
// Solidity: function approve(address guy) returns(bool)
func (_Token *TokenTransactor) Approve0(opts *bind.TransactOpts, guy common.Address) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "approve0", guy)
}

// Approve0 is a paid mutator transaction binding the contract method 0xdaea85c5.
//
// Solidity: function approve(address guy) returns(bool)
func (_Token *TokenSession) Approve0(guy common.Address) (*types.Transaction, error) {
	return _Token.Contract.Approve0(&_Token.TransactOpts, guy)
}

// Approve0 is a paid mutator transaction binding the contract method 0xdaea85c5.
//
// Solidity: function approve(address guy) returns(bool)
func (_Token *TokenTransactorSession) Approve0(guy common.Address) (*types.Transaction, error) {
	return _Token.Contract.Approve0(&_Token.TransactOpts, guy)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 wad) returns()
func (_Token *TokenTransactor) Burn(opts *bind.TransactOpts, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "burn", wad)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 wad) returns()
func (_Token *TokenSession) Burn(wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Burn(&_Token.TransactOpts, wad)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 wad) returns()
func (_Token *TokenTransactorSession) Burn(wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Burn(&_Token.TransactOpts, wad)
}

// Burn0 is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address guy, uint256 wad) returns()
func (_Token *TokenTransactor) Burn0(opts *bind.TransactOpts, guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "burn0", guy, wad)
}

// Burn0 is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address guy, uint256 wad) returns()
func (_Token *TokenSession) Burn0(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Burn0(&_Token.TransactOpts, guy, wad)
}

// Burn0 is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address guy, uint256 wad) returns()
func (_Token *TokenTransactorSession) Burn0(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Burn0(&_Token.TransactOpts, guy, wad)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Token *TokenTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Token *TokenSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Token.Contract.GrantOperator(&_Token.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Token *TokenTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Token.Contract.GrantOperator(&_Token.TransactOpts, _operator)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_Token *TokenTransactor) Mint(opts *bind.TransactOpts, guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "mint", guy, wad)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_Token *TokenSession) Mint(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Mint(&_Token.TransactOpts, guy, wad)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address guy, uint256 wad) returns()
func (_Token *TokenTransactorSession) Mint(guy common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Mint(&_Token.TransactOpts, guy, wad)
}

// Mint0 is a paid mutator transaction binding the contract method 0xa0712d68.
//
// Solidity: function mint(uint256 wad) returns()
func (_Token *TokenTransactor) Mint0(opts *bind.TransactOpts, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "mint0", wad)
}

// Mint0 is a paid mutator transaction binding the contract method 0xa0712d68.
//
// Solidity: function mint(uint256 wad) returns()
func (_Token *TokenSession) Mint0(wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Mint0(&_Token.TransactOpts, wad)
}

// Mint0 is a paid mutator transaction binding the contract method 0xa0712d68.
//
// Solidity: function mint(uint256 wad) returns()
func (_Token *TokenTransactorSession) Mint0(wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Mint0(&_Token.TransactOpts, wad)
}

// Move is a paid mutator transaction binding the contract method 0xbb35783b.
//
// Solidity: function move(address src, address dst, uint256 wad) returns()
func (_Token *TokenTransactor) Move(opts *bind.TransactOpts, src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "move", src, dst, wad)
}

// Move is a paid mutator transaction binding the contract method 0xbb35783b.
//
// Solidity: function move(address src, address dst, uint256 wad) returns()
func (_Token *TokenSession) Move(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Move(&_Token.TransactOpts, src, dst, wad)
}

// Move is a paid mutator transaction binding the contract method 0xbb35783b.
//
// Solidity: function move(address src, address dst, uint256 wad) returns()
func (_Token *TokenTransactorSession) Move(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Move(&_Token.TransactOpts, src, dst, wad)
}

// Pull is a paid mutator transaction binding the contract method 0xf2d5d56b.
//
// Solidity: function pull(address src, uint256 wad) returns()
func (_Token *TokenTransactor) Pull(opts *bind.TransactOpts, src common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "pull", src, wad)
}

// Pull is a paid mutator transaction binding the contract method 0xf2d5d56b.
//
// Solidity: function pull(address src, uint256 wad) returns()
func (_Token *TokenSession) Pull(src common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Pull(&_Token.TransactOpts, src, wad)
}

// Pull is a paid mutator transaction binding the contract method 0xf2d5d56b.
//
// Solidity: function pull(address src, uint256 wad) returns()
func (_Token *TokenTransactorSession) Pull(src common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Pull(&_Token.TransactOpts, src, wad)
}

// Push is a paid mutator transaction binding the contract method 0xb753a98c.
//
// Solidity: function push(address dst, uint256 wad) returns()
func (_Token *TokenTransactor) Push(opts *bind.TransactOpts, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "push", dst, wad)
}

// Push is a paid mutator transaction binding the contract method 0xb753a98c.
//
// Solidity: function push(address dst, uint256 wad) returns()
func (_Token *TokenSession) Push(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Push(&_Token.TransactOpts, dst, wad)
}

// Push is a paid mutator transaction binding the contract method 0xb753a98c.
//
// Solidity: function push(address dst, uint256 wad) returns()
func (_Token *TokenTransactorSession) Push(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Push(&_Token.TransactOpts, dst, wad)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Token *TokenTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Token *TokenSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Token.Contract.RevokeOperator(&_Token.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Token *TokenTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Token.Contract.RevokeOperator(&_Token.TransactOpts, _operator)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Token *TokenTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Token *TokenSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Token.Contract.SetAuthority(&_Token.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Token *TokenTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Token.Contract.SetAuthority(&_Token.TransactOpts, authority_)
}

// SetName is a paid mutator transaction binding the contract method 0x5ac801fe.
//
// Solidity: function setName(bytes32 name_) returns()
func (_Token *TokenTransactor) SetName(opts *bind.TransactOpts, name_ [32]byte) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "setName", name_)
}

// SetName is a paid mutator transaction binding the contract method 0x5ac801fe.
//
// Solidity: function setName(bytes32 name_) returns()
func (_Token *TokenSession) SetName(name_ [32]byte) (*types.Transaction, error) {
	return _Token.Contract.SetName(&_Token.TransactOpts, name_)
}

// SetName is a paid mutator transaction binding the contract method 0x5ac801fe.
//
// Solidity: function setName(bytes32 name_) returns()
func (_Token *TokenTransactorSession) SetName(name_ [32]byte) (*types.Transaction, error) {
	return _Token.Contract.SetName(&_Token.TransactOpts, name_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Token *TokenTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Token *TokenSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Token.Contract.SetOwner(&_Token.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Token *TokenTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Token.Contract.SetOwner(&_Token.TransactOpts, owner_)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Token *TokenTransactor) Start(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "start")
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Token *TokenSession) Start() (*types.Transaction, error) {
	return _Token.Contract.Start(&_Token.TransactOpts)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Token *TokenTransactorSession) Start() (*types.Transaction, error) {
	return _Token.Contract.Start(&_Token.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Token *TokenTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Token *TokenSession) Stop() (*types.Transaction, error) {
	return _Token.Contract.Stop(&_Token.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Token *TokenTransactorSession) Stop() (*types.Transaction, error) {
	return _Token.Contract.Stop(&_Token.TransactOpts)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_Token *TokenTransactor) Transfer(opts *bind.TransactOpts, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "transfer", dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_Token *TokenSession) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Transfer(&_Token.TransactOpts, dst, wad)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address dst, uint256 wad) returns(bool)
func (_Token *TokenTransactorSession) Transfer(dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.Transfer(&_Token.TransactOpts, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_Token *TokenTransactor) TransferFrom(opts *bind.TransactOpts, src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.contract.Transact(opts, "transferFrom", src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_Token *TokenSession) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.TransferFrom(&_Token.TransactOpts, src, dst, wad)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address src, address dst, uint256 wad) returns(bool)
func (_Token *TokenTransactorSession) TransferFrom(src common.Address, dst common.Address, wad *big.Int) (*types.Transaction, error) {
	return _Token.Contract.TransferFrom(&_Token.TransactOpts, src, dst, wad)
}

// TokenApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the Token contract.
type TokenApprovalIterator struct {
	Event *TokenApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenApproval represents a Approval event raised by the Token contract.
type TokenApproval struct {
	Src common.Address
	Guy common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed src, address indexed guy, uint256 wad)
func (_Token *TokenFilterer) FilterApproval(opts *bind.FilterOpts, src []common.Address, guy []common.Address) (*TokenApprovalIterator, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}
	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "Approval", srcRule, guyRule)
	if err != nil {
		return nil, err
	}
	return &TokenApprovalIterator{contract: _Token.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed src, address indexed guy, uint256 wad)
func (_Token *TokenFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *TokenApproval, src []common.Address, guy []common.Address) (event.Subscription, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}
	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "Approval", srcRule, guyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenApproval)
				if err := _Token.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed src, address indexed guy, uint256 wad)
func (_Token *TokenFilterer) ParseApproval(log types.Log) (*TokenApproval, error) {
	event := new(TokenApproval)
	if err := _Token.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the Token contract.
type TokenBurnIterator struct {
	Event *TokenBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenBurn represents a Burn event raised by the Token contract.
type TokenBurn struct {
	Guy common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) FilterBurn(opts *bind.FilterOpts, guy []common.Address) (*TokenBurnIterator, error) {

	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "Burn", guyRule)
	if err != nil {
		return nil, err
	}
	return &TokenBurnIterator{contract: _Token.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *TokenBurn, guy []common.Address) (event.Subscription, error) {

	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "Burn", guyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenBurn)
				if err := _Token.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) ParseBurn(log types.Log) (*TokenBurn, error) {
	event := new(TokenBurn)
	if err := _Token.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the Token contract.
type TokenLogSetAuthorityIterator struct {
	Event *TokenLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenLogSetAuthority represents a LogSetAuthority event raised by the Token contract.
type TokenLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Token *TokenFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*TokenLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &TokenLogSetAuthorityIterator{contract: _Token.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Token *TokenFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *TokenLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenLogSetAuthority)
				if err := _Token.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetAuthority is a log parse operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Token *TokenFilterer) ParseLogSetAuthority(log types.Log) (*TokenLogSetAuthority, error) {
	event := new(TokenLogSetAuthority)
	if err := _Token.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the Token contract.
type TokenLogSetOwnerIterator struct {
	Event *TokenLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenLogSetOwner represents a LogSetOwner event raised by the Token contract.
type TokenLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Token *TokenFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*TokenLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &TokenLogSetOwnerIterator{contract: _Token.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Token *TokenFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *TokenLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenLogSetOwner)
				if err := _Token.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetOwner is a log parse operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Token *TokenFilterer) ParseLogSetOwner(log types.Log) (*TokenLogSetOwner, error) {
	event := new(TokenLogSetOwner)
	if err := _Token.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the Token contract.
type TokenMintIterator struct {
	Event *TokenMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMint represents a Mint event raised by the Token contract.
type TokenMint struct {
	Guy common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) FilterMint(opts *bind.FilterOpts, guy []common.Address) (*TokenMintIterator, error) {

	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "Mint", guyRule)
	if err != nil {
		return nil, err
	}
	return &TokenMintIterator{contract: _Token.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *TokenMint, guy []common.Address) (event.Subscription, error) {

	var guyRule []interface{}
	for _, guyItem := range guy {
		guyRule = append(guyRule, guyItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "Mint", guyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMint)
				if err := _Token.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed guy, uint256 wad)
func (_Token *TokenFilterer) ParseMint(log types.Log) (*TokenMint, error) {
	event := new(TokenMint)
	if err := _Token.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenStartIterator is returned from FilterStart and is used to iterate over the raw logs and unpacked data for Start events raised by the Token contract.
type TokenStartIterator struct {
	Event *TokenStart // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenStartIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenStart)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenStart)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenStartIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenStartIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenStart represents a Start event raised by the Token contract.
type TokenStart struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterStart is a free log retrieval operation binding the contract event 0x1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b.
//
// Solidity: event Start()
func (_Token *TokenFilterer) FilterStart(opts *bind.FilterOpts) (*TokenStartIterator, error) {

	logs, sub, err := _Token.contract.FilterLogs(opts, "Start")
	if err != nil {
		return nil, err
	}
	return &TokenStartIterator{contract: _Token.contract, event: "Start", logs: logs, sub: sub}, nil
}

// WatchStart is a free log subscription operation binding the contract event 0x1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b.
//
// Solidity: event Start()
func (_Token *TokenFilterer) WatchStart(opts *bind.WatchOpts, sink chan<- *TokenStart) (event.Subscription, error) {

	logs, sub, err := _Token.contract.WatchLogs(opts, "Start")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenStart)
				if err := _Token.contract.UnpackLog(event, "Start", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStart is a log parse operation binding the contract event 0x1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b.
//
// Solidity: event Start()
func (_Token *TokenFilterer) ParseStart(log types.Log) (*TokenStart, error) {
	event := new(TokenStart)
	if err := _Token.contract.UnpackLog(event, "Start", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenStopIterator is returned from FilterStop and is used to iterate over the raw logs and unpacked data for Stop events raised by the Token contract.
type TokenStopIterator struct {
	Event *TokenStop // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenStopIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenStop)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenStop)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenStopIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenStopIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenStop represents a Stop event raised by the Token contract.
type TokenStop struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterStop is a free log retrieval operation binding the contract event 0xbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b.
//
// Solidity: event Stop()
func (_Token *TokenFilterer) FilterStop(opts *bind.FilterOpts) (*TokenStopIterator, error) {

	logs, sub, err := _Token.contract.FilterLogs(opts, "Stop")
	if err != nil {
		return nil, err
	}
	return &TokenStopIterator{contract: _Token.contract, event: "Stop", logs: logs, sub: sub}, nil
}

// WatchStop is a free log subscription operation binding the contract event 0xbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b.
//
// Solidity: event Stop()
func (_Token *TokenFilterer) WatchStop(opts *bind.WatchOpts, sink chan<- *TokenStop) (event.Subscription, error) {

	logs, sub, err := _Token.contract.WatchLogs(opts, "Stop")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenStop)
				if err := _Token.contract.UnpackLog(event, "Stop", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStop is a log parse operation binding the contract event 0xbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b.
//
// Solidity: event Stop()
func (_Token *TokenFilterer) ParseStop(log types.Log) (*TokenStop, error) {
	event := new(TokenStop)
	if err := _Token.contract.UnpackLog(event, "Stop", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the Token contract.
type TokenTransferIterator struct {
	Event *TokenTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTransfer represents a Transfer event raised by the Token contract.
type TokenTransfer struct {
	Src common.Address
	Dst common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed src, address indexed dst, uint256 wad)
func (_Token *TokenFilterer) FilterTransfer(opts *bind.FilterOpts, src []common.Address, dst []common.Address) (*TokenTransferIterator, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}
	var dstRule []interface{}
	for _, dstItem := range dst {
		dstRule = append(dstRule, dstItem)
	}

	logs, sub, err := _Token.contract.FilterLogs(opts, "Transfer", srcRule, dstRule)
	if err != nil {
		return nil, err
	}
	return &TokenTransferIterator{contract: _Token.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed src, address indexed dst, uint256 wad)
func (_Token *TokenFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *TokenTransfer, src []common.Address, dst []common.Address) (event.Subscription, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}
	var dstRule []interface{}
	for _, dstItem := range dst {
		dstRule = append(dstRule, dstItem)
	}

	logs, sub, err := _Token.contract.WatchLogs(opts, "Transfer", srcRule, dstRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTransfer)
				if err := _Token.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed src, address indexed dst, uint256 wad)
func (_Token *TokenFilterer) ParseTransfer(log types.Log) (*TokenTransfer, error) {
	event := new(TokenTransfer)
	if err := _Token.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenAuthorityABI is the input ABI used to generate the binding from.
const TokenAuthorityABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenAuthorityBin is the compiled bytecode used for deploying new contracts.
var TokenAuthorityBin = "0x608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806108086031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610619806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063b700961314610046578063e348da13146100eb578063fad8b32a1461012f575b600080fd5b6100d16004803603606081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610173565b604051808215151515815260200191505060405180910390f35b61012d6004803603602081101561010157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610279565b005b6101716004803603602081101561014557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506103de565b005b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061021957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61026e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600190509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061031d57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610372576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061048257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6104d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600180541161054e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220e7b320aefb1d184f7676dc65708a2ba5fbb27dfa7b0b34c702cf84c84818fd2c64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployTokenAuthority deploys a new Ethereum contract, binding an instance of TokenAuthority to it.
func DeployTokenAuthority(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TokenAuthority, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenAuthorityABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenAuthorityBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenAuthority{TokenAuthorityCaller: TokenAuthorityCaller{contract: contract}, TokenAuthorityTransactor: TokenAuthorityTransactor{contract: contract}, TokenAuthorityFilterer: TokenAuthorityFilterer{contract: contract}}, nil
}

// TokenAuthority is an auto generated Go binding around an Ethereum contract.
type TokenAuthority struct {
	TokenAuthorityCaller     // Read-only binding to the contract
	TokenAuthorityTransactor // Write-only binding to the contract
	TokenAuthorityFilterer   // Log filterer for contract events
}

// TokenAuthorityCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenAuthorityCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenAuthorityTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenAuthorityTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenAuthorityFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenAuthorityFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenAuthoritySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenAuthoritySession struct {
	Contract     *TokenAuthority   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenAuthorityCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenAuthorityCallerSession struct {
	Contract *TokenAuthorityCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// TokenAuthorityTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenAuthorityTransactorSession struct {
	Contract     *TokenAuthorityTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// TokenAuthorityRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenAuthorityRaw struct {
	Contract *TokenAuthority // Generic contract binding to access the raw methods on
}

// TokenAuthorityCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenAuthorityCallerRaw struct {
	Contract *TokenAuthorityCaller // Generic read-only contract binding to access the raw methods on
}

// TokenAuthorityTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenAuthorityTransactorRaw struct {
	Contract *TokenAuthorityTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenAuthority creates a new instance of TokenAuthority, bound to a specific deployed contract.
func NewTokenAuthority(address common.Address, backend bind.ContractBackend) (*TokenAuthority, error) {
	contract, err := bindTokenAuthority(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenAuthority{TokenAuthorityCaller: TokenAuthorityCaller{contract: contract}, TokenAuthorityTransactor: TokenAuthorityTransactor{contract: contract}, TokenAuthorityFilterer: TokenAuthorityFilterer{contract: contract}}, nil
}

// NewTokenAuthorityCaller creates a new read-only instance of TokenAuthority, bound to a specific deployed contract.
func NewTokenAuthorityCaller(address common.Address, caller bind.ContractCaller) (*TokenAuthorityCaller, error) {
	contract, err := bindTokenAuthority(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenAuthorityCaller{contract: contract}, nil
}

// NewTokenAuthorityTransactor creates a new write-only instance of TokenAuthority, bound to a specific deployed contract.
func NewTokenAuthorityTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenAuthorityTransactor, error) {
	contract, err := bindTokenAuthority(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenAuthorityTransactor{contract: contract}, nil
}

// NewTokenAuthorityFilterer creates a new log filterer instance of TokenAuthority, bound to a specific deployed contract.
func NewTokenAuthorityFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenAuthorityFilterer, error) {
	contract, err := bindTokenAuthority(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenAuthorityFilterer{contract: contract}, nil
}

// bindTokenAuthority binds a generic wrapper to an already deployed contract.
func bindTokenAuthority(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenAuthorityABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenAuthority *TokenAuthorityRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenAuthority.Contract.TokenAuthorityCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenAuthority *TokenAuthorityRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenAuthority.Contract.TokenAuthorityTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenAuthority *TokenAuthorityRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenAuthority.Contract.TokenAuthorityTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenAuthority *TokenAuthorityCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenAuthority.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenAuthority *TokenAuthorityTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenAuthority.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenAuthority *TokenAuthorityTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenAuthority.Contract.contract.Transact(opts, method, params...)
}

// CanCall is a free data retrieval call binding the contract method 0xb7009613.
//
// Solidity: function canCall(address , address , bytes4 ) view returns(bool)
func (_TokenAuthority *TokenAuthorityCaller) CanCall(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address, arg2 [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _TokenAuthority.contract.Call(opts, out, "canCall", arg0, arg1, arg2)
	return *ret0, err
}

// CanCall is a free data retrieval call binding the contract method 0xb7009613.
//
// Solidity: function canCall(address , address , bytes4 ) view returns(bool)
func (_TokenAuthority *TokenAuthoritySession) CanCall(arg0 common.Address, arg1 common.Address, arg2 [4]byte) (bool, error) {
	return _TokenAuthority.Contract.CanCall(&_TokenAuthority.CallOpts, arg0, arg1, arg2)
}

// CanCall is a free data retrieval call binding the contract method 0xb7009613.
//
// Solidity: function canCall(address , address , bytes4 ) view returns(bool)
func (_TokenAuthority *TokenAuthorityCallerSession) CanCall(arg0 common.Address, arg1 common.Address, arg2 [4]byte) (bool, error) {
	return _TokenAuthority.Contract.CanCall(&_TokenAuthority.CallOpts, arg0, arg1, arg2)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthorityTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthoritySession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.Contract.GrantOperator(&_TokenAuthority.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthorityTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.Contract.GrantOperator(&_TokenAuthority.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthorityTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthoritySession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.Contract.RevokeOperator(&_TokenAuthority.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenAuthority *TokenAuthorityTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenAuthority.Contract.RevokeOperator(&_TokenAuthority.TransactOpts, _operator)
}

// TokenMigratorABI is the input ABI used to generate the binding from.
const TokenMigratorABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Stopped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenMigratorBin is the compiled bytecode used for deploying new contracts.
var TokenMigratorBin = "0x608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806116566031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b611467806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c80634a77f8701161005b5780634a77f87014610173578063afa293d41461017d578063e348da13146101c7578063fad8b32a1461020b57610088565b806307da68f51461008d57806316ad9542146100975780633ccfe887146100e1578063454b060814610145575b600080fd5b61009561024f565b005b61009f6104ce565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610143600480360360408110156100f757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506104f8565b005b6101716004803603602081101561015b57600080fd5b810190808035906020019092919050505061089c565b005b61017b6108a9565b005b610185610b3b565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610209600480360360208110156101dd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b65565b005b61024d6004803603602081101561022157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cca565b005b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806102f357506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610348576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b600260149054906101000a900460ff166103ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d6967726174696f6e206e6f742073746172746564000000000000000000000081525060200191505060405180910390fd5b6000600260146101000a81548160ff0219169083151502179055506000600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b33604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1565b6000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061059c57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6105f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b6105fa82610e9e565b61064f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260448152602001806113746044913960600191505060405180910390fd5b61065881610e9e565b6106ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260498152602001806113b86049913960600191505060405180910390fd5b600260149054906101000a900460ff1615610730576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f6d6967726174696f6e2068617320616c7265616479207374617274656400000081525060200191505060405180910390fd5b6001600260146101000a81548160ff02191690831515021790555081600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d828233604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001935050505060405180910390a15050565b6108a63382611021565b50565b60003390506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561094f57600080fd5b505afa158015610963573d6000803e3d6000fd5b505050506040513d602081101561097957600080fd5b810190808051906020019092919050505090506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd62ed3e84306040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060206040518083038186803b158015610a6157600080fd5b505afa158015610a75573d6000803e3d6000fd5b505050506040513d6020811015610a8b57600080fd5b810190808051906020019092919050505090506000610ab3838361135990919063ffffffff16565b905060008111610b2b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f6e6f20746f6b656e7320617661696c61626c6520746f206d696772617465000081525060200191505060405180910390fd5b610b358482611021565b50505050565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610c0957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610c5e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610d6e57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610dc3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b6001805411610e3a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556001600081548092919060019003919050555050565b60008060608373ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f18160ddd000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310610f705780518252602082019150602081019050602083039250610f4d565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610fd2576040519150601f19603f3d011682016040523d82523d6000602084013e610fd7565b606091505b5080925081935050506000818060200190516020811015610ff757600080fd5b810190808051906020019092919050505090508280156110175750600081115b9350505050919050565b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661112e576003339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8330846040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b15801561125857600080fd5b505af115801561126c573d6000803e3d6000fd5b505050506040513d602081101561128257600080fd5b810190808051906020019092919050505050600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166340c10f1983836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561133d57600080fd5b505af1158015611351573d6000803e3d6000fd5b505050505050565b600081831115611369578161136b565b825b90509291505056fe736f7572636520646f6573206e6f742061707065617220746f20626520616e20455243323020286661696c65642063616c6c20746f20746f74616c537570706c7928292964657374696e6174696f6e20646f6573206e6f742061707065617220746f20626520616e20455243323020286661696c65642063616c6c20746f20746f74616c537570706c7928292946756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220b36d01680096486c656c5b2a1ef6fe000f1d4e6e6c848913e0a846a6b261419b64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployTokenMigrator deploys a new Ethereum contract, binding an instance of TokenMigrator to it.
func DeployTokenMigrator(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TokenMigrator, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenMigratorBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenMigrator{TokenMigratorCaller: TokenMigratorCaller{contract: contract}, TokenMigratorTransactor: TokenMigratorTransactor{contract: contract}, TokenMigratorFilterer: TokenMigratorFilterer{contract: contract}}, nil
}

// TokenMigrator is an auto generated Go binding around an Ethereum contract.
type TokenMigrator struct {
	TokenMigratorCaller     // Read-only binding to the contract
	TokenMigratorTransactor // Write-only binding to the contract
	TokenMigratorFilterer   // Log filterer for contract events
}

// TokenMigratorCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenMigratorCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenMigratorTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenMigratorFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenMigratorSession struct {
	Contract     *TokenMigrator    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenMigratorCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenMigratorCallerSession struct {
	Contract *TokenMigratorCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// TokenMigratorTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenMigratorTransactorSession struct {
	Contract     *TokenMigratorTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// TokenMigratorRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenMigratorRaw struct {
	Contract *TokenMigrator // Generic contract binding to access the raw methods on
}

// TokenMigratorCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenMigratorCallerRaw struct {
	Contract *TokenMigratorCaller // Generic read-only contract binding to access the raw methods on
}

// TokenMigratorTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenMigratorTransactorRaw struct {
	Contract *TokenMigratorTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenMigrator creates a new instance of TokenMigrator, bound to a specific deployed contract.
func NewTokenMigrator(address common.Address, backend bind.ContractBackend) (*TokenMigrator, error) {
	contract, err := bindTokenMigrator(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenMigrator{TokenMigratorCaller: TokenMigratorCaller{contract: contract}, TokenMigratorTransactor: TokenMigratorTransactor{contract: contract}, TokenMigratorFilterer: TokenMigratorFilterer{contract: contract}}, nil
}

// NewTokenMigratorCaller creates a new read-only instance of TokenMigrator, bound to a specific deployed contract.
func NewTokenMigratorCaller(address common.Address, caller bind.ContractCaller) (*TokenMigratorCaller, error) {
	contract, err := bindTokenMigrator(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorCaller{contract: contract}, nil
}

// NewTokenMigratorTransactor creates a new write-only instance of TokenMigrator, bound to a specific deployed contract.
func NewTokenMigratorTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenMigratorTransactor, error) {
	contract, err := bindTokenMigrator(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTransactor{contract: contract}, nil
}

// NewTokenMigratorFilterer creates a new log filterer instance of TokenMigrator, bound to a specific deployed contract.
func NewTokenMigratorFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenMigratorFilterer, error) {
	contract, err := bindTokenMigrator(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorFilterer{contract: contract}, nil
}

// bindTokenMigrator binds a generic wrapper to an already deployed contract.
func bindTokenMigrator(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigrator *TokenMigratorRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigrator.Contract.TokenMigratorCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigrator *TokenMigratorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigrator.Contract.TokenMigratorTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigrator *TokenMigratorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigrator.Contract.TokenMigratorTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigrator *TokenMigratorCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigrator.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigrator *TokenMigratorTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigrator.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigrator *TokenMigratorTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigrator.Contract.contract.Transact(opts, method, params...)
}

// GetDestination is a free data retrieval call binding the contract method 0x16ad9542.
//
// Solidity: function getDestination() view returns(address)
func (_TokenMigrator *TokenMigratorCaller) GetDestination(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _TokenMigrator.contract.Call(opts, out, "getDestination")
	return *ret0, err
}

// GetDestination is a free data retrieval call binding the contract method 0x16ad9542.
//
// Solidity: function getDestination() view returns(address)
func (_TokenMigrator *TokenMigratorSession) GetDestination() (common.Address, error) {
	return _TokenMigrator.Contract.GetDestination(&_TokenMigrator.CallOpts)
}

// GetDestination is a free data retrieval call binding the contract method 0x16ad9542.
//
// Solidity: function getDestination() view returns(address)
func (_TokenMigrator *TokenMigratorCallerSession) GetDestination() (common.Address, error) {
	return _TokenMigrator.Contract.GetDestination(&_TokenMigrator.CallOpts)
}

// GetSource is a free data retrieval call binding the contract method 0xafa293d4.
//
// Solidity: function getSource() view returns(address)
func (_TokenMigrator *TokenMigratorCaller) GetSource(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _TokenMigrator.contract.Call(opts, out, "getSource")
	return *ret0, err
}

// GetSource is a free data retrieval call binding the contract method 0xafa293d4.
//
// Solidity: function getSource() view returns(address)
func (_TokenMigrator *TokenMigratorSession) GetSource() (common.Address, error) {
	return _TokenMigrator.Contract.GetSource(&_TokenMigrator.CallOpts)
}

// GetSource is a free data retrieval call binding the contract method 0xafa293d4.
//
// Solidity: function getSource() view returns(address)
func (_TokenMigrator *TokenMigratorCallerSession) GetSource() (common.Address, error) {
	return _TokenMigrator.Contract.GetSource(&_TokenMigrator.CallOpts)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.GrantOperator(&_TokenMigrator.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.GrantOperator(&_TokenMigrator.TransactOpts, _operator)
}

// Migrate is a paid mutator transaction binding the contract method 0x454b0608.
//
// Solidity: function migrate(uint256 amount) returns()
func (_TokenMigrator *TokenMigratorTransactor) Migrate(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "migrate", amount)
}

// Migrate is a paid mutator transaction binding the contract method 0x454b0608.
//
// Solidity: function migrate(uint256 amount) returns()
func (_TokenMigrator *TokenMigratorSession) Migrate(amount *big.Int) (*types.Transaction, error) {
	return _TokenMigrator.Contract.Migrate(&_TokenMigrator.TransactOpts, amount)
}

// Migrate is a paid mutator transaction binding the contract method 0x454b0608.
//
// Solidity: function migrate(uint256 amount) returns()
func (_TokenMigrator *TokenMigratorTransactorSession) Migrate(amount *big.Int) (*types.Transaction, error) {
	return _TokenMigrator.Contract.Migrate(&_TokenMigrator.TransactOpts, amount)
}

// MigrateAll is a paid mutator transaction binding the contract method 0x4a77f870.
//
// Solidity: function migrateAll() returns()
func (_TokenMigrator *TokenMigratorTransactor) MigrateAll(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "migrateAll")
}

// MigrateAll is a paid mutator transaction binding the contract method 0x4a77f870.
//
// Solidity: function migrateAll() returns()
func (_TokenMigrator *TokenMigratorSession) MigrateAll() (*types.Transaction, error) {
	return _TokenMigrator.Contract.MigrateAll(&_TokenMigrator.TransactOpts)
}

// MigrateAll is a paid mutator transaction binding the contract method 0x4a77f870.
//
// Solidity: function migrateAll() returns()
func (_TokenMigrator *TokenMigratorTransactorSession) MigrateAll() (*types.Transaction, error) {
	return _TokenMigrator.Contract.MigrateAll(&_TokenMigrator.TransactOpts)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.RevokeOperator(&_TokenMigrator.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_TokenMigrator *TokenMigratorTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.RevokeOperator(&_TokenMigrator.TransactOpts, _operator)
}

// Start is a paid mutator transaction binding the contract method 0x3ccfe887.
//
// Solidity: function start(address src, address dst) returns()
func (_TokenMigrator *TokenMigratorTransactor) Start(opts *bind.TransactOpts, src common.Address, dst common.Address) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "start", src, dst)
}

// Start is a paid mutator transaction binding the contract method 0x3ccfe887.
//
// Solidity: function start(address src, address dst) returns()
func (_TokenMigrator *TokenMigratorSession) Start(src common.Address, dst common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.Start(&_TokenMigrator.TransactOpts, src, dst)
}

// Start is a paid mutator transaction binding the contract method 0x3ccfe887.
//
// Solidity: function start(address src, address dst) returns()
func (_TokenMigrator *TokenMigratorTransactorSession) Start(src common.Address, dst common.Address) (*types.Transaction, error) {
	return _TokenMigrator.Contract.Start(&_TokenMigrator.TransactOpts, src, dst)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_TokenMigrator *TokenMigratorTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigrator.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_TokenMigrator *TokenMigratorSession) Stop() (*types.Transaction, error) {
	return _TokenMigrator.Contract.Stop(&_TokenMigrator.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_TokenMigrator *TokenMigratorTransactorSession) Stop() (*types.Transaction, error) {
	return _TokenMigrator.Contract.Stop(&_TokenMigrator.TransactOpts)
}

// TokenMigratorStartedIterator is returned from FilterStarted and is used to iterate over the raw logs and unpacked data for Started events raised by the TokenMigrator contract.
type TokenMigratorStartedIterator struct {
	Event *TokenMigratorStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorStarted represents a Started event raised by the TokenMigrator contract.
type TokenMigratorStarted struct {
	Source      common.Address
	Destination common.Address
	Who         common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterStarted is a free log retrieval operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigrator *TokenMigratorFilterer) FilterStarted(opts *bind.FilterOpts) (*TokenMigratorStartedIterator, error) {

	logs, sub, err := _TokenMigrator.contract.FilterLogs(opts, "Started")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorStartedIterator{contract: _TokenMigrator.contract, event: "Started", logs: logs, sub: sub}, nil
}

// WatchStarted is a free log subscription operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigrator *TokenMigratorFilterer) WatchStarted(opts *bind.WatchOpts, sink chan<- *TokenMigratorStarted) (event.Subscription, error) {

	logs, sub, err := _TokenMigrator.contract.WatchLogs(opts, "Started")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorStarted)
				if err := _TokenMigrator.contract.UnpackLog(event, "Started", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStarted is a log parse operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigrator *TokenMigratorFilterer) ParseStarted(log types.Log) (*TokenMigratorStarted, error) {
	event := new(TokenMigratorStarted)
	if err := _TokenMigrator.contract.UnpackLog(event, "Started", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorStoppedIterator is returned from FilterStopped and is used to iterate over the raw logs and unpacked data for Stopped events raised by the TokenMigrator contract.
type TokenMigratorStoppedIterator struct {
	Event *TokenMigratorStopped // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorStoppedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorStopped)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorStopped)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorStoppedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorStoppedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorStopped represents a Stopped event raised by the TokenMigrator contract.
type TokenMigratorStopped struct {
	Who common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterStopped is a free log retrieval operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigrator *TokenMigratorFilterer) FilterStopped(opts *bind.FilterOpts) (*TokenMigratorStoppedIterator, error) {

	logs, sub, err := _TokenMigrator.contract.FilterLogs(opts, "Stopped")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorStoppedIterator{contract: _TokenMigrator.contract, event: "Stopped", logs: logs, sub: sub}, nil
}

// WatchStopped is a free log subscription operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigrator *TokenMigratorFilterer) WatchStopped(opts *bind.WatchOpts, sink chan<- *TokenMigratorStopped) (event.Subscription, error) {

	logs, sub, err := _TokenMigrator.contract.WatchLogs(opts, "Stopped")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorStopped)
				if err := _TokenMigrator.contract.UnpackLog(event, "Stopped", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStopped is a log parse operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigrator *TokenMigratorFilterer) ParseStopped(log types.Log) (*TokenMigratorStopped, error) {
	event := new(TokenMigratorStopped)
	if err := _TokenMigrator.contract.UnpackLog(event, "Stopped", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorEventsABI is the input ABI used to generate the binding from.
const TokenMigratorEventsABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Stopped\",\"type\":\"event\"}]"

// TokenMigratorEventsBin is the compiled bytecode used for deploying new contracts.
var TokenMigratorEventsBin = "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122076c41fa86493dde1d768a5bd783183d0692da953ed8a9f104c1edefb158793f864736f6c63430006070033"

// DeployTokenMigratorEvents deploys a new Ethereum contract, binding an instance of TokenMigratorEvents to it.
func DeployTokenMigratorEvents(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TokenMigratorEvents, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorEventsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenMigratorEventsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenMigratorEvents{TokenMigratorEventsCaller: TokenMigratorEventsCaller{contract: contract}, TokenMigratorEventsTransactor: TokenMigratorEventsTransactor{contract: contract}, TokenMigratorEventsFilterer: TokenMigratorEventsFilterer{contract: contract}}, nil
}

// TokenMigratorEvents is an auto generated Go binding around an Ethereum contract.
type TokenMigratorEvents struct {
	TokenMigratorEventsCaller     // Read-only binding to the contract
	TokenMigratorEventsTransactor // Write-only binding to the contract
	TokenMigratorEventsFilterer   // Log filterer for contract events
}

// TokenMigratorEventsCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenMigratorEventsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorEventsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenMigratorEventsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorEventsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenMigratorEventsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorEventsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenMigratorEventsSession struct {
	Contract     *TokenMigratorEvents // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// TokenMigratorEventsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenMigratorEventsCallerSession struct {
	Contract *TokenMigratorEventsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// TokenMigratorEventsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenMigratorEventsTransactorSession struct {
	Contract     *TokenMigratorEventsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// TokenMigratorEventsRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenMigratorEventsRaw struct {
	Contract *TokenMigratorEvents // Generic contract binding to access the raw methods on
}

// TokenMigratorEventsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenMigratorEventsCallerRaw struct {
	Contract *TokenMigratorEventsCaller // Generic read-only contract binding to access the raw methods on
}

// TokenMigratorEventsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenMigratorEventsTransactorRaw struct {
	Contract *TokenMigratorEventsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenMigratorEvents creates a new instance of TokenMigratorEvents, bound to a specific deployed contract.
func NewTokenMigratorEvents(address common.Address, backend bind.ContractBackend) (*TokenMigratorEvents, error) {
	contract, err := bindTokenMigratorEvents(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEvents{TokenMigratorEventsCaller: TokenMigratorEventsCaller{contract: contract}, TokenMigratorEventsTransactor: TokenMigratorEventsTransactor{contract: contract}, TokenMigratorEventsFilterer: TokenMigratorEventsFilterer{contract: contract}}, nil
}

// NewTokenMigratorEventsCaller creates a new read-only instance of TokenMigratorEvents, bound to a specific deployed contract.
func NewTokenMigratorEventsCaller(address common.Address, caller bind.ContractCaller) (*TokenMigratorEventsCaller, error) {
	contract, err := bindTokenMigratorEvents(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEventsCaller{contract: contract}, nil
}

// NewTokenMigratorEventsTransactor creates a new write-only instance of TokenMigratorEvents, bound to a specific deployed contract.
func NewTokenMigratorEventsTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenMigratorEventsTransactor, error) {
	contract, err := bindTokenMigratorEvents(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEventsTransactor{contract: contract}, nil
}

// NewTokenMigratorEventsFilterer creates a new log filterer instance of TokenMigratorEvents, bound to a specific deployed contract.
func NewTokenMigratorEventsFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenMigratorEventsFilterer, error) {
	contract, err := bindTokenMigratorEvents(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEventsFilterer{contract: contract}, nil
}

// bindTokenMigratorEvents binds a generic wrapper to an already deployed contract.
func bindTokenMigratorEvents(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorEventsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigratorEvents *TokenMigratorEventsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigratorEvents.Contract.TokenMigratorEventsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigratorEvents *TokenMigratorEventsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorEvents.Contract.TokenMigratorEventsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigratorEvents *TokenMigratorEventsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigratorEvents.Contract.TokenMigratorEventsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigratorEvents *TokenMigratorEventsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigratorEvents.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigratorEvents *TokenMigratorEventsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorEvents.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigratorEvents *TokenMigratorEventsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigratorEvents.Contract.contract.Transact(opts, method, params...)
}

// TokenMigratorEventsStartedIterator is returned from FilterStarted and is used to iterate over the raw logs and unpacked data for Started events raised by the TokenMigratorEvents contract.
type TokenMigratorEventsStartedIterator struct {
	Event *TokenMigratorEventsStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorEventsStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorEventsStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorEventsStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorEventsStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorEventsStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorEventsStarted represents a Started event raised by the TokenMigratorEvents contract.
type TokenMigratorEventsStarted struct {
	Source      common.Address
	Destination common.Address
	Who         common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterStarted is a free log retrieval operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) FilterStarted(opts *bind.FilterOpts) (*TokenMigratorEventsStartedIterator, error) {

	logs, sub, err := _TokenMigratorEvents.contract.FilterLogs(opts, "Started")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEventsStartedIterator{contract: _TokenMigratorEvents.contract, event: "Started", logs: logs, sub: sub}, nil
}

// WatchStarted is a free log subscription operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) WatchStarted(opts *bind.WatchOpts, sink chan<- *TokenMigratorEventsStarted) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorEvents.contract.WatchLogs(opts, "Started")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorEventsStarted)
				if err := _TokenMigratorEvents.contract.UnpackLog(event, "Started", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStarted is a log parse operation binding the contract event 0xe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d.
//
// Solidity: event Started(address source, address destination, address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) ParseStarted(log types.Log) (*TokenMigratorEventsStarted, error) {
	event := new(TokenMigratorEventsStarted)
	if err := _TokenMigratorEvents.contract.UnpackLog(event, "Started", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorEventsStoppedIterator is returned from FilterStopped and is used to iterate over the raw logs and unpacked data for Stopped events raised by the TokenMigratorEvents contract.
type TokenMigratorEventsStoppedIterator struct {
	Event *TokenMigratorEventsStopped // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorEventsStoppedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorEventsStopped)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorEventsStopped)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorEventsStoppedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorEventsStoppedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorEventsStopped represents a Stopped event raised by the TokenMigratorEvents contract.
type TokenMigratorEventsStopped struct {
	Who common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterStopped is a free log retrieval operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) FilterStopped(opts *bind.FilterOpts) (*TokenMigratorEventsStoppedIterator, error) {

	logs, sub, err := _TokenMigratorEvents.contract.FilterLogs(opts, "Stopped")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorEventsStoppedIterator{contract: _TokenMigratorEvents.contract, event: "Stopped", logs: logs, sub: sub}, nil
}

// WatchStopped is a free log subscription operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) WatchStopped(opts *bind.WatchOpts, sink chan<- *TokenMigratorEventsStopped) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorEvents.contract.WatchLogs(opts, "Stopped")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorEventsStopped)
				if err := _TokenMigratorEvents.contract.UnpackLog(event, "Stopped", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStopped is a log parse operation binding the contract event 0x55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b.
//
// Solidity: event Stopped(address who)
func (_TokenMigratorEvents *TokenMigratorEventsFilterer) ParseStopped(log types.Log) (*TokenMigratorEventsStopped, error) {
	event := new(TokenMigratorEventsStopped)
	if err := _TokenMigratorEvents.contract.UnpackLog(event, "Stopped", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestABI is the input ABI used to generate the binding from.
const TokenMigratorTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailMigrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailMigrateAllUnapproved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailStartDouble\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailStartInvalidToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testMigrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testMigrateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testMigrateAllSupplyIncrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenMigratorTestBin is the compiled bytecode used for deploying new contracts.
var TokenMigratorTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b50617f7b8061003a6000396000f3fe60806040523480156200001157600080fd5b5060043610620000e25760003560e01c806396b2833e1162000099578063da34e901116200006f578063da34e901146200016b578063e34323b81462000177578063f89eae171462000183578063fa7626d4146200018f57620000e2565b806396b2833e146200012f578063ba414fa6146200013b578063c84c2c14146200015f57620000e2565b80630a9254e414620000e75780631a83894c14620000f357806331e876f114620000ff57806343ab1a34146200010b578063538bec1614620001175780637a3867d31462000123575b600080fd5b620000f1620001b3565b005b620000fd620005f4565b005b6200010962000aaf565b005b6200011562000b8e565b005b6200012162000ca1565b005b6200012d6200141e565b005b6200013962001ba7565b005b6200014562001de4565b604051808215151515815260200191505060405180910390f35b6200016962001df7565b005b6200017562002122565b005b620001816200238a565b005b6200018d620024bf565b005b6200019962002678565b604051808215151515815260200191505060405180910390f35b604051620001c190620027ea565b604051809103906000f080158015620001de573d6000803e3d6000fd5b50600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040516200022d90620027f8565b80807f5352430000000000000000000000000000000000000000000000000000000000815250602001807f536f7572636500000000000000000000000000000000000000000000000000008152506020019050604051809103906000f0801580156200029d573d6000803e3d6000fd5b50600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550604051620002ec90620027f8565b80807f4453540000000000000000000000000000000000000000000000000000000000815250602001807f44657374696e6174696f6e0000000000000000000000000000000000000000008152506020019050604051809103906000f0801580156200035c573d6000803e3d6000fd5b50600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156200046157600080fd5b505af115801562000476573d6000803e3d6000fd5b50505050604051620004889062002806565b604051809103906000f080158015620004a5573d6000803e3d6000fd5b50600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166104d26040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015620005b457600080fd5b505af1158015620005c9573d6000803e3d6000fd5b505050506040513d6020811015620005e057600080fd5b810190808051906020019092919050505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b1580156200070e57600080fd5b505af115801562000723573d6000803e3d6000fd5b505050506000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156200079257600080fd5b505afa158015620007a7573d6000803e3d6000fd5b505050506040513d6020811015620007be57600080fd5b81019080805190602001909291905050509050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e1f21c67600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166104d26040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b158015620008f557600080fd5b505af11580156200090a573d6000803e3d6000fd5b50505050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635a8cadb1600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015620009d257600080fd5b505af1158015620009e7573d6000803e3d6000fd5b505050506000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801562000a5657600080fd5b505afa15801562000a6b573d6000803e3d6000fd5b505050506040513d602081101562000a8257600080fd5b8101908080519060200190929190505050905060006104d28301905062000aaa82826200268a565b505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635a8cadb1600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801562000b7357600080fd5b505af115801562000b88573d6000803e3d6000fd5b50505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16306040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b15801562000c8657600080fd5b505af115801562000c9b573d6000803e3d6000fd5b50505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b15801562000dbb57600080fd5b505af115801562000dd0573d6000803e3d6000fd5b5050505062000ee0600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801562000e9a57600080fd5b505afa15801562000eaf573d6000803e3d6000fd5b505050506040513d602081101562000ec657600080fd5b81019080805190602001909291905050506104d26200268a565b62000feb600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801562000fa657600080fd5b505afa15801562000fbb573d6000803e3d6000fd5b505050506040513d602081101562000fd257600080fd5b810190808051906020019092919050505060006200268a565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e1f21c67600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166104d26040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b1580156200110f57600080fd5b505af115801562001124573d6000803e3d6000fd5b50505050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635a8cadb1600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015620011ec57600080fd5b505af115801562001201573d6000803e3d6000fd5b5050505062001310600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015620012cb57600080fd5b505afa158015620012e0573d6000803e3d6000fd5b505050506040513d6020811015620012f757600080fd5b810190808051906020019092919050505060006200268a565b6200141c600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015620013d657600080fd5b505afa158015620013eb573d6000803e3d6000fd5b505050506040513d60208110156200140257600080fd5b81019080805190602001909291905050506104d26200268a565b565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b1580156200153857600080fd5b505af11580156200154d573d6000803e3d6000fd5b505050506200165d600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156200161757600080fd5b505afa1580156200162c573d6000803e3d6000fd5b505050506040513d60208110156200164357600080fd5b81019080805190602001909291905050506104d26200268a565b62001768600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156200172357600080fd5b505afa15801562001738573d6000803e3d6000fd5b505050506040513d60208110156200174f57600080fd5b810190808051906020019092919050505060006200268a565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e1f21c67600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff166104d26040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b1580156200188c57600080fd5b505af1158015620018a1573d6000803e3d6000fd5b50505050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ad68ebf7600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660056040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156200197257600080fd5b505af115801562001987573d6000803e3d6000fd5b5050505062001a9a600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801562001a5157600080fd5b505afa15801562001a66573d6000803e3d6000fd5b505050506040513d602081101562001a7d57600080fd5b810190808051906020019092919050505060056104d2036200268a565b62001ba5600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801562001b6057600080fd5b505afa15801562001b75573d6000803e3d6000fd5b505050506040513d602081101562001b8c57600080fd5b810190808051906020019092919050505060056200268a565b565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b15801562001cc157600080fd5b505af115801562001cd6573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166307da68f56040518163ffffffff1660e01b8152600401600060405180830381600087803b15801562001d4557600080fd5b505af115801562001d5a573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166307da68f56040518163ffffffff1660e01b8152600401600060405180830381600087803b15801562001dc957600080fd5b505af115801562001dde573d6000803e3d6000fd5b50505050565b600060019054906101000a900460ff1681565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b15801562001f1157600080fd5b505af115801562001f26573d6000803e3d6000fd5b5050505062002036600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801562001ff057600080fd5b505afa15801562002005573d6000803e3d6000fd5b505050506040513d60208110156200201c57600080fd5b81019080805190602001909291905050506104d26200268a565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ad68ebf7600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660026104d2026040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156200210757600080fd5b505af11580156200211c573d6000803e3d6000fd5b50505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b1580156200223c57600080fd5b505af115801562002251573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b1580156200236f57600080fd5b505af115801562002384573d6000803e3d6000fd5b50505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b158015620024a457600080fd5b505af1158015620024b9573d6000803e3d6000fd5b50505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633ccfe887600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b158015620025d957600080fd5b505af1158015620025ee573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166307da68f56040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156200265d57600080fd5b505af115801562002672573d6000803e3d6000fd5b50505050565b6000809054906101000a900460ff1681565b808214620027c9577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405180806020018281038252602281526020018062007f246022913960400191505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88160405180806020018381526020018281038252600a8152602001807f20204578706563746564000000000000000000000000000000000000000000008152506020019250505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88260405180806020018381526020018281038252600a8152602001807f2020202041637475616c000000000000000000000000000000000000000000008152506020019250505060405180910390a1620027c8620027cd565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b611687806200281583390190565b613d528062003e9c83390190565b6103368062007bee8339019056fe608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806116566031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b611467806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c80634a77f8701161005b5780634a77f87014610173578063afa293d41461017d578063e348da13146101c7578063fad8b32a1461020b57610088565b806307da68f51461008d57806316ad9542146100975780633ccfe887146100e1578063454b060814610145575b600080fd5b61009561024f565b005b61009f6104ce565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610143600480360360408110156100f757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506104f8565b005b6101716004803603602081101561015b57600080fd5b810190808035906020019092919050505061089c565b005b61017b6108a9565b005b610185610b3b565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610209600480360360208110156101dd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b65565b005b61024d6004803603602081101561022157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cca565b005b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806102f357506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610348576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b600260149054906101000a900460ff166103ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d6967726174696f6e206e6f742073746172746564000000000000000000000081525060200191505060405180910390fd5b6000600260146101000a81548160ff0219169083151502179055506000600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f55c4adf1f68f084b809304657594a92ba835ada8d3b5340955bf05746723c05b33604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1565b6000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061059c57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6105f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b6105fa82610e9e565b61064f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260448152602001806113746044913960600191505060405180910390fd5b61065881610e9e565b6106ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260498152602001806113b86049913960600191505060405180910390fd5b600260149054906101000a900460ff1615610730576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f6d6967726174696f6e2068617320616c7265616479207374617274656400000081525060200191505060405180910390fd5b6001600260146101000a81548160ff02191690831515021790555081600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fe7ccbdddf2d84fab545fb1aad35fd684ef7cce1df6df25facfb32fe3de037f1d828233604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001935050505060405180910390a15050565b6108a63382611021565b50565b60003390506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561094f57600080fd5b505afa158015610963573d6000803e3d6000fd5b505050506040513d602081101561097957600080fd5b810190808051906020019092919050505090506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663dd62ed3e84306040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060206040518083038186803b158015610a6157600080fd5b505afa158015610a75573d6000803e3d6000fd5b505050506040513d6020811015610a8b57600080fd5b810190808051906020019092919050505090506000610ab3838361135990919063ffffffff16565b905060008111610b2b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f6e6f20746f6b656e7320617661696c61626c6520746f206d696772617465000081525060200191505060405180910390fd5b610b358482611021565b50505050565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610c0957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610c5e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610d6e57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610dc3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806114016031913960400191505060405180910390fd5b6001805411610e3a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556001600081548092919060019003919050555050565b60008060608373ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f18160ddd000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310610f705780518252602082019150602081019050602083039250610f4d565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610fd2576040519150601f19603f3d011682016040523d82523d6000602084013e610fd7565b606091505b5080925081935050506000818060200190516020811015610ff757600080fd5b810190808051906020019092919050505090508280156110175750600081115b9350505050919050565b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661112e576003339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8330846040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b15801561125857600080fd5b505af115801561126c573d6000803e3d6000fd5b505050506040513d602081101561128257600080fd5b810190808051906020019092919050505050600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166340c10f1983836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561133d57600080fd5b505af1158015611351573d6000803e3d6000fd5b505050505050565b600081831115611369578161136b565b825b90509291505056fe736f7572636520646f6573206e6f742061707065617220746f20626520616e20455243323020286661696c65642063616c6c20746f20746f74616c537570706c7928292964657374696e6174696f6e20646f6573206e6f742061707065617220746f20626520616e20455243323020286661696c65642063616c6c20746f20746f74616c537570706c7928292946756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220b36d01680096486c656c5b2a1ef6fe000f1d4e6e6c848913e0a846a6b261419b64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e6080604052601260065560006007556040516200001c9062000c8b565b604051809103906000f08015801562000039573d6000803e3d6000fd5b50600b60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156200008757600080fd5b5060405162003d5238038062003d5283398181016040526040811015620000ad57600080fd5b8101908080519060200190929190805190602001909291905050508133600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a2806005819055505033600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550620001c9600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620002ed60201b60201c565b620001fc600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620004be60201b60201c565b80600781905550600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13336040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015620002a557600080fd5b505af1158015620002ba573d6000803e3d6000fd5b505050506012600681905550620002e5336c0c9f2c9cd04674edea400000006200060e60201b60201c565b505062000c99565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620003935750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b620003ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156200048c57600080fd5b505af1158015620004a1573d6000803e3d6000fd5b50505050620004bb816200083b60201b6200249a1760201c565b50565b620004f4336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b62000567576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b62000644336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b620006b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff16156200073b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6200078c600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548262000c0760201b60201c565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620007e36002548262000c0760201b60201c565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620008e15750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000938576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415620009e6576001905062000c01565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141562000a47576001905062000c01565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141562000aa8576000905062000c01565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801562000bc157600080fd5b505afa15801562000bd6573d6000803e3d6000fd5b505050506040513d602081101562000bed57600080fd5b810190808051906020019092919050505090505b92915050565b600082828401915081101562000c85576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b61083980620034e883390190565b61283f8062000ca96000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80638da5cb5b116100f9578063be9a655511610097578063dd62ed3e11610071578063dd62ed3e14610760578063e348da13146107d8578063f2d5d56b1461081c578063fad8b32a1461086a576101a9565b8063be9a6555146106b0578063bf7e214f146106ba578063daea85c514610704576101a9565b8063a0712d68116100d3578063a0712d6814610560578063a9059cbb1461058e578063b753a98c146105f4578063bb35783b14610642576101a9565b80638da5cb5b146104aa57806395d89b41146104f45780639dc29fac14610512576101a9565b8063313ce567116101665780635ac801fe116101405780635ac801fe146103be57806370a08231146103ec57806375f12b21146104445780637a9e5e4b14610466576101a9565b8063313ce5671461032457806340c10f191461034257806342966c6814610390576101a9565b806306fdde03146101ae57806307da68f5146101cc578063095ea7b3146101d657806313af40351461023c57806318160ddd1461028057806323b872dd1461029e575b600080fd5b6101b66108ae565b6040518082815260200191505060405180910390f35b6101d46108b4565b005b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061099c565b604051808215151515815260200191505060405180910390f35b61027e6004803603602081101561025257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b11565b005b610288610c5a565b6040518082815260200191505060405180910390f35b61030a600480360360608110156102b457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610c60565b604051808215151515815260200191505060405180910390f35b61032c6111f8565b6040518082815260200191505060405180910390f35b61038e6004803603604081101561035857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506111fe565b005b6103bc600480360360208110156103a657600080fd5b8101908080359060200190929190505050611411565b005b6103ea600480360360208110156103d457600080fd5b810190808035906020019092919050505061141e565b005b61042e6004803603602081101561040257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114c8565b6040518082815260200191505060405180910390f35b61044c6114e0565b604051808215151515815260200191505060405180910390f35b6104a86004803603602081101561047c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114f3565b005b6104b261163a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6104fc611660565b6040518082815260200191505060405180910390f35b61055e6004803603604081101561052857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611666565b005b61058c6004803603602081101561057657600080fd5b8101908080359060200190929190505050611c04565b005b6105da600480360360408110156105a457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c11565b604051808215151515815260200191505060405180910390f35b6106406004803603604081101561060a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c26565b005b6106ae6004803603606081101561065857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c36565b005b6106b8611c47565b005b6106c2611d30565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6107466004803603602081101561071a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d55565b604051808215151515815260200191505060405180910390f35b6107c26004803603604081101561077657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d88565b6040518082815260200191505060405180910390f35b61081a600480360360208110156107ee57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611dad565b005b6108686004803603604081101561083257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611f6c565b005b6108ac6004803603602081101561088057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611f7c565b005b60075481565b6108e2336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610954576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60018060146101000a81548160ff0219169083151502179055507fbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b60405160405180910390a1565b6000600160149054906101000a900460ff1615610a21576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b610b3f336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610bb1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b60025481565b6000600160149054906101000a900460ff1615610ce5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614158015610dbd57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15610fbb5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610eb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b610f3a600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611070576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b6110b9600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611145600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612417565b600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b60065481565b61122c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b61129e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611321576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b61136a600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612417565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506113b960025482612417565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b61141b3382611666565b50565b61144c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b6114be576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b8060078190555050565b60036020528060005260406000206000915090505481565b600160149054906101000a900460ff1681565b611521336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611593576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b611694336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611706576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611789576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415801561186157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15611a5f5780600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611958576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b6119de600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611b14576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b611b5d600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611bac60025482612394565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5826040518082815260200191505060405180910390a25050565b611c0e33826111fe565b50565b6000611c1e338484610c60565b905092915050565b611c31338383610c60565b505050565b611c41838383610c60565b50505050565b611c75336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611ce7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000600160146101000a81548160ff0219169083151502179055507f1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b60405160405180910390a1565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000611d81827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61099c565b9050919050565b6004602052816000526040600020602052806000526040600020600091509150505481565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611e525750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611ea7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50505050611f698161249a565b50565b611f77823383610c60565b505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806120215750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612076576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fad8b32a826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561211757600080fd5b505af115801561212b573d6000803e3d6000fd5b5050505061213881612601565b50565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561217a576001905061238e565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156121d9576001905061238e565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415612238576000905061238e565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561235057600080fd5b505afa158015612364573d6000803e3d6000fd5b505050506040513d602081101561237a57600080fd5b810190808051906020019092919050505090505b92915050565b6000828284039150811115612411576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f64732d6d6174682d7375622d756e646572666c6f77000000000000000000000081525060200191505060405180910390fd5b92915050565b6000828284019150811015612494576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061253f5750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612594576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806126a65750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6126fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600160095411612773576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600960008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea264697066735822122082e300604a10aacaee1f89b3d629b05643e878ab42c4fb218fb6a45d82449f3064736f6c63430006070033608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806108086031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610619806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063b700961314610046578063e348da13146100eb578063fad8b32a1461012f575b600080fd5b6100d16004803603606081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610173565b604051808215151515815260200191505060405180910390f35b61012d6004803603602081101561010157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610279565b005b6101716004803603602081101561014557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506103de565b005b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061021957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61026e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600190509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061031d57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610372576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061048257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6104d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600180541161054e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220e7b320aefb1d184f7676dc65708a2ba5fbb27dfa7b0b34c702cf84c84818fd2c64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e608060405234801561001057600080fd5b50610316806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80635a8cadb114610046578063ad68ebf71461008a578063e1f21c67146100d8575b600080fd5b6100886004803603602081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610146565b005b6100d6600480360360408110156100a057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506101a9565b005b610144600480360360608110156100ee57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610218565b005b8073ffffffffffffffffffffffffffffffffffffffff16634a77f8706040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561018e57600080fd5b505af11580156101a2573d6000803e3d6000fd5b5050505050565b8173ffffffffffffffffffffffffffffffffffffffff1663454b0608826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b1580156101fc57600080fd5b505af1158015610210573d6000803e3d6000fd5b505050505050565b8273ffffffffffffffffffffffffffffffffffffffff1663095ea7b383836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561029f57600080fd5b505af11580156102b3573d6000803e3d6000fd5b505050506040513d60208110156102c957600080fd5b81019080805190602001909291905050505050505056fea264697066735822122089fea595cbb546d6f30642ac842ff4244121b482961427f8dc043ffcd874bd4464736f6c634300060700334572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e745da264697066735822122014179420c9e9553b0b7a880ba2c5727d3c1d6e476cb801269f141a77a6bc259764736f6c63430006070033"

// DeployTokenMigratorTest deploys a new Ethereum contract, binding an instance of TokenMigratorTest to it.
func DeployTokenMigratorTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TokenMigratorTest, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenMigratorTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenMigratorTest{TokenMigratorTestCaller: TokenMigratorTestCaller{contract: contract}, TokenMigratorTestTransactor: TokenMigratorTestTransactor{contract: contract}, TokenMigratorTestFilterer: TokenMigratorTestFilterer{contract: contract}}, nil
}

// TokenMigratorTest is an auto generated Go binding around an Ethereum contract.
type TokenMigratorTest struct {
	TokenMigratorTestCaller     // Read-only binding to the contract
	TokenMigratorTestTransactor // Write-only binding to the contract
	TokenMigratorTestFilterer   // Log filterer for contract events
}

// TokenMigratorTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenMigratorTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenMigratorTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenMigratorTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenMigratorTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenMigratorTestSession struct {
	Contract     *TokenMigratorTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// TokenMigratorTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenMigratorTestCallerSession struct {
	Contract *TokenMigratorTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// TokenMigratorTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenMigratorTestTransactorSession struct {
	Contract     *TokenMigratorTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// TokenMigratorTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenMigratorTestRaw struct {
	Contract *TokenMigratorTest // Generic contract binding to access the raw methods on
}

// TokenMigratorTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenMigratorTestCallerRaw struct {
	Contract *TokenMigratorTestCaller // Generic read-only contract binding to access the raw methods on
}

// TokenMigratorTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenMigratorTestTransactorRaw struct {
	Contract *TokenMigratorTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenMigratorTest creates a new instance of TokenMigratorTest, bound to a specific deployed contract.
func NewTokenMigratorTest(address common.Address, backend bind.ContractBackend) (*TokenMigratorTest, error) {
	contract, err := bindTokenMigratorTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTest{TokenMigratorTestCaller: TokenMigratorTestCaller{contract: contract}, TokenMigratorTestTransactor: TokenMigratorTestTransactor{contract: contract}, TokenMigratorTestFilterer: TokenMigratorTestFilterer{contract: contract}}, nil
}

// NewTokenMigratorTestCaller creates a new read-only instance of TokenMigratorTest, bound to a specific deployed contract.
func NewTokenMigratorTestCaller(address common.Address, caller bind.ContractCaller) (*TokenMigratorTestCaller, error) {
	contract, err := bindTokenMigratorTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestCaller{contract: contract}, nil
}

// NewTokenMigratorTestTransactor creates a new write-only instance of TokenMigratorTest, bound to a specific deployed contract.
func NewTokenMigratorTestTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenMigratorTestTransactor, error) {
	contract, err := bindTokenMigratorTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestTransactor{contract: contract}, nil
}

// NewTokenMigratorTestFilterer creates a new log filterer instance of TokenMigratorTest, bound to a specific deployed contract.
func NewTokenMigratorTestFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenMigratorTestFilterer, error) {
	contract, err := bindTokenMigratorTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestFilterer{contract: contract}, nil
}

// bindTokenMigratorTest binds a generic wrapper to an already deployed contract.
func bindTokenMigratorTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenMigratorTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigratorTest *TokenMigratorTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigratorTest.Contract.TokenMigratorTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigratorTest *TokenMigratorTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TokenMigratorTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigratorTest *TokenMigratorTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TokenMigratorTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenMigratorTest *TokenMigratorTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenMigratorTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenMigratorTest *TokenMigratorTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenMigratorTest *TokenMigratorTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _TokenMigratorTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestSession) ISTEST() (bool, error) {
	return _TokenMigratorTest.Contract.ISTEST(&_TokenMigratorTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestCallerSession) ISTEST() (bool, error) {
	return _TokenMigratorTest.Contract.ISTEST(&_TokenMigratorTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _TokenMigratorTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestSession) Failed() (bool, error) {
	return _TokenMigratorTest.Contract.Failed(&_TokenMigratorTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenMigratorTest *TokenMigratorTestCallerSession) Failed() (bool, error) {
	return _TokenMigratorTest.Contract.Failed(&_TokenMigratorTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) SetUp() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.SetUp(&_TokenMigratorTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.SetUp(&_TokenMigratorTest.TransactOpts)
}

// TestFailMigrate is a paid mutator transaction binding the contract method 0xc84c2c14.
//
// Solidity: function testFailMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestFailMigrate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testFailMigrate")
}

// TestFailMigrate is a paid mutator transaction binding the contract method 0xc84c2c14.
//
// Solidity: function testFailMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestFailMigrate() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailMigrate(&_TokenMigratorTest.TransactOpts)
}

// TestFailMigrate is a paid mutator transaction binding the contract method 0xc84c2c14.
//
// Solidity: function testFailMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestFailMigrate() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailMigrate(&_TokenMigratorTest.TransactOpts)
}

// TestFailMigrateAllUnapproved is a paid mutator transaction binding the contract method 0x31e876f1.
//
// Solidity: function testFailMigrateAllUnapproved() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestFailMigrateAllUnapproved(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testFailMigrateAllUnapproved")
}

// TestFailMigrateAllUnapproved is a paid mutator transaction binding the contract method 0x31e876f1.
//
// Solidity: function testFailMigrateAllUnapproved() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestFailMigrateAllUnapproved() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailMigrateAllUnapproved(&_TokenMigratorTest.TransactOpts)
}

// TestFailMigrateAllUnapproved is a paid mutator transaction binding the contract method 0x31e876f1.
//
// Solidity: function testFailMigrateAllUnapproved() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestFailMigrateAllUnapproved() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailMigrateAllUnapproved(&_TokenMigratorTest.TransactOpts)
}

// TestFailStartDouble is a paid mutator transaction binding the contract method 0xda34e901.
//
// Solidity: function testFailStartDouble() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestFailStartDouble(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testFailStartDouble")
}

// TestFailStartDouble is a paid mutator transaction binding the contract method 0xda34e901.
//
// Solidity: function testFailStartDouble() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestFailStartDouble() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStartDouble(&_TokenMigratorTest.TransactOpts)
}

// TestFailStartDouble is a paid mutator transaction binding the contract method 0xda34e901.
//
// Solidity: function testFailStartDouble() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestFailStartDouble() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStartDouble(&_TokenMigratorTest.TransactOpts)
}

// TestFailStartInvalidToken is a paid mutator transaction binding the contract method 0x43ab1a34.
//
// Solidity: function testFailStartInvalidToken() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestFailStartInvalidToken(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testFailStartInvalidToken")
}

// TestFailStartInvalidToken is a paid mutator transaction binding the contract method 0x43ab1a34.
//
// Solidity: function testFailStartInvalidToken() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestFailStartInvalidToken() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStartInvalidToken(&_TokenMigratorTest.TransactOpts)
}

// TestFailStartInvalidToken is a paid mutator transaction binding the contract method 0x43ab1a34.
//
// Solidity: function testFailStartInvalidToken() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestFailStartInvalidToken() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStartInvalidToken(&_TokenMigratorTest.TransactOpts)
}

// TestFailStop is a paid mutator transaction binding the contract method 0x96b2833e.
//
// Solidity: function testFailStop() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestFailStop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testFailStop")
}

// TestFailStop is a paid mutator transaction binding the contract method 0x96b2833e.
//
// Solidity: function testFailStop() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestFailStop() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStop(&_TokenMigratorTest.TransactOpts)
}

// TestFailStop is a paid mutator transaction binding the contract method 0x96b2833e.
//
// Solidity: function testFailStop() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestFailStop() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestFailStop(&_TokenMigratorTest.TransactOpts)
}

// TestMigrate is a paid mutator transaction binding the contract method 0x7a3867d3.
//
// Solidity: function testMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestMigrate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testMigrate")
}

// TestMigrate is a paid mutator transaction binding the contract method 0x7a3867d3.
//
// Solidity: function testMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestMigrate() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrate(&_TokenMigratorTest.TransactOpts)
}

// TestMigrate is a paid mutator transaction binding the contract method 0x7a3867d3.
//
// Solidity: function testMigrate() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestMigrate() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrate(&_TokenMigratorTest.TransactOpts)
}

// TestMigrateAll is a paid mutator transaction binding the contract method 0x538bec16.
//
// Solidity: function testMigrateAll() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestMigrateAll(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testMigrateAll")
}

// TestMigrateAll is a paid mutator transaction binding the contract method 0x538bec16.
//
// Solidity: function testMigrateAll() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestMigrateAll() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrateAll(&_TokenMigratorTest.TransactOpts)
}

// TestMigrateAll is a paid mutator transaction binding the contract method 0x538bec16.
//
// Solidity: function testMigrateAll() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestMigrateAll() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrateAll(&_TokenMigratorTest.TransactOpts)
}

// TestMigrateAllSupplyIncrease is a paid mutator transaction binding the contract method 0x1a83894c.
//
// Solidity: function testMigrateAllSupplyIncrease() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestMigrateAllSupplyIncrease(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testMigrateAllSupplyIncrease")
}

// TestMigrateAllSupplyIncrease is a paid mutator transaction binding the contract method 0x1a83894c.
//
// Solidity: function testMigrateAllSupplyIncrease() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestMigrateAllSupplyIncrease() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrateAllSupplyIncrease(&_TokenMigratorTest.TransactOpts)
}

// TestMigrateAllSupplyIncrease is a paid mutator transaction binding the contract method 0x1a83894c.
//
// Solidity: function testMigrateAllSupplyIncrease() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestMigrateAllSupplyIncrease() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestMigrateAllSupplyIncrease(&_TokenMigratorTest.TransactOpts)
}

// TestStart is a paid mutator transaction binding the contract method 0xe34323b8.
//
// Solidity: function testStart() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestStart(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testStart")
}

// TestStart is a paid mutator transaction binding the contract method 0xe34323b8.
//
// Solidity: function testStart() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestStart() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestStart(&_TokenMigratorTest.TransactOpts)
}

// TestStart is a paid mutator transaction binding the contract method 0xe34323b8.
//
// Solidity: function testStart() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestStart() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestStart(&_TokenMigratorTest.TransactOpts)
}

// TestStop is a paid mutator transaction binding the contract method 0xf89eae17.
//
// Solidity: function testStop() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactor) TestStop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenMigratorTest.contract.Transact(opts, "testStop")
}

// TestStop is a paid mutator transaction binding the contract method 0xf89eae17.
//
// Solidity: function testStop() returns()
func (_TokenMigratorTest *TokenMigratorTestSession) TestStop() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestStop(&_TokenMigratorTest.TransactOpts)
}

// TestStop is a paid mutator transaction binding the contract method 0xf89eae17.
//
// Solidity: function testStop() returns()
func (_TokenMigratorTest *TokenMigratorTestTransactorSession) TestStop() (*types.Transaction, error) {
	return _TokenMigratorTest.Contract.TestStop(&_TokenMigratorTest.TransactOpts)
}

// TokenMigratorTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogIterator struct {
	Event *TokenMigratorTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLog represents a Log event raised by the TokenMigratorTest contract.
type TokenMigratorTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLog(opts *bind.FilterOpts) (*TokenMigratorTestLogIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogIterator{contract: _TokenMigratorTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLog) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLog)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLog(log types.Log) (*TokenMigratorTestLog, error) {
	event := new(TokenMigratorTestLog)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogAddressIterator struct {
	Event *TokenMigratorTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogAddress represents a LogAddress event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*TokenMigratorTestLogAddressIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogAddressIterator{contract: _TokenMigratorTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogAddress)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogAddress(log types.Log) (*TokenMigratorTestLogAddress, error) {
	event := new(TokenMigratorTestLogAddress)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogBytesIterator struct {
	Event *TokenMigratorTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogBytes represents a LogBytes event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*TokenMigratorTestLogBytesIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogBytesIterator{contract: _TokenMigratorTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogBytes)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogBytes(log types.Log) (*TokenMigratorTestLogBytes, error) {
	event := new(TokenMigratorTestLogBytes)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogBytes32Iterator struct {
	Event *TokenMigratorTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogBytes32 represents a LogBytes32 event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*TokenMigratorTestLogBytes32Iterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogBytes32Iterator{contract: _TokenMigratorTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogBytes32)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogBytes32(log types.Log) (*TokenMigratorTestLogBytes32, error) {
	event := new(TokenMigratorTestLogBytes32)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogIntIterator struct {
	Event *TokenMigratorTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogInt represents a LogInt event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*TokenMigratorTestLogIntIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogIntIterator{contract: _TokenMigratorTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogInt) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogInt)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogInt(log types.Log) (*TokenMigratorTestLogInt, error) {
	event := new(TokenMigratorTestLogInt)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedAddressIterator struct {
	Event *TokenMigratorTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedAddress represents a LogNamedAddress event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedAddressIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedAddressIterator{contract: _TokenMigratorTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedAddress)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedAddress(log types.Log) (*TokenMigratorTestLogNamedAddress, error) {
	event := new(TokenMigratorTestLogNamedAddress)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedBytesIterator struct {
	Event *TokenMigratorTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedBytes represents a LogNamedBytes event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedBytesIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedBytesIterator{contract: _TokenMigratorTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedBytes)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedBytes(log types.Log) (*TokenMigratorTestLogNamedBytes, error) {
	event := new(TokenMigratorTestLogNamedBytes)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedBytes32Iterator struct {
	Event *TokenMigratorTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedBytes32Iterator{contract: _TokenMigratorTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedBytes32)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedBytes32(log types.Log) (*TokenMigratorTestLogNamedBytes32, error) {
	event := new(TokenMigratorTestLogNamedBytes32)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedDecimalIntIterator struct {
	Event *TokenMigratorTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedDecimalIntIterator{contract: _TokenMigratorTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedDecimalInt)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*TokenMigratorTestLogNamedDecimalInt, error) {
	event := new(TokenMigratorTestLogNamedDecimalInt)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedDecimalUintIterator struct {
	Event *TokenMigratorTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedDecimalUintIterator{contract: _TokenMigratorTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedDecimalUint)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*TokenMigratorTestLogNamedDecimalUint, error) {
	event := new(TokenMigratorTestLogNamedDecimalUint)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedIntIterator struct {
	Event *TokenMigratorTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedInt represents a LogNamedInt event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedIntIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedIntIterator{contract: _TokenMigratorTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedInt)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedInt(log types.Log) (*TokenMigratorTestLogNamedInt, error) {
	event := new(TokenMigratorTestLogNamedInt)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedStringIterator struct {
	Event *TokenMigratorTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedString represents a LogNamedString event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedStringIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedStringIterator{contract: _TokenMigratorTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedString)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedString(log types.Log) (*TokenMigratorTestLogNamedString, error) {
	event := new(TokenMigratorTestLogNamedString)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedUintIterator struct {
	Event *TokenMigratorTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogNamedUint represents a LogNamedUint event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*TokenMigratorTestLogNamedUintIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogNamedUintIterator{contract: _TokenMigratorTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogNamedUint)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogNamedUint(log types.Log) (*TokenMigratorTestLogNamedUint, error) {
	event := new(TokenMigratorTestLogNamedUint)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogStringIterator struct {
	Event *TokenMigratorTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogString represents a LogString event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogString(opts *bind.FilterOpts) (*TokenMigratorTestLogStringIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogStringIterator{contract: _TokenMigratorTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogString) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogString)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogString(log types.Log) (*TokenMigratorTestLogString, error) {
	event := new(TokenMigratorTestLogString)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogUintIterator struct {
	Event *TokenMigratorTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogUint represents a LogUint event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*TokenMigratorTestLogUintIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogUintIterator{contract: _TokenMigratorTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogUint) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogUint)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogUint(log types.Log) (*TokenMigratorTestLogUint, error) {
	event := new(TokenMigratorTestLogUint)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenMigratorTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the TokenMigratorTest contract.
type TokenMigratorTestLogsIterator struct {
	Event *TokenMigratorTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenMigratorTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenMigratorTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenMigratorTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenMigratorTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenMigratorTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenMigratorTestLogs represents a Logs event raised by the TokenMigratorTest contract.
type TokenMigratorTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) FilterLogs(opts *bind.FilterOpts) (*TokenMigratorTestLogsIterator, error) {

	logs, sub, err := _TokenMigratorTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &TokenMigratorTestLogsIterator{contract: _TokenMigratorTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *TokenMigratorTestLogs) (event.Subscription, error) {

	logs, sub, err := _TokenMigratorTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenMigratorTestLogs)
				if err := _TokenMigratorTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenMigratorTest *TokenMigratorTestFilterer) ParseLogs(log types.Log) (*TokenMigratorTestLogs, error) {
	event := new(TokenMigratorTestLogs)
	if err := _TokenMigratorTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestABI is the input ABI used to generate the binding from.
const TokenTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testInitialization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenTestBin is the compiled bytecode used for deploying new contracts.
var TokenTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b5061453b8061003a6000396000f3fe60806040523480156200001157600080fd5b5060043610620000525760003560e01c80630a9254e41462000057578063a109f39a1462000063578063ba414fa6146200006f578063fa7626d41462000093575b600080fd5b62000061620000b7565b005b6200006d62000237565b005b62000079620006e7565b604051808215151515815260200191505060405180910390f35b6200009d620006fa565b604051808215151515815260200191505060405180910390f35b604051620000c590620007a5565b80807f55544c0000000000000000000000000000000000000000000000000000000000815250602001807f4d61644e6574205574696c6974790000000000000000000000000000000000008152506020019050604051809103906000f08015801562000135573d6000803e3d6000fd5b50600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040516200018490620007a5565b80807f53544b0000000000000000000000000000000000000000000000000000000000815250602001807f4d61644e6574205374616b696e670000000000000000000000000000000000008152506020019050604051809103906000f080158015620001f4573d6000803e3d6000fd5b50600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b620003097f55544c0000000000000000000000000000000000000000000000000000000000600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160206040518083038186803b158015620002c557600080fd5b505afa158015620002da573d6000803e3d6000fd5b505050506040513d6020811015620002f157600080fd5b8101908080519060200190929190505050146200070c565b620003db7f4d61644e6574205574696c697479000000000000000000000000000000000000600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b815260040160206040518083038186803b1580156200039757600080fd5b505afa158015620003ac573d6000803e3d6000fd5b505050506040513d6020811015620003c357600080fd5b8101908080519060200190929190505050146200070c565b6200048e6012600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b1580156200044a57600080fd5b505afa1580156200045f573d6000803e3d6000fd5b505050506040513d60208110156200047657600080fd5b8101908080519060200190929190505050146200070c565b620005607f53544b0000000000000000000000000000000000000000000000000000000000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160206040518083038186803b1580156200051c57600080fd5b505afa15801562000531573d6000803e3d6000fd5b505050506040513d60208110156200054857600080fd5b8101908080519060200190929190505050146200070c565b620006327f4d61644e6574205374616b696e67000000000000000000000000000000000000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b815260040160206040518083038186803b158015620005ee57600080fd5b505afa15801562000603573d6000803e3d6000fd5b505050506040513d60208110156200061a57600080fd5b8101908080519060200190929190505050146200070c565b620006e56012600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015620006a157600080fd5b505afa158015620006b6573d6000803e3d6000fd5b505050506040513d6020811015620006cd57600080fd5b8101908080519060200190929190505050146200070c565b565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b8062000785577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040518080602001828103825260178152602001807f4572726f723a20417373657274696f6e204661696c656400000000000000000081525060200191505060405180910390a16200078462000788565b5b50565b6001600060016101000a81548160ff021916908315150217905550565b613d5280620007b48339019056fe6080604052601260065560006007556040516200001c9062000c8b565b604051809103906000f08015801562000039573d6000803e3d6000fd5b50600b60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156200008757600080fd5b5060405162003d5238038062003d5283398181016040526040811015620000ad57600080fd5b8101908080519060200190929190805190602001909291905050508133600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a2806005819055505033600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550620001c9600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620002ed60201b60201c565b620001fc600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16620004be60201b60201c565b80600781905550600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13336040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015620002a557600080fd5b505af1158015620002ba573d6000803e3d6000fd5b505050506012600681905550620002e5336c0c9f2c9cd04674edea400000006200060e60201b60201c565b505062000c99565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620003935750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b620003ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156200048c57600080fd5b505af1158015620004a1573d6000803e3d6000fd5b50505050620004bb816200083b60201b6200249a1760201c565b50565b620004f4336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b62000567576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b62000644336000357fffffffff0000000000000000000000000000000000000000000000000000000016620009a560201b60201c565b620006b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff16156200073b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b6200078c600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548262000c0760201b60201c565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620007e36002548262000c0760201b60201c565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620008e15750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000938576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062003d216031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415620009e6576001905062000c01565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141562000a47576001905062000c01565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141562000aa8576000905062000c01565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801562000bc157600080fd5b505afa15801562000bd6573d6000803e3d6000fd5b505050506040513d602081101562000bed57600080fd5b810190808051906020019092919050505090505b92915050565b600082828401915081101562000c85576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b61083980620034e883390190565b61283f8062000ca96000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80638da5cb5b116100f9578063be9a655511610097578063dd62ed3e11610071578063dd62ed3e14610760578063e348da13146107d8578063f2d5d56b1461081c578063fad8b32a1461086a576101a9565b8063be9a6555146106b0578063bf7e214f146106ba578063daea85c514610704576101a9565b8063a0712d68116100d3578063a0712d6814610560578063a9059cbb1461058e578063b753a98c146105f4578063bb35783b14610642576101a9565b80638da5cb5b146104aa57806395d89b41146104f45780639dc29fac14610512576101a9565b8063313ce567116101665780635ac801fe116101405780635ac801fe146103be57806370a08231146103ec57806375f12b21146104445780637a9e5e4b14610466576101a9565b8063313ce5671461032457806340c10f191461034257806342966c6814610390576101a9565b806306fdde03146101ae57806307da68f5146101cc578063095ea7b3146101d657806313af40351461023c57806318160ddd1461028057806323b872dd1461029e575b600080fd5b6101b66108ae565b6040518082815260200191505060405180910390f35b6101d46108b4565b005b610222600480360360408110156101ec57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061099c565b604051808215151515815260200191505060405180910390f35b61027e6004803603602081101561025257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b11565b005b610288610c5a565b6040518082815260200191505060405180910390f35b61030a600480360360608110156102b457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610c60565b604051808215151515815260200191505060405180910390f35b61032c6111f8565b6040518082815260200191505060405180910390f35b61038e6004803603604081101561035857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506111fe565b005b6103bc600480360360208110156103a657600080fd5b8101908080359060200190929190505050611411565b005b6103ea600480360360208110156103d457600080fd5b810190808035906020019092919050505061141e565b005b61042e6004803603602081101561040257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114c8565b6040518082815260200191505060405180910390f35b61044c6114e0565b604051808215151515815260200191505060405180910390f35b6104a86004803603602081101561047c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114f3565b005b6104b261163a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6104fc611660565b6040518082815260200191505060405180910390f35b61055e6004803603604081101561052857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611666565b005b61058c6004803603602081101561057657600080fd5b8101908080359060200190929190505050611c04565b005b6105da600480360360408110156105a457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c11565b604051808215151515815260200191505060405180910390f35b6106406004803603604081101561060a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c26565b005b6106ae6004803603606081101561065857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611c36565b005b6106b8611c47565b005b6106c2611d30565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6107466004803603602081101561071a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d55565b604051808215151515815260200191505060405180910390f35b6107c26004803603604081101561077657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d88565b6040518082815260200191505060405180910390f35b61081a600480360360208110156107ee57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611dad565b005b6108686004803603604081101561083257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611f6c565b005b6108ac6004803603602081101561088057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611f7c565b005b60075481565b6108e2336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610954576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60018060146101000a81548160ff0219169083151502179055507fbedf0f4abfe86d4ffad593d9607fe70e83ea706033d44d24b3b6283cf3fc4f6b60405160405180910390a1565b6000600160149054906101000a900460ff1615610a21576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b610b3f336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b610bb1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b60025481565b6000600160149054906101000a900460ff1615610ce5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614158015610dbd57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15610fbb5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610eb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b610f3a600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611070576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b6110b9600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612394565b600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611145600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483612417565b600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b60065481565b61122c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b61129e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611321576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b61136a600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612417565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506113b960025482612417565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885826040518082815260200191505060405180910390a25050565b61141b3382611666565b50565b61144c336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b6114be576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b8060078190555050565b60036020528060005260406000206000915090505481565b600160149054906101000a900460ff1681565b611521336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611593576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b611694336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611706576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b600160149054906101000a900460ff1615611789576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415801561186157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15611a5f5780600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611958576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601e8152602001807f64732d746f6b656e2d696e73756666696369656e742d617070726f76616c000081525060200191505060405180910390fd5b6119de600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611b14576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f64732d746f6b656e2d696e73756666696369656e742d62616c616e636500000081525060200191505060405180910390fd5b611b5d600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482612394565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611bac60025482612394565b6002819055508173ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5826040518082815260200191505060405180910390a25050565b611c0e33826111fe565b50565b6000611c1e338484610c60565b905092915050565b611c31338383610c60565b505050565b611c41838383610c60565b50505050565b611c75336000357fffffffff000000000000000000000000000000000000000000000000000000001661213b565b611ce7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000600160146101000a81548160ff0219169083151502179055507f1b55ba3aa851a46be3b365aee5b5c140edd620d578922f3e8466d2cbd96f954b60405160405180910390a1565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000611d81827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61099c565b9050919050565b6004602052816000526040600020602052806000526040600020600091509150505481565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611e525750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611ea7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e348da13826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50505050611f698161249a565b50565b611f77823383610c60565b505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806120215750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612076576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fad8b32a826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561211757600080fd5b505af115801561212b573d6000803e3d6000fd5b5050505061213881612601565b50565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561217a576001905061238e565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156121d9576001905061238e565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415612238576000905061238e565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561235057600080fd5b505afa158015612364573d6000803e3d6000fd5b505050506040513d602081101561237a57600080fd5b810190808051906020019092919050505090505b92915050565b6000828284039150811115612411576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f64732d6d6174682d7375622d756e646572666c6f77000000000000000000000081525060200191505060405180910390fd5b92915050565b6000828284019150811015612494576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061253f5750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612594576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b6001600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060096000815480929190600101919050555050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806126a65750600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6126fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806127d96031913960400191505060405180910390fd5b600160095411612773576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600860008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600960008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea264697066735822122082e300604a10aacaee1f89b3d629b05643e878ab42c4fb218fb6a45d82449f3064736f6c63430006070033608060405233600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610076600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661007b60201b60201c565b6101e0565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061011f57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610174576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806108086031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b610619806101ef6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063b700961314610046578063e348da13146100eb578063fad8b32a1461012f575b600080fd5b6100d16004803603606081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610173565b604051808215151515815260200191505060405180910390f35b61012d6004803603602081101561010157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610279565b005b6101716004803603602081101561014557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506103de565b005b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061021957506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61026e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600190509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061031d57506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610372576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b60016000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060016000815480929190600101919050555050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061048257506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6104d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806105b36031913960400191505060405180910390fd5b600180541161054e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b6000808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055600160008154809291906001900391905055505056fe46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea2646970667358221220e7b320aefb1d184f7676dc65708a2ba5fbb27dfa7b0b34c702cf84c84818fd2c64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e46756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea26469706673582212201886d59b05d3fbb930ab585ab41df6e1d5621d2367c6d46c5aef6c1e46390db364736f6c63430006070033"

// DeployTokenTest deploys a new Ethereum contract, binding an instance of TokenTest to it.
func DeployTokenTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TokenTest, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(TokenTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenTest{TokenTestCaller: TokenTestCaller{contract: contract}, TokenTestTransactor: TokenTestTransactor{contract: contract}, TokenTestFilterer: TokenTestFilterer{contract: contract}}, nil
}

// TokenTest is an auto generated Go binding around an Ethereum contract.
type TokenTest struct {
	TokenTestCaller     // Read-only binding to the contract
	TokenTestTransactor // Write-only binding to the contract
	TokenTestFilterer   // Log filterer for contract events
}

// TokenTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenTestSession struct {
	Contract     *TokenTest        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenTestCallerSession struct {
	Contract *TokenTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// TokenTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenTestTransactorSession struct {
	Contract     *TokenTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// TokenTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenTestRaw struct {
	Contract *TokenTest // Generic contract binding to access the raw methods on
}

// TokenTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenTestCallerRaw struct {
	Contract *TokenTestCaller // Generic read-only contract binding to access the raw methods on
}

// TokenTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenTestTransactorRaw struct {
	Contract *TokenTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenTest creates a new instance of TokenTest, bound to a specific deployed contract.
func NewTokenTest(address common.Address, backend bind.ContractBackend) (*TokenTest, error) {
	contract, err := bindTokenTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenTest{TokenTestCaller: TokenTestCaller{contract: contract}, TokenTestTransactor: TokenTestTransactor{contract: contract}, TokenTestFilterer: TokenTestFilterer{contract: contract}}, nil
}

// NewTokenTestCaller creates a new read-only instance of TokenTest, bound to a specific deployed contract.
func NewTokenTestCaller(address common.Address, caller bind.ContractCaller) (*TokenTestCaller, error) {
	contract, err := bindTokenTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenTestCaller{contract: contract}, nil
}

// NewTokenTestTransactor creates a new write-only instance of TokenTest, bound to a specific deployed contract.
func NewTokenTestTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenTestTransactor, error) {
	contract, err := bindTokenTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenTestTransactor{contract: contract}, nil
}

// NewTokenTestFilterer creates a new log filterer instance of TokenTest, bound to a specific deployed contract.
func NewTokenTestFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenTestFilterer, error) {
	contract, err := bindTokenTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenTestFilterer{contract: contract}, nil
}

// bindTokenTest binds a generic wrapper to an already deployed contract.
func bindTokenTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenTest *TokenTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenTest.Contract.TokenTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenTest *TokenTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenTest.Contract.TokenTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenTest *TokenTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenTest.Contract.TokenTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenTest *TokenTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenTest *TokenTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenTest *TokenTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenTest *TokenTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _TokenTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenTest *TokenTestSession) ISTEST() (bool, error) {
	return _TokenTest.Contract.ISTEST(&_TokenTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_TokenTest *TokenTestCallerSession) ISTEST() (bool, error) {
	return _TokenTest.Contract.ISTEST(&_TokenTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenTest *TokenTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _TokenTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenTest *TokenTestSession) Failed() (bool, error) {
	return _TokenTest.Contract.Failed(&_TokenTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_TokenTest *TokenTestCallerSession) Failed() (bool, error) {
	return _TokenTest.Contract.Failed(&_TokenTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenTest *TokenTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenTest *TokenTestSession) SetUp() (*types.Transaction, error) {
	return _TokenTest.Contract.SetUp(&_TokenTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_TokenTest *TokenTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _TokenTest.Contract.SetUp(&_TokenTest.TransactOpts)
}

// TestInitialization is a paid mutator transaction binding the contract method 0xa109f39a.
//
// Solidity: function testInitialization() returns()
func (_TokenTest *TokenTestTransactor) TestInitialization(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenTest.contract.Transact(opts, "testInitialization")
}

// TestInitialization is a paid mutator transaction binding the contract method 0xa109f39a.
//
// Solidity: function testInitialization() returns()
func (_TokenTest *TokenTestSession) TestInitialization() (*types.Transaction, error) {
	return _TokenTest.Contract.TestInitialization(&_TokenTest.TransactOpts)
}

// TestInitialization is a paid mutator transaction binding the contract method 0xa109f39a.
//
// Solidity: function testInitialization() returns()
func (_TokenTest *TokenTestTransactorSession) TestInitialization() (*types.Transaction, error) {
	return _TokenTest.Contract.TestInitialization(&_TokenTest.TransactOpts)
}

// TokenTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the TokenTest contract.
type TokenTestLogIterator struct {
	Event *TokenTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLog represents a Log event raised by the TokenTest contract.
type TokenTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenTest *TokenTestFilterer) FilterLog(opts *bind.FilterOpts) (*TokenTestLogIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogIterator{contract: _TokenTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenTest *TokenTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *TokenTestLog) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLog)
				if err := _TokenTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_TokenTest *TokenTestFilterer) ParseLog(log types.Log) (*TokenTestLog, error) {
	event := new(TokenTestLog)
	if err := _TokenTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the TokenTest contract.
type TokenTestLogAddressIterator struct {
	Event *TokenTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogAddress represents a LogAddress event raised by the TokenTest contract.
type TokenTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenTest *TokenTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*TokenTestLogAddressIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogAddressIterator{contract: _TokenTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenTest *TokenTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *TokenTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogAddress)
				if err := _TokenTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_TokenTest *TokenTestFilterer) ParseLogAddress(log types.Log) (*TokenTestLogAddress, error) {
	event := new(TokenTestLogAddress)
	if err := _TokenTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the TokenTest contract.
type TokenTestLogBytesIterator struct {
	Event *TokenTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogBytes represents a LogBytes event raised by the TokenTest contract.
type TokenTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenTest *TokenTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*TokenTestLogBytesIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogBytesIterator{contract: _TokenTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenTest *TokenTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *TokenTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogBytes)
				if err := _TokenTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_TokenTest *TokenTestFilterer) ParseLogBytes(log types.Log) (*TokenTestLogBytes, error) {
	event := new(TokenTestLogBytes)
	if err := _TokenTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the TokenTest contract.
type TokenTestLogBytes32Iterator struct {
	Event *TokenTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogBytes32 represents a LogBytes32 event raised by the TokenTest contract.
type TokenTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenTest *TokenTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*TokenTestLogBytes32Iterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogBytes32Iterator{contract: _TokenTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenTest *TokenTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *TokenTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogBytes32)
				if err := _TokenTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_TokenTest *TokenTestFilterer) ParseLogBytes32(log types.Log) (*TokenTestLogBytes32, error) {
	event := new(TokenTestLogBytes32)
	if err := _TokenTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the TokenTest contract.
type TokenTestLogIntIterator struct {
	Event *TokenTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogInt represents a LogInt event raised by the TokenTest contract.
type TokenTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenTest *TokenTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*TokenTestLogIntIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogIntIterator{contract: _TokenTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenTest *TokenTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *TokenTestLogInt) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogInt)
				if err := _TokenTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_TokenTest *TokenTestFilterer) ParseLogInt(log types.Log) (*TokenTestLogInt, error) {
	event := new(TokenTestLogInt)
	if err := _TokenTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the TokenTest contract.
type TokenTestLogNamedAddressIterator struct {
	Event *TokenTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedAddress represents a LogNamedAddress event raised by the TokenTest contract.
type TokenTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*TokenTestLogNamedAddressIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedAddressIterator{contract: _TokenTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedAddress)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedAddress(log types.Log) (*TokenTestLogNamedAddress, error) {
	event := new(TokenTestLogNamedAddress)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the TokenTest contract.
type TokenTestLogNamedBytesIterator struct {
	Event *TokenTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedBytes represents a LogNamedBytes event raised by the TokenTest contract.
type TokenTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*TokenTestLogNamedBytesIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedBytesIterator{contract: _TokenTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedBytes)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedBytes(log types.Log) (*TokenTestLogNamedBytes, error) {
	event := new(TokenTestLogNamedBytes)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the TokenTest contract.
type TokenTestLogNamedBytes32Iterator struct {
	Event *TokenTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the TokenTest contract.
type TokenTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*TokenTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedBytes32Iterator{contract: _TokenTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedBytes32)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedBytes32(log types.Log) (*TokenTestLogNamedBytes32, error) {
	event := new(TokenTestLogNamedBytes32)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the TokenTest contract.
type TokenTestLogNamedDecimalIntIterator struct {
	Event *TokenTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the TokenTest contract.
type TokenTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*TokenTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedDecimalIntIterator{contract: _TokenTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedDecimalInt)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*TokenTestLogNamedDecimalInt, error) {
	event := new(TokenTestLogNamedDecimalInt)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the TokenTest contract.
type TokenTestLogNamedDecimalUintIterator struct {
	Event *TokenTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the TokenTest contract.
type TokenTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*TokenTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedDecimalUintIterator{contract: _TokenTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedDecimalUint)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_TokenTest *TokenTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*TokenTestLogNamedDecimalUint, error) {
	event := new(TokenTestLogNamedDecimalUint)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the TokenTest contract.
type TokenTestLogNamedIntIterator struct {
	Event *TokenTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedInt represents a LogNamedInt event raised by the TokenTest contract.
type TokenTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*TokenTestLogNamedIntIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedIntIterator{contract: _TokenTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedInt)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedInt(log types.Log) (*TokenTestLogNamedInt, error) {
	event := new(TokenTestLogNamedInt)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the TokenTest contract.
type TokenTestLogNamedStringIterator struct {
	Event *TokenTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedString represents a LogNamedString event raised by the TokenTest contract.
type TokenTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*TokenTestLogNamedStringIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedStringIterator{contract: _TokenTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedString)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedString(log types.Log) (*TokenTestLogNamedString, error) {
	event := new(TokenTestLogNamedString)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the TokenTest contract.
type TokenTestLogNamedUintIterator struct {
	Event *TokenTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogNamedUint represents a LogNamedUint event raised by the TokenTest contract.
type TokenTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenTest *TokenTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*TokenTestLogNamedUintIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogNamedUintIterator{contract: _TokenTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenTest *TokenTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *TokenTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogNamedUint)
				if err := _TokenTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_TokenTest *TokenTestFilterer) ParseLogNamedUint(log types.Log) (*TokenTestLogNamedUint, error) {
	event := new(TokenTestLogNamedUint)
	if err := _TokenTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the TokenTest contract.
type TokenTestLogStringIterator struct {
	Event *TokenTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogString represents a LogString event raised by the TokenTest contract.
type TokenTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenTest *TokenTestFilterer) FilterLogString(opts *bind.FilterOpts) (*TokenTestLogStringIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogStringIterator{contract: _TokenTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenTest *TokenTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *TokenTestLogString) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogString)
				if err := _TokenTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_TokenTest *TokenTestFilterer) ParseLogString(log types.Log) (*TokenTestLogString, error) {
	event := new(TokenTestLogString)
	if err := _TokenTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the TokenTest contract.
type TokenTestLogUintIterator struct {
	Event *TokenTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogUint represents a LogUint event raised by the TokenTest contract.
type TokenTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenTest *TokenTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*TokenTestLogUintIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogUintIterator{contract: _TokenTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenTest *TokenTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *TokenTestLogUint) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogUint)
				if err := _TokenTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_TokenTest *TokenTestFilterer) ParseLogUint(log types.Log) (*TokenTestLogUint, error) {
	event := new(TokenTestLogUint)
	if err := _TokenTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// TokenTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the TokenTest contract.
type TokenTestLogsIterator struct {
	Event *TokenTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenTestLogs represents a Logs event raised by the TokenTest contract.
type TokenTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenTest *TokenTestFilterer) FilterLogs(opts *bind.FilterOpts) (*TokenTestLogsIterator, error) {

	logs, sub, err := _TokenTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &TokenTestLogsIterator{contract: _TokenTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenTest *TokenTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *TokenTestLogs) (event.Subscription, error) {

	logs, sub, err := _TokenTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenTestLogs)
				if err := _TokenTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_TokenTest *TokenTestFilterer) ParseLogs(log types.Log) (*TokenTestLogs, error) {
	event := new(TokenTestLogs)
	if err := _TokenTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// UserRepresentativeABI is the input ABI used to generate the binding from.
const UserRepresentativeABI = "[{\"inputs\":[{\"internalType\":\"contractBasicERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractTokenMigrator\",\"name\":\"migrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractTokenMigrator\",\"name\":\"migrator\",\"type\":\"address\"}],\"name\":\"migrateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// UserRepresentativeBin is the compiled bytecode used for deploying new contracts.
var UserRepresentativeBin = "0x608060405234801561001057600080fd5b50610316806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80635a8cadb114610046578063ad68ebf71461008a578063e1f21c67146100d8575b600080fd5b6100886004803603602081101561005c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610146565b005b6100d6600480360360408110156100a057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506101a9565b005b610144600480360360608110156100ee57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610218565b005b8073ffffffffffffffffffffffffffffffffffffffff16634a77f8706040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561018e57600080fd5b505af11580156101a2573d6000803e3d6000fd5b5050505050565b8173ffffffffffffffffffffffffffffffffffffffff1663454b0608826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b1580156101fc57600080fd5b505af1158015610210573d6000803e3d6000fd5b505050505050565b8273ffffffffffffffffffffffffffffffffffffffff1663095ea7b383836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561029f57600080fd5b505af11580156102b3573d6000803e3d6000fd5b505050506040513d60208110156102c957600080fd5b81019080805190602001909291905050505050505056fea264697066735822122089fea595cbb546d6f30642ac842ff4244121b482961427f8dc043ffcd874bd4464736f6c63430006070033"

// DeployUserRepresentative deploys a new Ethereum contract, binding an instance of UserRepresentative to it.
func DeployUserRepresentative(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *UserRepresentative, error) {
	parsed, err := abi.JSON(strings.NewReader(UserRepresentativeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(UserRepresentativeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &UserRepresentative{UserRepresentativeCaller: UserRepresentativeCaller{contract: contract}, UserRepresentativeTransactor: UserRepresentativeTransactor{contract: contract}, UserRepresentativeFilterer: UserRepresentativeFilterer{contract: contract}}, nil
}

// UserRepresentative is an auto generated Go binding around an Ethereum contract.
type UserRepresentative struct {
	UserRepresentativeCaller     // Read-only binding to the contract
	UserRepresentativeTransactor // Write-only binding to the contract
	UserRepresentativeFilterer   // Log filterer for contract events
}

// UserRepresentativeCaller is an auto generated read-only Go binding around an Ethereum contract.
type UserRepresentativeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UserRepresentativeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UserRepresentativeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UserRepresentativeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UserRepresentativeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UserRepresentativeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UserRepresentativeSession struct {
	Contract     *UserRepresentative // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// UserRepresentativeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UserRepresentativeCallerSession struct {
	Contract *UserRepresentativeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// UserRepresentativeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UserRepresentativeTransactorSession struct {
	Contract     *UserRepresentativeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// UserRepresentativeRaw is an auto generated low-level Go binding around an Ethereum contract.
type UserRepresentativeRaw struct {
	Contract *UserRepresentative // Generic contract binding to access the raw methods on
}

// UserRepresentativeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UserRepresentativeCallerRaw struct {
	Contract *UserRepresentativeCaller // Generic read-only contract binding to access the raw methods on
}

// UserRepresentativeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UserRepresentativeTransactorRaw struct {
	Contract *UserRepresentativeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUserRepresentative creates a new instance of UserRepresentative, bound to a specific deployed contract.
func NewUserRepresentative(address common.Address, backend bind.ContractBackend) (*UserRepresentative, error) {
	contract, err := bindUserRepresentative(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &UserRepresentative{UserRepresentativeCaller: UserRepresentativeCaller{contract: contract}, UserRepresentativeTransactor: UserRepresentativeTransactor{contract: contract}, UserRepresentativeFilterer: UserRepresentativeFilterer{contract: contract}}, nil
}

// NewUserRepresentativeCaller creates a new read-only instance of UserRepresentative, bound to a specific deployed contract.
func NewUserRepresentativeCaller(address common.Address, caller bind.ContractCaller) (*UserRepresentativeCaller, error) {
	contract, err := bindUserRepresentative(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UserRepresentativeCaller{contract: contract}, nil
}

// NewUserRepresentativeTransactor creates a new write-only instance of UserRepresentative, bound to a specific deployed contract.
func NewUserRepresentativeTransactor(address common.Address, transactor bind.ContractTransactor) (*UserRepresentativeTransactor, error) {
	contract, err := bindUserRepresentative(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UserRepresentativeTransactor{contract: contract}, nil
}

// NewUserRepresentativeFilterer creates a new log filterer instance of UserRepresentative, bound to a specific deployed contract.
func NewUserRepresentativeFilterer(address common.Address, filterer bind.ContractFilterer) (*UserRepresentativeFilterer, error) {
	contract, err := bindUserRepresentative(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UserRepresentativeFilterer{contract: contract}, nil
}

// bindUserRepresentative binds a generic wrapper to an already deployed contract.
func bindUserRepresentative(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(UserRepresentativeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UserRepresentative *UserRepresentativeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _UserRepresentative.Contract.UserRepresentativeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UserRepresentative *UserRepresentativeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UserRepresentative.Contract.UserRepresentativeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UserRepresentative *UserRepresentativeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UserRepresentative.Contract.UserRepresentativeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UserRepresentative *UserRepresentativeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _UserRepresentative.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UserRepresentative *UserRepresentativeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UserRepresentative.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UserRepresentative *UserRepresentativeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UserRepresentative.Contract.contract.Transact(opts, method, params...)
}

// Approve is a paid mutator transaction binding the contract method 0xe1f21c67.
//
// Solidity: function approve(address token, address who, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeTransactor) Approve(opts *bind.TransactOpts, token common.Address, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.contract.Transact(opts, "approve", token, who, amount)
}

// Approve is a paid mutator transaction binding the contract method 0xe1f21c67.
//
// Solidity: function approve(address token, address who, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeSession) Approve(token common.Address, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.Contract.Approve(&_UserRepresentative.TransactOpts, token, who, amount)
}

// Approve is a paid mutator transaction binding the contract method 0xe1f21c67.
//
// Solidity: function approve(address token, address who, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeTransactorSession) Approve(token common.Address, who common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.Contract.Approve(&_UserRepresentative.TransactOpts, token, who, amount)
}

// Migrate is a paid mutator transaction binding the contract method 0xad68ebf7.
//
// Solidity: function migrate(address migrator, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeTransactor) Migrate(opts *bind.TransactOpts, migrator common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.contract.Transact(opts, "migrate", migrator, amount)
}

// Migrate is a paid mutator transaction binding the contract method 0xad68ebf7.
//
// Solidity: function migrate(address migrator, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeSession) Migrate(migrator common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.Contract.Migrate(&_UserRepresentative.TransactOpts, migrator, amount)
}

// Migrate is a paid mutator transaction binding the contract method 0xad68ebf7.
//
// Solidity: function migrate(address migrator, uint256 amount) returns()
func (_UserRepresentative *UserRepresentativeTransactorSession) Migrate(migrator common.Address, amount *big.Int) (*types.Transaction, error) {
	return _UserRepresentative.Contract.Migrate(&_UserRepresentative.TransactOpts, migrator, amount)
}

// MigrateAll is a paid mutator transaction binding the contract method 0x5a8cadb1.
//
// Solidity: function migrateAll(address migrator) returns()
func (_UserRepresentative *UserRepresentativeTransactor) MigrateAll(opts *bind.TransactOpts, migrator common.Address) (*types.Transaction, error) {
	return _UserRepresentative.contract.Transact(opts, "migrateAll", migrator)
}

// MigrateAll is a paid mutator transaction binding the contract method 0x5a8cadb1.
//
// Solidity: function migrateAll(address migrator) returns()
func (_UserRepresentative *UserRepresentativeSession) MigrateAll(migrator common.Address) (*types.Transaction, error) {
	return _UserRepresentative.Contract.MigrateAll(&_UserRepresentative.TransactOpts, migrator)
}

// MigrateAll is a paid mutator transaction binding the contract method 0x5a8cadb1.
//
// Solidity: function migrateAll(address migrator) returns()
func (_UserRepresentative *UserRepresentativeTransactorSession) MigrateAll(migrator common.Address) (*types.Transaction, error) {
	return _UserRepresentative.Contract.MigrateAll(&_UserRepresentative.TransactOpts, migrator)
}

// ValidatorEventsABI is the input ABI used to generate the binding from.
const ValidatorEventsABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"startingETHDKG\",\"type\":\"bool\"}],\"name\":\"SnapshotTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorQueued\",\"type\":\"event\"}]"

// ValidatorEvents is an auto generated Go binding around an Ethereum contract.
type ValidatorEvents struct {
	ValidatorEventsCaller     // Read-only binding to the contract
	ValidatorEventsTransactor // Write-only binding to the contract
	ValidatorEventsFilterer   // Log filterer for contract events
}

// ValidatorEventsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorEventsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorEventsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorEventsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorEventsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorEventsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorEventsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorEventsSession struct {
	Contract     *ValidatorEvents  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValidatorEventsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorEventsCallerSession struct {
	Contract *ValidatorEventsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ValidatorEventsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorEventsTransactorSession struct {
	Contract     *ValidatorEventsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ValidatorEventsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorEventsRaw struct {
	Contract *ValidatorEvents // Generic contract binding to access the raw methods on
}

// ValidatorEventsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorEventsCallerRaw struct {
	Contract *ValidatorEventsCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorEventsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorEventsTransactorRaw struct {
	Contract *ValidatorEventsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorEvents creates a new instance of ValidatorEvents, bound to a specific deployed contract.
func NewValidatorEvents(address common.Address, backend bind.ContractBackend) (*ValidatorEvents, error) {
	contract, err := bindValidatorEvents(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorEvents{ValidatorEventsCaller: ValidatorEventsCaller{contract: contract}, ValidatorEventsTransactor: ValidatorEventsTransactor{contract: contract}, ValidatorEventsFilterer: ValidatorEventsFilterer{contract: contract}}, nil
}

// NewValidatorEventsCaller creates a new read-only instance of ValidatorEvents, bound to a specific deployed contract.
func NewValidatorEventsCaller(address common.Address, caller bind.ContractCaller) (*ValidatorEventsCaller, error) {
	contract, err := bindValidatorEvents(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsCaller{contract: contract}, nil
}

// NewValidatorEventsTransactor creates a new write-only instance of ValidatorEvents, bound to a specific deployed contract.
func NewValidatorEventsTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorEventsTransactor, error) {
	contract, err := bindValidatorEvents(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsTransactor{contract: contract}, nil
}

// NewValidatorEventsFilterer creates a new log filterer instance of ValidatorEvents, bound to a specific deployed contract.
func NewValidatorEventsFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorEventsFilterer, error) {
	contract, err := bindValidatorEvents(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsFilterer{contract: contract}, nil
}

// bindValidatorEvents binds a generic wrapper to an already deployed contract.
func bindValidatorEvents(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorEventsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorEvents *ValidatorEventsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorEvents.Contract.ValidatorEventsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorEvents *ValidatorEventsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorEvents.Contract.ValidatorEventsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorEvents *ValidatorEventsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorEvents.Contract.ValidatorEventsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorEvents *ValidatorEventsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorEvents.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorEvents *ValidatorEventsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorEvents.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorEvents *ValidatorEventsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorEvents.Contract.contract.Transact(opts, method, params...)
}

// ValidatorEventsSnapshotTakenIterator is returned from FilterSnapshotTaken and is used to iterate over the raw logs and unpacked data for SnapshotTaken events raised by the ValidatorEvents contract.
type ValidatorEventsSnapshotTakenIterator struct {
	Event *ValidatorEventsSnapshotTaken // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorEventsSnapshotTakenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorEventsSnapshotTaken)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorEventsSnapshotTaken)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorEventsSnapshotTakenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorEventsSnapshotTakenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorEventsSnapshotTaken represents a SnapshotTaken event raised by the ValidatorEvents contract.
type ValidatorEventsSnapshotTaken struct {
	ChainId        uint32
	Epoch          *big.Int
	Height         uint32
	Validator      common.Address
	StartingETHDKG bool
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterSnapshotTaken is a free log retrieval operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorEvents *ValidatorEventsFilterer) FilterSnapshotTaken(opts *bind.FilterOpts, epoch []*big.Int, validator []common.Address) (*ValidatorEventsSnapshotTakenIterator, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.FilterLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsSnapshotTakenIterator{contract: _ValidatorEvents.contract, event: "SnapshotTaken", logs: logs, sub: sub}, nil
}

// WatchSnapshotTaken is a free log subscription operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorEvents *ValidatorEventsFilterer) WatchSnapshotTaken(opts *bind.WatchOpts, sink chan<- *ValidatorEventsSnapshotTaken, epoch []*big.Int, validator []common.Address) (event.Subscription, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.WatchLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorEventsSnapshotTaken)
				if err := _ValidatorEvents.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSnapshotTaken is a log parse operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorEvents *ValidatorEventsFilterer) ParseSnapshotTaken(log types.Log) (*ValidatorEventsSnapshotTaken, error) {
	event := new(ValidatorEventsSnapshotTaken)
	if err := _ValidatorEvents.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorEventsValidatorCreatedIterator is returned from FilterValidatorCreated and is used to iterate over the raw logs and unpacked data for ValidatorCreated events raised by the ValidatorEvents contract.
type ValidatorEventsValidatorCreatedIterator struct {
	Event *ValidatorEventsValidatorCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorEventsValidatorCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorEventsValidatorCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorEventsValidatorCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorEventsValidatorCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorEventsValidatorCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorEventsValidatorCreated represents a ValidatorCreated event raised by the ValidatorEvents contract.
type ValidatorEventsValidatorCreated struct {
	Validator common.Address
	Signer    common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorCreated is a free log retrieval operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) FilterValidatorCreated(opts *bind.FilterOpts, validator []common.Address, signer []common.Address) (*ValidatorEventsValidatorCreatedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorEvents.contract.FilterLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsValidatorCreatedIterator{contract: _ValidatorEvents.contract, event: "ValidatorCreated", logs: logs, sub: sub}, nil
}

// WatchValidatorCreated is a free log subscription operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) WatchValidatorCreated(opts *bind.WatchOpts, sink chan<- *ValidatorEventsValidatorCreated, validator []common.Address, signer []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorEvents.contract.WatchLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorEventsValidatorCreated)
				if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorCreated is a log parse operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) ParseValidatorCreated(log types.Log) (*ValidatorEventsValidatorCreated, error) {
	event := new(ValidatorEventsValidatorCreated)
	if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorEventsValidatorJoinedIterator is returned from FilterValidatorJoined and is used to iterate over the raw logs and unpacked data for ValidatorJoined events raised by the ValidatorEvents contract.
type ValidatorEventsValidatorJoinedIterator struct {
	Event *ValidatorEventsValidatorJoined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorEventsValidatorJoinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorEventsValidatorJoined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorEventsValidatorJoined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorEventsValidatorJoinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorEventsValidatorJoinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorEventsValidatorJoined represents a ValidatorJoined event raised by the ValidatorEvents contract.
type ValidatorEventsValidatorJoined struct {
	Validator common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorJoined is a free log retrieval operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) FilterValidatorJoined(opts *bind.FilterOpts, validator []common.Address) (*ValidatorEventsValidatorJoinedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.FilterLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsValidatorJoinedIterator{contract: _ValidatorEvents.contract, event: "ValidatorJoined", logs: logs, sub: sub}, nil
}

// WatchValidatorJoined is a free log subscription operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) WatchValidatorJoined(opts *bind.WatchOpts, sink chan<- *ValidatorEventsValidatorJoined, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.WatchLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorEventsValidatorJoined)
				if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorJoined is a log parse operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorEvents *ValidatorEventsFilterer) ParseValidatorJoined(log types.Log) (*ValidatorEventsValidatorJoined, error) {
	event := new(ValidatorEventsValidatorJoined)
	if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorEventsValidatorLeftIterator is returned from FilterValidatorLeft and is used to iterate over the raw logs and unpacked data for ValidatorLeft events raised by the ValidatorEvents contract.
type ValidatorEventsValidatorLeftIterator struct {
	Event *ValidatorEventsValidatorLeft // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorEventsValidatorLeftIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorEventsValidatorLeft)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorEventsValidatorLeft)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorEventsValidatorLeftIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorEventsValidatorLeftIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorEventsValidatorLeft represents a ValidatorLeft event raised by the ValidatorEvents contract.
type ValidatorEventsValidatorLeft struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorLeft is a free log retrieval operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) FilterValidatorLeft(opts *bind.FilterOpts, validator []common.Address) (*ValidatorEventsValidatorLeftIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.FilterLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsValidatorLeftIterator{contract: _ValidatorEvents.contract, event: "ValidatorLeft", logs: logs, sub: sub}, nil
}

// WatchValidatorLeft is a free log subscription operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) WatchValidatorLeft(opts *bind.WatchOpts, sink chan<- *ValidatorEventsValidatorLeft, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.WatchLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorEventsValidatorLeft)
				if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorLeft is a log parse operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) ParseValidatorLeft(log types.Log) (*ValidatorEventsValidatorLeft, error) {
	event := new(ValidatorEventsValidatorLeft)
	if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorEventsValidatorQueuedIterator is returned from FilterValidatorQueued and is used to iterate over the raw logs and unpacked data for ValidatorQueued events raised by the ValidatorEvents contract.
type ValidatorEventsValidatorQueuedIterator struct {
	Event *ValidatorEventsValidatorQueued // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorEventsValidatorQueuedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorEventsValidatorQueued)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorEventsValidatorQueued)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorEventsValidatorQueuedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorEventsValidatorQueuedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorEventsValidatorQueued represents a ValidatorQueued event raised by the ValidatorEvents contract.
type ValidatorEventsValidatorQueued struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorQueued is a free log retrieval operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) FilterValidatorQueued(opts *bind.FilterOpts, validator []common.Address) (*ValidatorEventsValidatorQueuedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.FilterLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorEventsValidatorQueuedIterator{contract: _ValidatorEvents.contract, event: "ValidatorQueued", logs: logs, sub: sub}, nil
}

// WatchValidatorQueued is a free log subscription operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) WatchValidatorQueued(opts *bind.WatchOpts, sink chan<- *ValidatorEventsValidatorQueued, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorEvents.contract.WatchLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorEventsValidatorQueued)
				if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorQueued is a log parse operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorEvents *ValidatorEventsFilterer) ParseValidatorQueued(log types.Log) (*ValidatorEventsValidatorQueued, error) {
	event := new(ValidatorEventsValidatorQueued)
	if err := _ValidatorEvents.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsABI is the input ABI used to generate the binding from.
const ValidatorsABI = "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxValidators\",\"type\":\"uint8\"},{\"internalType\":\"contractRegistry\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"startingETHDKG\",\"type\":\"bool\"}],\"name\":\"SnapshotTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorQueued\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"_madID\",\"type\":\"uint256[2]\"}],\"name\":\"addValidator\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmValidators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getChainIdFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getMadHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawBlockClaimsSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawSignatureSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"getValidatorPublicKey\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"majorFine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"majorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"minorFine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"_madID\",\"type\":\"uint256[2]\"}],\"name\":\"queueValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reloadRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"_madID\",\"type\":\"uint256[2]\"}],\"name\":\"removeValidator\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_majorStakeFine\",\"type\":\"uint256\"}],\"name\":\"setMajorStakeFine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumStake\",\"type\":\"uint256\"}],\"name\":\"setMinimumStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minorStakeFine\",\"type\":\"uint256\"}],\"name\":\"setMinorStakeFine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAmount\",\"type\":\"uint256\"}],\"name\":\"setRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardBonus\",\"type\":\"uint256\"}],\"name\":\"setRewardBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_validatorMaxCount\",\"type\":\"uint8\"}],\"name\":\"setValidatorMaxCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signatureGroup\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_bclaims\",\"type\":\"bytes\"}],\"name\":\"snapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorMaxCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ValidatorsBin is the compiled bytecode used for deploying new contracts.
var ValidatorsBin = "0x6080604052620000196200021260201b62004e491760201c565b6005600082015181600201556020820151816003015550503480156200003e57600080fd5b506040516200535738038062005357833981810160405260408110156200006457600080fd5b81019080805190602001909291908051906020019092919050505033600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a233600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555062000177600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166200023860201b60201c565b600160138190555081601260006101000a81548160ff021916908360ff16021790555080600b60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550620f4240600d8190555062030d40600e8190555061c350600f819055506103e86010819055506103e86011819055505050620003bc565b6200021c620003a2565b6040518060400160405280600181526020016000815250905090565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620002de5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000335576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180620053266031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b604051806040016040528060008152602001600081525090565b614f5a80620003cc6000396000f3fe608060405234801561001057600080fd5b50600436106102485760003560e01c806381d3cb141161013b578063d2a2c55c116100b8578063f7b2a7be1161007c578063f7b2a7be14610b9b578063f95d80fa14610bb9578063facd743b14610be7578063fad8b32a14610c43578063fdf553cf14610c8757610248565b8063d2a2c55c14610a3f578063e348da1314610a83578063e380b22814610ac7578063eb6320c714610b15578063ec5ffac214610b7d57610248565b8063a8a65a78116100ff578063a8a65a7814610940578063ad43d8451461096e578063b7ab4db51461098c578063be9a6555146109eb578063bf7e214f146109f557610248565b806381d3cb14146107ca578063844469b21461082c57806389afcb44146108945780638da5cb5b146108d8578063900cf0cf1461092257610248565b806335b6c632116101c95780636372fe511161018d5780636372fe51146106715780636d0591261461071857806375f12b211461073657806378146c2f146107585780637a9e5e4b1461078657610248565b806335b6c6321461049657806335c6a1631461053d5780634e6f4a221461055f5780634f4ea614146105df57806357b4f82a1461062d57610248565b80631476601d116102105780631476601d146103b157806319f74669146103bb578063233e99031461040957806329693c5c146104375780632cab37f71461046557610248565b806307da68f51461024d57806308ca1f251461025757806309f0d45d146103255780630f43a6771461034957806313af40351461036d575b600080fd5b610255610ca5565b005b6103236004803603604081101561026d57600080fd5b810190808035906020019064010000000081111561028a57600080fd5b82018360208201111561029c57600080fd5b803590602001918460018302840111640100000000831117156102be57600080fd5b9091929391929390803590602001906401000000008111156102df57600080fd5b8201836020820111156102f157600080fd5b8035906020019184600183028401116401000000008311171561031357600080fd5b9091929391929390505050610e1e565b005b61032d61144a565b604051808260ff1660ff16815260200191505060405180910390f35b61035161145d565b604051808260ff1660ff16815260200191505060405180910390f35b6103af6004803603602081101561038357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611470565b005b6103b96115b9565b005b6103e7600480360360208110156103d157600080fd5b8101908080359060200190929190505050611f81565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6104356004803603602081101561041f57600080fd5b8101908080359060200190929190505050611fb1565b005b6104636004803603602081101561044d57600080fd5b81019080803590602001909291905050506120b5565b005b6104946004803603602081101561047b57600080fd5b81019080803560ff1690602001909291905050506121b9565b005b6104c2600480360360208110156104ac57600080fd5b81019080803590602001909291905050506122d1565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105025780820151818401526020810190506104e7565b50505050905090810190601f16801561052f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610545612389565b604051808215151515815260200191505060405180910390f35b6105a16004803603602081101561057557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506124fc565b6040518082600260200280838360005b838110156105cc5780820151818401526020810190506105b1565b5050505090500191505060405180910390f35b61060b600480360360208110156105f557600080fd5b8101908080359060200190929190505050612645565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b61066f6004803603602081101561064357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612675565b005b61069d6004803603602081101561068757600080fd5b81019080803590602001909291905050506128dc565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156106dd5780820151818401526020810190506106c2565b50505050905090810190601f16801561070a5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610720612994565b6040518082815260200191505060405180910390f35b61073e61299a565b604051808215151515815260200191505060405180910390f35b6107846004803603602081101561076e57600080fd5b81019080803590602001909291905050506129ad565b005b6107c86004803603602081101561079c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612ab1565b005b610816600480360360608110156107e057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080604001909192919290505050612bf8565b6040518082815260200191505060405180910390f35b6108786004803603606081101561084257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080604001909192919290505050612d15565b604051808260ff1660ff16815260200191505060405180910390f35b6108d6600480360360208110156108aa57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506134d8565b005b6108e061373f565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61092a613765565b6040518082815260200191505060405180910390f35b61096c6004803603602081101561095657600080fd5b810190808035906020019092919050505061376b565b005b61097661386f565b6040518082815260200191505060405180910390f35b610994613875565b6040518080602001828103825283818151815260200191508051906020019060200280838360005b838110156109d75780820151818401526020810190506109bc565b505050509050019250505060405180910390f35b6109f3613903565b005b6109fd613a7d565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610a8160048036036020811015610a5557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613aa2565b005b610ac560048036036020811015610a9957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613d09565b005b610af360048036036020811015610add57600080fd5b8101908080359060200190929190505050613e70565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b610b6160048036036060811015610b2b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080604001909192919290505050613ea0565b604051808260ff1660ff16815260200191505060405180910390f35b610b85613f6e565b6040518082815260200191505060405180910390f35b610ba3613f74565b6040518082815260200191505060405180910390f35b610be560048036036020811015610bcf57600080fd5b8101908080359060200190929190505050613f7a565b005b610c2960048036036020811015610bfd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061407e565b604051808215151515815260200191505060405180910390f35b610c8560048036036020811015610c5957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506141bb565b005b610c8f614392565b6040518082815260200191505060405180910390f35b610cd3336000357fffffffff0000000000000000000000000000000000000000000000000000000016614398565b610d45576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60008060006004359250602435915034905060018060146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b600160149054906101000a900460ff1615610ea1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b60006060601a60019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16868686866040516024018080602001806020018381038352878782818152602001925080828437600081840152601f19601f8201169050808301925050508381038252858582818152602001925080828437600081840152601f19601f82011690508083019250505096505050505050506040516020818303038152906040527f08ca1f25000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310610fff5780518252602082019150602081019050602083039250610fdc565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461105f576040519150601f19603f3d011682016040523d82523d6000602084013e611064565b606091505b5091509150816110bf576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180614edb6025913960400191505060405180910390fd5b60008180602001905160208110156110d657600080fd5b81019080805190602001909291905050509050801561117257600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663825711956040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561115957600080fd5b505af115801561116d573d6000803e3d6000fd5b505050505b600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631dd6b9b16013546040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b1580156111e957600080fd5b505af11580156111fd573d6000803e3d6000fd5b5050505060008090505b60168054905081101561134c57600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630ddb07ad6016838154811061125f57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166010546001601354016040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018281526020019350505050602060405180830381600087803b15801561130357600080fd5b505af1158015611317573d6000803e3d6000fd5b505050506040513d602081101561132d57600080fd5b8101908080519060200190929190505050508080600101915050611207565b50600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630ddb07ad336011546001601354016040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018281526020019350505050602060405180830381600087803b15801561140557600080fd5b505af1158015611419573d6000803e3d6000fd5b505050506040513d602081101561142f57600080fd5b81019080805190602001909291905050505050505050505050565b601260009054906101000a900460ff1681565b601a60009054906101000a900460ff1681565b61149e336000357fffffffff0000000000000000000000000000000000000000000000000000000016614398565b611510576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061165e5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6116b3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b6000600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600981526020017f63727970746f2f763100000000000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561177857808201518184015260208101905061175d565b50505050905090810190601f1680156117a55780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156117c257600080fd5b505afa1580156117d6573d6000803e3d6000fd5b505050506040513d60208110156117ec57600080fd5b8101908080519060200190929190505050905080600960006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156118e3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f696e76616c6964206164647265737320666f722063727970746f00000000000081525060200191505060405180910390fd5b6000600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600981526020017f657468646b672f763100000000000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156119a857808201518184015260208101905061198d565b50505050905090810190601f1680156119d55780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156119f257600080fd5b505afa158015611a06573d6000803e3d6000fd5b505050506040513d6020811015611a1c57600080fd5b8101908080519060200190929190505050905080600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611b13576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f696e76616c6964206164647265737320666f7220657468646b6700000000000081525060200191505060405180910390fd5b611b1c81613d09565b6000600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280600a81526020017f7374616b696e672f7631000000000000000000000000000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611be1578082015181840152602081019050611bc6565b50505050905090810190601f168015611c0e5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b158015611c2b57600080fd5b505afa158015611c3f573d6000803e3d6000fd5b505050506040513d6020811015611c5557600080fd5b8101908080519060200190929190505050905080600c60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611d4c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601b8152602001807f696e76616c6964206164647265737320666f72207374616b696e67000000000081525060200191505060405180910390fd5b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f67187ac6040518060400160405280601581526020017f76616c696461746f7273536e617073686f742f763100000000000000000000008152506040518263ffffffff1660e01b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611e0f578082015181840152602081019050611df4565b50505050905090810190601f168015611e3c5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b158015611e5957600080fd5b505afa158015611e6d573d6000803e3d6000fd5b505050506040513d6020811015611e8357600080fd5b8101908080519060200190929190505050601a60016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff16601a60019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415611f7c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180614f006025913960400191505060405180910390fd5b505050565b6000601b600083815260200190815260200160002060000160019054906101000a900463ffffffff169050919050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806120565750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6120ab576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b80600d8190555050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061215a5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6121af576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b80600f8190555050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061225e5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6122b3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b80601260006101000a81548160ff021916908360ff16021790555050565b6060601b60008381526020019081526020016000206002018054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561237d5780601f106123525761010080835404028352916020019161237d565b820191906000526020600020905b81548152906001019060200180831161236057829003601f168201915b50505050509050919050565b6000600160149054906101000a900460ff161561240e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b5b601260009054906101000a900460ff1660ff16601a60009054906101000a900460ff1660ff1610801561244b5750600061244960056145f1565b115b156124f557600061245c6005614633565b9050612466614db4565b601960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206002806020026040519081016040528092919082600280156124dc576020028201915b8154815260200190600101908083116124c8575b505050505090506124ed82826147a7565b50505061240f565b6001905090565b612504614db4565b601860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166125c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f56616c696461746f72206e6f742070726573656e742e0000000000000000000081525060200191505060405180910390fd5b601960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015612639576020028201915b815481526020019060010190808311612625575b50505050509050919050565b6000601b600083815260200190815260200160002060030160049054906101000a900463ffffffff169050919050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061271a5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61276f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b600160149054906101000a900460ff16156127f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663db1e466282600e546040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561289d57600080fd5b505af11580156128b1573d6000803e3d6000fd5b505050506040513d60208110156128c757600080fd5b81019080805190602001909291905050505050565b6060601b60008381526020019081526020016000206001018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156129885780601f1061295d57610100808354040283529160200191612988565b820191906000526020600020905b81548152906001019060200180831161296b57829003601f168201915b50505050509050919050565b600f5481565b600160149054906101000a900460ff1681565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480612a525750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612aa7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b80600e8190555050565b612adf336000357fffffffff0000000000000000000000000000000000000000000000000000000016614398565b612b51576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b6000600160149054906101000a900460ff1615612c7d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b612c91836005614b1690919063ffffffff16565b8273ffffffffffffffffffffffffffffffffffffffff167fb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d836040518082600260200280828437600081840152601f19601f82011690508083019250505091505060405180910390a2601a60009054906101000a900460ff1660ff16905092915050565b6000600160149054906101000a900460ff1615612d9a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b601860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16612e59576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f56616c696461746f72206e6f742070726573656e74000000000000000000000081525060200191505060405180910390fd5b6000601760008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050612ea5614db4565b601960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600280602002604051908101604052809291908260028015612f1b576020028201915b815481526020019060010190808311612f07575b5050505050905083600060028110612f2f57fe5b602002013581600060028110612f4157fe5b602002015114612f9c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180614e886022913960400191505060405180910390fd5b83600160028110612fa957fe5b602002013581600160028110612fbb57fe5b602002015114613016576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180614e886022913960400191505060405180910390fd5b601760008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009055601860008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055601960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006130f39190614dd6565b6000600160168054905003905060006016828154811061310f57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905083601760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506016828154811061318d57fe5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16601685815481106131c557fe5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601680548061321857fe5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905590556000600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166335ba4daf896040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156132ee57600080fd5b505afa158015613302573d6000803e3d6000fd5b505050506040513d602081101561331857600080fd5b81019080805190602001909291905050509050600081111561343557600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e29dda9289836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156133dd57600080fd5b505af11580156133f1573d6000803e3d6000fd5b505050506040513d602081101561340757600080fd5b8101908080519060200190929190505050506001601560006101000a81548160ff0219169083151502179055505b8773ffffffffffffffffffffffffffffffffffffffff167f319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94886040518082600260200280828437600081840152601f19601f82011690508083019250505091505060405180910390a2601a600081819054906101000a900460ff166001900391906101000a81548160ff021916908360ff16021790559550505050505092915050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061357d5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6135d2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b600160149054906101000a900460ff1615613655576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639c70287c82600d546040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561370057600080fd5b505af1158015613714573d6000803e3d6000fd5b505050506040513d602081101561372a57600080fd5b81019080805190602001909291905050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60135481565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806138105750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b613865576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b8060108190555050565b600e5481565b606060168054806020026020016040519081016040528092919081815260200182805480156138f957602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116138af575b5050505050905090565b613931336000357fffffffff0000000000000000000000000000000000000000000000000000000016614398565b6139a3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506000600160146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613b475750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b613b9c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b600160149054906101000a900460ff1615613c1f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663db1e466282600f546040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015613cca57600080fd5b505af1158015613cde573d6000803e3d6000fd5b505050506040513d6020811015613cf457600080fd5b81019080805190602001909291905050505050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613dae5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b613e03576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b6000601b600083815260200190815260200160002060030160009054906101000a900463ffffffff169050919050565b6000600160149054906101000a900460ff1615613f25576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b613f6683836002806020026040519081016040528092919082600260200280828437600081840152601f19601f8201169050808301925050505050506147a7565b905092915050565b600d5481565b60105481565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061401f5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b614074576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b8060118190555050565b6000601860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1680156141b45750600d54600c60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166335ba4daf846040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561417657600080fd5b505afa15801561418a573d6000803e3d6000fd5b505050506040513d60208110156141a057600080fd5b810190808051906020019092919050505010155b9050919050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806142605750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6142b5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526031815260200180614eaa6031913960400191505060405180910390fd5b60016003541161432d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556003600081548092919060019003919050555050565b60115481565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156143d757600190506145eb565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561443657600190506145eb565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141561449557600090506145eb565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b1580156145ad57600080fd5b505afa1580156145c1573d6000803e3d6000fd5b505050506040513d60208110156145d757600080fd5b810190808051906020019092919050505090505b92915050565b6000808260030154905061460f600182614cae90919063ffffffff16565b9050614628836002015482614d3190919063ffffffff16565b905080915050919050565b60008160020154826003015410156146b3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f517565756520697320656d70747900000000000000000000000000000000000081525060200191505060405180910390fd5b60008260010160008460020154815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508260000160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558260010160008460020154815260200190815260200160002060006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905561479660018460020154614cae90919063ffffffff16565b836002018190555080915050919050565b6000601860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161580156148265750601260009054906101000a900460ff1660ff16601a60009054906101000a900460ff1660ff16105b614898576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e277420616464206d6f72652076616c696461746f72732e00000000000081525060200191505060405180910390fd5b601860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16614a88576016839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160168054905003601760008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506001601860008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555081601960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020906002614a3e929190614de4565b506001601560006101000a81548160ff021916908315150217905550601a600081819054906101000a900460ff1660010191906101000a81548160ff021916908360ff1602179055505b8273ffffffffffffffffffffffffffffffffffffffff167f8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9836040518082600260200280838360005b83811015614aec578082015181840152602081019050614ad1565b5050505090500191505060405180910390a2601a60009054906101000a900460ff16905092915050565b8160000160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615614bd8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f4475706c696361746520656e7472696573206e6f7420616c6c6f77656400000081525060200191505060405180910390fd5b614bf060018360030154614cae90919063ffffffff16565b8260030181905550808260010160008460030154815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060018260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505050565b6000828284019150811015614d2b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b6000828284039150811115614dae576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f64732d6d6174682d7375622d756e646572666c6f77000000000000000000000081525060200191505060405180910390fd5b92915050565b6040518060400160405280600290602082028036833780820191505090505090565b506000815560010160009055565b8260028101928215614e13579160200282015b82811115614e12578251825591602001919060010190614df7565b5b509050614e209190614e24565b5090565b614e4691905b80821115614e42576000816000905550600101614e2a565b5090565b90565b614e51614e6d565b6040518060400160405280600181526020016000815250905090565b60405180604001604052806000815260200160008152509056fe56616c696461746f7220646f65736e2774206d61746368207075626c6963206b657946756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e64656c656761746563616c6c206661696c656420666f7220736e617073686f74282e2e2e29696e76616c6964206164647265737320666f7220736e617073686f7420636f6e7472616374a26469706673582212203dd1166dd28c88fcadfcd48c5a9cdae12854d58379dbd4fa9bacc88d078ae7b164736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployValidators deploys a new Ethereum contract, binding an instance of Validators to it.
func DeployValidators(auth *bind.TransactOpts, backend bind.ContractBackend, maxValidators uint8, registry_ common.Address) (common.Address, *types.Transaction, *Validators, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsBin), backend, maxValidators, registry_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Validators{ValidatorsCaller: ValidatorsCaller{contract: contract}, ValidatorsTransactor: ValidatorsTransactor{contract: contract}, ValidatorsFilterer: ValidatorsFilterer{contract: contract}}, nil
}

// Validators is an auto generated Go binding around an Ethereum contract.
type Validators struct {
	ValidatorsCaller     // Read-only binding to the contract
	ValidatorsTransactor // Write-only binding to the contract
	ValidatorsFilterer   // Log filterer for contract events
}

// ValidatorsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsSession struct {
	Contract     *Validators       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValidatorsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsCallerSession struct {
	Contract *ValidatorsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ValidatorsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsTransactorSession struct {
	Contract     *ValidatorsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ValidatorsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsRaw struct {
	Contract *Validators // Generic contract binding to access the raw methods on
}

// ValidatorsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsCallerRaw struct {
	Contract *ValidatorsCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsTransactorRaw struct {
	Contract *ValidatorsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidators creates a new instance of Validators, bound to a specific deployed contract.
func NewValidators(address common.Address, backend bind.ContractBackend) (*Validators, error) {
	contract, err := bindValidators(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Validators{ValidatorsCaller: ValidatorsCaller{contract: contract}, ValidatorsTransactor: ValidatorsTransactor{contract: contract}, ValidatorsFilterer: ValidatorsFilterer{contract: contract}}, nil
}

// NewValidatorsCaller creates a new read-only instance of Validators, bound to a specific deployed contract.
func NewValidatorsCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsCaller, error) {
	contract, err := bindValidators(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsCaller{contract: contract}, nil
}

// NewValidatorsTransactor creates a new write-only instance of Validators, bound to a specific deployed contract.
func NewValidatorsTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsTransactor, error) {
	contract, err := bindValidators(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsTransactor{contract: contract}, nil
}

// NewValidatorsFilterer creates a new log filterer instance of Validators, bound to a specific deployed contract.
func NewValidatorsFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsFilterer, error) {
	contract, err := bindValidators(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsFilterer{contract: contract}, nil
}

// bindValidators binds a generic wrapper to an already deployed contract.
func bindValidators(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Validators *ValidatorsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Validators.Contract.ValidatorsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Validators *ValidatorsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.Contract.ValidatorsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Validators *ValidatorsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Validators.Contract.ValidatorsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Validators *ValidatorsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Validators.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Validators *ValidatorsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Validators *ValidatorsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Validators.Contract.contract.Transact(opts, method, params...)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Validators *ValidatorsCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Validators *ValidatorsSession) Authority() (common.Address, error) {
	return _Validators.Contract.Authority(&_Validators.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_Validators *ValidatorsCallerSession) Authority() (common.Address, error) {
	return _Validators.Contract.Authority(&_Validators.CallOpts)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_Validators *ValidatorsCaller) Epoch(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "epoch")
	return *ret0, err
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_Validators *ValidatorsSession) Epoch() (*big.Int, error) {
	return _Validators.Contract.Epoch(&_Validators.CallOpts)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_Validators *ValidatorsCallerSession) Epoch() (*big.Int, error) {
	return _Validators.Contract.Epoch(&_Validators.CallOpts)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCaller) GetChainIdFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getChainIdFromSnapshot", _epoch)
	return *ret0, err
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetChainIdFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCallerSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetChainIdFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCaller) GetHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetHeightFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCallerSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetHeightFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCaller) GetMadHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getMadHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetMadHeightFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_Validators *ValidatorsCallerSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _Validators.Contract.GetMadHeightFromSnapshot(&_Validators.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsCaller) GetRawBlockClaimsSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getRawBlockClaimsSnapshot", _epoch)
	return *ret0, err
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _Validators.Contract.GetRawBlockClaimsSnapshot(&_Validators.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsCallerSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _Validators.Contract.GetRawBlockClaimsSnapshot(&_Validators.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsCaller) GetRawSignatureSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getRawSignatureSnapshot", _epoch)
	return *ret0, err
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _Validators.Contract.GetRawSignatureSnapshot(&_Validators.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_Validators *ValidatorsCallerSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _Validators.Contract.GetRawSignatureSnapshot(&_Validators.CallOpts, _epoch)
}

// GetValidatorPublicKey is a free data retrieval call binding the contract method 0x4e6f4a22.
//
// Solidity: function getValidatorPublicKey(address _validator) view returns(uint256[2])
func (_Validators *ValidatorsCaller) GetValidatorPublicKey(opts *bind.CallOpts, _validator common.Address) ([2]*big.Int, error) {
	var (
		ret0 = new([2]*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getValidatorPublicKey", _validator)
	return *ret0, err
}

// GetValidatorPublicKey is a free data retrieval call binding the contract method 0x4e6f4a22.
//
// Solidity: function getValidatorPublicKey(address _validator) view returns(uint256[2])
func (_Validators *ValidatorsSession) GetValidatorPublicKey(_validator common.Address) ([2]*big.Int, error) {
	return _Validators.Contract.GetValidatorPublicKey(&_Validators.CallOpts, _validator)
}

// GetValidatorPublicKey is a free data retrieval call binding the contract method 0x4e6f4a22.
//
// Solidity: function getValidatorPublicKey(address _validator) view returns(uint256[2])
func (_Validators *ValidatorsCallerSession) GetValidatorPublicKey(_validator common.Address) ([2]*big.Int, error) {
	return _Validators.Contract.GetValidatorPublicKey(&_Validators.CallOpts, _validator)
}

// GetValidators is a free data retrieval call binding the contract method 0xb7ab4db5.
//
// Solidity: function getValidators() view returns(address[])
func (_Validators *ValidatorsCaller) GetValidators(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "getValidators")
	return *ret0, err
}

// GetValidators is a free data retrieval call binding the contract method 0xb7ab4db5.
//
// Solidity: function getValidators() view returns(address[])
func (_Validators *ValidatorsSession) GetValidators() ([]common.Address, error) {
	return _Validators.Contract.GetValidators(&_Validators.CallOpts)
}

// GetValidators is a free data retrieval call binding the contract method 0xb7ab4db5.
//
// Solidity: function getValidators() view returns(address[])
func (_Validators *ValidatorsCallerSession) GetValidators() ([]common.Address, error) {
	return _Validators.Contract.GetValidators(&_Validators.CallOpts)
}

// IsValidator is a free data retrieval call binding the contract method 0xfacd743b.
//
// Solidity: function isValidator(address validator) view returns(bool)
func (_Validators *ValidatorsCaller) IsValidator(opts *bind.CallOpts, validator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "isValidator", validator)
	return *ret0, err
}

// IsValidator is a free data retrieval call binding the contract method 0xfacd743b.
//
// Solidity: function isValidator(address validator) view returns(bool)
func (_Validators *ValidatorsSession) IsValidator(validator common.Address) (bool, error) {
	return _Validators.Contract.IsValidator(&_Validators.CallOpts, validator)
}

// IsValidator is a free data retrieval call binding the contract method 0xfacd743b.
//
// Solidity: function isValidator(address validator) view returns(bool)
func (_Validators *ValidatorsCallerSession) IsValidator(validator common.Address) (bool, error) {
	return _Validators.Contract.IsValidator(&_Validators.CallOpts, validator)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_Validators *ValidatorsCaller) MajorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "majorStakeFine")
	return *ret0, err
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_Validators *ValidatorsSession) MajorStakeFine() (*big.Int, error) {
	return _Validators.Contract.MajorStakeFine(&_Validators.CallOpts)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_Validators *ValidatorsCallerSession) MajorStakeFine() (*big.Int, error) {
	return _Validators.Contract.MajorStakeFine(&_Validators.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_Validators *ValidatorsCaller) MinimumStake(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "minimumStake")
	return *ret0, err
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_Validators *ValidatorsSession) MinimumStake() (*big.Int, error) {
	return _Validators.Contract.MinimumStake(&_Validators.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_Validators *ValidatorsCallerSession) MinimumStake() (*big.Int, error) {
	return _Validators.Contract.MinimumStake(&_Validators.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_Validators *ValidatorsCaller) MinorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "minorStakeFine")
	return *ret0, err
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_Validators *ValidatorsSession) MinorStakeFine() (*big.Int, error) {
	return _Validators.Contract.MinorStakeFine(&_Validators.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_Validators *ValidatorsCallerSession) MinorStakeFine() (*big.Int, error) {
	return _Validators.Contract.MinorStakeFine(&_Validators.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Validators *ValidatorsCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Validators *ValidatorsSession) Owner() (common.Address, error) {
	return _Validators.Contract.Owner(&_Validators.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Validators *ValidatorsCallerSession) Owner() (common.Address, error) {
	return _Validators.Contract.Owner(&_Validators.CallOpts)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_Validators *ValidatorsCaller) RewardAmount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "rewardAmount")
	return *ret0, err
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_Validators *ValidatorsSession) RewardAmount() (*big.Int, error) {
	return _Validators.Contract.RewardAmount(&_Validators.CallOpts)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_Validators *ValidatorsCallerSession) RewardAmount() (*big.Int, error) {
	return _Validators.Contract.RewardAmount(&_Validators.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_Validators *ValidatorsCaller) RewardBonus(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "rewardBonus")
	return *ret0, err
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_Validators *ValidatorsSession) RewardBonus() (*big.Int, error) {
	return _Validators.Contract.RewardBonus(&_Validators.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_Validators *ValidatorsCallerSession) RewardBonus() (*big.Int, error) {
	return _Validators.Contract.RewardBonus(&_Validators.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Validators *ValidatorsCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Validators *ValidatorsSession) Stopped() (bool, error) {
	return _Validators.Contract.Stopped(&_Validators.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_Validators *ValidatorsCallerSession) Stopped() (bool, error) {
	return _Validators.Contract.Stopped(&_Validators.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_Validators *ValidatorsCaller) ValidatorCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "validatorCount")
	return *ret0, err
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_Validators *ValidatorsSession) ValidatorCount() (uint8, error) {
	return _Validators.Contract.ValidatorCount(&_Validators.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_Validators *ValidatorsCallerSession) ValidatorCount() (uint8, error) {
	return _Validators.Contract.ValidatorCount(&_Validators.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_Validators *ValidatorsCaller) ValidatorMaxCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _Validators.contract.Call(opts, out, "validatorMaxCount")
	return *ret0, err
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_Validators *ValidatorsSession) ValidatorMaxCount() (uint8, error) {
	return _Validators.Contract.ValidatorMaxCount(&_Validators.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_Validators *ValidatorsCallerSession) ValidatorMaxCount() (uint8, error) {
	return _Validators.Contract.ValidatorMaxCount(&_Validators.CallOpts)
}

// AddValidator is a paid mutator transaction binding the contract method 0xeb6320c7.
//
// Solidity: function addValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsTransactor) AddValidator(opts *bind.TransactOpts, _validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "addValidator", _validator, _madID)
}

// AddValidator is a paid mutator transaction binding the contract method 0xeb6320c7.
//
// Solidity: function addValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsSession) AddValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.AddValidator(&_Validators.TransactOpts, _validator, _madID)
}

// AddValidator is a paid mutator transaction binding the contract method 0xeb6320c7.
//
// Solidity: function addValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsTransactorSession) AddValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.AddValidator(&_Validators.TransactOpts, _validator, _madID)
}

// Burn is a paid mutator transaction binding the contract method 0x89afcb44.
//
// Solidity: function burn(address who) returns()
func (_Validators *ValidatorsTransactor) Burn(opts *bind.TransactOpts, who common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "burn", who)
}

// Burn is a paid mutator transaction binding the contract method 0x89afcb44.
//
// Solidity: function burn(address who) returns()
func (_Validators *ValidatorsSession) Burn(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.Burn(&_Validators.TransactOpts, who)
}

// Burn is a paid mutator transaction binding the contract method 0x89afcb44.
//
// Solidity: function burn(address who) returns()
func (_Validators *ValidatorsTransactorSession) Burn(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.Burn(&_Validators.TransactOpts, who)
}

// ConfirmValidators is a paid mutator transaction binding the contract method 0x35c6a163.
//
// Solidity: function confirmValidators() returns(bool)
func (_Validators *ValidatorsTransactor) ConfirmValidators(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "confirmValidators")
}

// ConfirmValidators is a paid mutator transaction binding the contract method 0x35c6a163.
//
// Solidity: function confirmValidators() returns(bool)
func (_Validators *ValidatorsSession) ConfirmValidators() (*types.Transaction, error) {
	return _Validators.Contract.ConfirmValidators(&_Validators.TransactOpts)
}

// ConfirmValidators is a paid mutator transaction binding the contract method 0x35c6a163.
//
// Solidity: function confirmValidators() returns(bool)
func (_Validators *ValidatorsTransactorSession) ConfirmValidators() (*types.Transaction, error) {
	return _Validators.Contract.ConfirmValidators(&_Validators.TransactOpts)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Validators *ValidatorsTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Validators *ValidatorsSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Validators.Contract.GrantOperator(&_Validators.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_Validators *ValidatorsTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _Validators.Contract.GrantOperator(&_Validators.TransactOpts, _operator)
}

// MajorFine is a paid mutator transaction binding the contract method 0x57b4f82a.
//
// Solidity: function majorFine(address who) returns()
func (_Validators *ValidatorsTransactor) MajorFine(opts *bind.TransactOpts, who common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "majorFine", who)
}

// MajorFine is a paid mutator transaction binding the contract method 0x57b4f82a.
//
// Solidity: function majorFine(address who) returns()
func (_Validators *ValidatorsSession) MajorFine(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.MajorFine(&_Validators.TransactOpts, who)
}

// MajorFine is a paid mutator transaction binding the contract method 0x57b4f82a.
//
// Solidity: function majorFine(address who) returns()
func (_Validators *ValidatorsTransactorSession) MajorFine(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.MajorFine(&_Validators.TransactOpts, who)
}

// MinorFine is a paid mutator transaction binding the contract method 0xd2a2c55c.
//
// Solidity: function minorFine(address who) returns()
func (_Validators *ValidatorsTransactor) MinorFine(opts *bind.TransactOpts, who common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "minorFine", who)
}

// MinorFine is a paid mutator transaction binding the contract method 0xd2a2c55c.
//
// Solidity: function minorFine(address who) returns()
func (_Validators *ValidatorsSession) MinorFine(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.MinorFine(&_Validators.TransactOpts, who)
}

// MinorFine is a paid mutator transaction binding the contract method 0xd2a2c55c.
//
// Solidity: function minorFine(address who) returns()
func (_Validators *ValidatorsTransactorSession) MinorFine(who common.Address) (*types.Transaction, error) {
	return _Validators.Contract.MinorFine(&_Validators.TransactOpts, who)
}

// QueueValidator is a paid mutator transaction binding the contract method 0x81d3cb14.
//
// Solidity: function queueValidator(address _validator, uint256[2] _madID) returns(uint256)
func (_Validators *ValidatorsTransactor) QueueValidator(opts *bind.TransactOpts, _validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "queueValidator", _validator, _madID)
}

// QueueValidator is a paid mutator transaction binding the contract method 0x81d3cb14.
//
// Solidity: function queueValidator(address _validator, uint256[2] _madID) returns(uint256)
func (_Validators *ValidatorsSession) QueueValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.QueueValidator(&_Validators.TransactOpts, _validator, _madID)
}

// QueueValidator is a paid mutator transaction binding the contract method 0x81d3cb14.
//
// Solidity: function queueValidator(address _validator, uint256[2] _madID) returns(uint256)
func (_Validators *ValidatorsTransactorSession) QueueValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.QueueValidator(&_Validators.TransactOpts, _validator, _madID)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Validators *ValidatorsTransactor) ReloadRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "reloadRegistry")
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Validators *ValidatorsSession) ReloadRegistry() (*types.Transaction, error) {
	return _Validators.Contract.ReloadRegistry(&_Validators.TransactOpts)
}

// ReloadRegistry is a paid mutator transaction binding the contract method 0x1476601d.
//
// Solidity: function reloadRegistry() returns()
func (_Validators *ValidatorsTransactorSession) ReloadRegistry() (*types.Transaction, error) {
	return _Validators.Contract.ReloadRegistry(&_Validators.TransactOpts)
}

// RemoveValidator is a paid mutator transaction binding the contract method 0x844469b2.
//
// Solidity: function removeValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsTransactor) RemoveValidator(opts *bind.TransactOpts, _validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "removeValidator", _validator, _madID)
}

// RemoveValidator is a paid mutator transaction binding the contract method 0x844469b2.
//
// Solidity: function removeValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsSession) RemoveValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.RemoveValidator(&_Validators.TransactOpts, _validator, _madID)
}

// RemoveValidator is a paid mutator transaction binding the contract method 0x844469b2.
//
// Solidity: function removeValidator(address _validator, uint256[2] _madID) returns(uint8)
func (_Validators *ValidatorsTransactorSession) RemoveValidator(_validator common.Address, _madID [2]*big.Int) (*types.Transaction, error) {
	return _Validators.Contract.RemoveValidator(&_Validators.TransactOpts, _validator, _madID)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Validators *ValidatorsTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Validators *ValidatorsSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Validators.Contract.RevokeOperator(&_Validators.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_Validators *ValidatorsTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _Validators.Contract.RevokeOperator(&_Validators.TransactOpts, _operator)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Validators *ValidatorsTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Validators *ValidatorsSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Validators.Contract.SetAuthority(&_Validators.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Validators *ValidatorsTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Validators.Contract.SetAuthority(&_Validators.TransactOpts, authority_)
}

// SetMajorStakeFine is a paid mutator transaction binding the contract method 0x78146c2f.
//
// Solidity: function setMajorStakeFine(uint256 _majorStakeFine) returns()
func (_Validators *ValidatorsTransactor) SetMajorStakeFine(opts *bind.TransactOpts, _majorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setMajorStakeFine", _majorStakeFine)
}

// SetMajorStakeFine is a paid mutator transaction binding the contract method 0x78146c2f.
//
// Solidity: function setMajorStakeFine(uint256 _majorStakeFine) returns()
func (_Validators *ValidatorsSession) SetMajorStakeFine(_majorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMajorStakeFine(&_Validators.TransactOpts, _majorStakeFine)
}

// SetMajorStakeFine is a paid mutator transaction binding the contract method 0x78146c2f.
//
// Solidity: function setMajorStakeFine(uint256 _majorStakeFine) returns()
func (_Validators *ValidatorsTransactorSession) SetMajorStakeFine(_majorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMajorStakeFine(&_Validators.TransactOpts, _majorStakeFine)
}

// SetMinimumStake is a paid mutator transaction binding the contract method 0x233e9903.
//
// Solidity: function setMinimumStake(uint256 _minimumStake) returns()
func (_Validators *ValidatorsTransactor) SetMinimumStake(opts *bind.TransactOpts, _minimumStake *big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setMinimumStake", _minimumStake)
}

// SetMinimumStake is a paid mutator transaction binding the contract method 0x233e9903.
//
// Solidity: function setMinimumStake(uint256 _minimumStake) returns()
func (_Validators *ValidatorsSession) SetMinimumStake(_minimumStake *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMinimumStake(&_Validators.TransactOpts, _minimumStake)
}

// SetMinimumStake is a paid mutator transaction binding the contract method 0x233e9903.
//
// Solidity: function setMinimumStake(uint256 _minimumStake) returns()
func (_Validators *ValidatorsTransactorSession) SetMinimumStake(_minimumStake *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMinimumStake(&_Validators.TransactOpts, _minimumStake)
}

// SetMinorStakeFine is a paid mutator transaction binding the contract method 0x29693c5c.
//
// Solidity: function setMinorStakeFine(uint256 _minorStakeFine) returns()
func (_Validators *ValidatorsTransactor) SetMinorStakeFine(opts *bind.TransactOpts, _minorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setMinorStakeFine", _minorStakeFine)
}

// SetMinorStakeFine is a paid mutator transaction binding the contract method 0x29693c5c.
//
// Solidity: function setMinorStakeFine(uint256 _minorStakeFine) returns()
func (_Validators *ValidatorsSession) SetMinorStakeFine(_minorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMinorStakeFine(&_Validators.TransactOpts, _minorStakeFine)
}

// SetMinorStakeFine is a paid mutator transaction binding the contract method 0x29693c5c.
//
// Solidity: function setMinorStakeFine(uint256 _minorStakeFine) returns()
func (_Validators *ValidatorsTransactorSession) SetMinorStakeFine(_minorStakeFine *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetMinorStakeFine(&_Validators.TransactOpts, _minorStakeFine)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Validators *ValidatorsTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Validators *ValidatorsSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Validators.Contract.SetOwner(&_Validators.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Validators *ValidatorsTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Validators.Contract.SetOwner(&_Validators.TransactOpts, owner_)
}

// SetRewardAmount is a paid mutator transaction binding the contract method 0xa8a65a78.
//
// Solidity: function setRewardAmount(uint256 _rewardAmount) returns()
func (_Validators *ValidatorsTransactor) SetRewardAmount(opts *bind.TransactOpts, _rewardAmount *big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setRewardAmount", _rewardAmount)
}

// SetRewardAmount is a paid mutator transaction binding the contract method 0xa8a65a78.
//
// Solidity: function setRewardAmount(uint256 _rewardAmount) returns()
func (_Validators *ValidatorsSession) SetRewardAmount(_rewardAmount *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetRewardAmount(&_Validators.TransactOpts, _rewardAmount)
}

// SetRewardAmount is a paid mutator transaction binding the contract method 0xa8a65a78.
//
// Solidity: function setRewardAmount(uint256 _rewardAmount) returns()
func (_Validators *ValidatorsTransactorSession) SetRewardAmount(_rewardAmount *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetRewardAmount(&_Validators.TransactOpts, _rewardAmount)
}

// SetRewardBonus is a paid mutator transaction binding the contract method 0xf95d80fa.
//
// Solidity: function setRewardBonus(uint256 _rewardBonus) returns()
func (_Validators *ValidatorsTransactor) SetRewardBonus(opts *bind.TransactOpts, _rewardBonus *big.Int) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setRewardBonus", _rewardBonus)
}

// SetRewardBonus is a paid mutator transaction binding the contract method 0xf95d80fa.
//
// Solidity: function setRewardBonus(uint256 _rewardBonus) returns()
func (_Validators *ValidatorsSession) SetRewardBonus(_rewardBonus *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetRewardBonus(&_Validators.TransactOpts, _rewardBonus)
}

// SetRewardBonus is a paid mutator transaction binding the contract method 0xf95d80fa.
//
// Solidity: function setRewardBonus(uint256 _rewardBonus) returns()
func (_Validators *ValidatorsTransactorSession) SetRewardBonus(_rewardBonus *big.Int) (*types.Transaction, error) {
	return _Validators.Contract.SetRewardBonus(&_Validators.TransactOpts, _rewardBonus)
}

// SetValidatorMaxCount is a paid mutator transaction binding the contract method 0x2cab37f7.
//
// Solidity: function setValidatorMaxCount(uint8 _validatorMaxCount) returns()
func (_Validators *ValidatorsTransactor) SetValidatorMaxCount(opts *bind.TransactOpts, _validatorMaxCount uint8) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "setValidatorMaxCount", _validatorMaxCount)
}

// SetValidatorMaxCount is a paid mutator transaction binding the contract method 0x2cab37f7.
//
// Solidity: function setValidatorMaxCount(uint8 _validatorMaxCount) returns()
func (_Validators *ValidatorsSession) SetValidatorMaxCount(_validatorMaxCount uint8) (*types.Transaction, error) {
	return _Validators.Contract.SetValidatorMaxCount(&_Validators.TransactOpts, _validatorMaxCount)
}

// SetValidatorMaxCount is a paid mutator transaction binding the contract method 0x2cab37f7.
//
// Solidity: function setValidatorMaxCount(uint8 _validatorMaxCount) returns()
func (_Validators *ValidatorsTransactorSession) SetValidatorMaxCount(_validatorMaxCount uint8) (*types.Transaction, error) {
	return _Validators.Contract.SetValidatorMaxCount(&_Validators.TransactOpts, _validatorMaxCount)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns()
func (_Validators *ValidatorsTransactor) Snapshot(opts *bind.TransactOpts, _signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "snapshot", _signatureGroup, _bclaims)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns()
func (_Validators *ValidatorsSession) Snapshot(_signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _Validators.Contract.Snapshot(&_Validators.TransactOpts, _signatureGroup, _bclaims)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns()
func (_Validators *ValidatorsTransactorSession) Snapshot(_signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _Validators.Contract.Snapshot(&_Validators.TransactOpts, _signatureGroup, _bclaims)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Validators *ValidatorsTransactor) Start(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "start")
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Validators *ValidatorsSession) Start() (*types.Transaction, error) {
	return _Validators.Contract.Start(&_Validators.TransactOpts)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_Validators *ValidatorsTransactorSession) Start() (*types.Transaction, error) {
	return _Validators.Contract.Start(&_Validators.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Validators *ValidatorsTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Validators.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Validators *ValidatorsSession) Stop() (*types.Transaction, error) {
	return _Validators.Contract.Stop(&_Validators.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Validators *ValidatorsTransactorSession) Stop() (*types.Transaction, error) {
	return _Validators.Contract.Stop(&_Validators.TransactOpts)
}

// ValidatorsLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the Validators contract.
type ValidatorsLogSetAuthorityIterator struct {
	Event *ValidatorsLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsLogSetAuthority represents a LogSetAuthority event raised by the Validators contract.
type ValidatorsLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Validators *ValidatorsFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*ValidatorsLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsLogSetAuthorityIterator{contract: _Validators.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Validators *ValidatorsFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *ValidatorsLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsLogSetAuthority)
				if err := _Validators.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetAuthority is a log parse operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Validators *ValidatorsFilterer) ParseLogSetAuthority(log types.Log) (*ValidatorsLogSetAuthority, error) {
	event := new(ValidatorsLogSetAuthority)
	if err := _Validators.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the Validators contract.
type ValidatorsLogSetOwnerIterator struct {
	Event *ValidatorsLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsLogSetOwner represents a LogSetOwner event raised by the Validators contract.
type ValidatorsLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Validators *ValidatorsFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*ValidatorsLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsLogSetOwnerIterator{contract: _Validators.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Validators *ValidatorsFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *ValidatorsLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsLogSetOwner)
				if err := _Validators.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetOwner is a log parse operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Validators *ValidatorsFilterer) ParseLogSetOwner(log types.Log) (*ValidatorsLogSetOwner, error) {
	event := new(ValidatorsLogSetOwner)
	if err := _Validators.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTakenIterator is returned from FilterSnapshotTaken and is used to iterate over the raw logs and unpacked data for SnapshotTaken events raised by the Validators contract.
type ValidatorsSnapshotTakenIterator struct {
	Event *ValidatorsSnapshotTaken // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTakenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTaken)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTaken)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTakenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTakenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTaken represents a SnapshotTaken event raised by the Validators contract.
type ValidatorsSnapshotTaken struct {
	ChainId        uint32
	Epoch          *big.Int
	Height         uint32
	Validator      common.Address
	StartingETHDKG bool
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterSnapshotTaken is a free log retrieval operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_Validators *ValidatorsFilterer) FilterSnapshotTaken(opts *bind.FilterOpts, epoch []*big.Int, validator []common.Address) (*ValidatorsSnapshotTakenIterator, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTakenIterator{contract: _Validators.contract, event: "SnapshotTaken", logs: logs, sub: sub}, nil
}

// WatchSnapshotTaken is a free log subscription operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_Validators *ValidatorsFilterer) WatchSnapshotTaken(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTaken, epoch []*big.Int, validator []common.Address) (event.Subscription, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTaken)
				if err := _Validators.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSnapshotTaken is a log parse operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_Validators *ValidatorsFilterer) ParseSnapshotTaken(log types.Log) (*ValidatorsSnapshotTaken, error) {
	event := new(ValidatorsSnapshotTaken)
	if err := _Validators.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsValidatorCreatedIterator is returned from FilterValidatorCreated and is used to iterate over the raw logs and unpacked data for ValidatorCreated events raised by the Validators contract.
type ValidatorsValidatorCreatedIterator struct {
	Event *ValidatorsValidatorCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsValidatorCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsValidatorCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsValidatorCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsValidatorCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsValidatorCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsValidatorCreated represents a ValidatorCreated event raised by the Validators contract.
type ValidatorsValidatorCreated struct {
	Validator common.Address
	Signer    common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorCreated is a free log retrieval operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_Validators *ValidatorsFilterer) FilterValidatorCreated(opts *bind.FilterOpts, validator []common.Address, signer []common.Address) (*ValidatorsValidatorCreatedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsValidatorCreatedIterator{contract: _Validators.contract, event: "ValidatorCreated", logs: logs, sub: sub}, nil
}

// WatchValidatorCreated is a free log subscription operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_Validators *ValidatorsFilterer) WatchValidatorCreated(opts *bind.WatchOpts, sink chan<- *ValidatorsValidatorCreated, validator []common.Address, signer []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsValidatorCreated)
				if err := _Validators.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorCreated is a log parse operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_Validators *ValidatorsFilterer) ParseValidatorCreated(log types.Log) (*ValidatorsValidatorCreated, error) {
	event := new(ValidatorsValidatorCreated)
	if err := _Validators.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsValidatorJoinedIterator is returned from FilterValidatorJoined and is used to iterate over the raw logs and unpacked data for ValidatorJoined events raised by the Validators contract.
type ValidatorsValidatorJoinedIterator struct {
	Event *ValidatorsValidatorJoined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsValidatorJoinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsValidatorJoined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsValidatorJoined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsValidatorJoinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsValidatorJoinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsValidatorJoined represents a ValidatorJoined event raised by the Validators contract.
type ValidatorsValidatorJoined struct {
	Validator common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorJoined is a free log retrieval operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_Validators *ValidatorsFilterer) FilterValidatorJoined(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsValidatorJoinedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsValidatorJoinedIterator{contract: _Validators.contract, event: "ValidatorJoined", logs: logs, sub: sub}, nil
}

// WatchValidatorJoined is a free log subscription operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_Validators *ValidatorsFilterer) WatchValidatorJoined(opts *bind.WatchOpts, sink chan<- *ValidatorsValidatorJoined, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsValidatorJoined)
				if err := _Validators.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorJoined is a log parse operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_Validators *ValidatorsFilterer) ParseValidatorJoined(log types.Log) (*ValidatorsValidatorJoined, error) {
	event := new(ValidatorsValidatorJoined)
	if err := _Validators.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsValidatorLeftIterator is returned from FilterValidatorLeft and is used to iterate over the raw logs and unpacked data for ValidatorLeft events raised by the Validators contract.
type ValidatorsValidatorLeftIterator struct {
	Event *ValidatorsValidatorLeft // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsValidatorLeftIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsValidatorLeft)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsValidatorLeft)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsValidatorLeftIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsValidatorLeftIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsValidatorLeft represents a ValidatorLeft event raised by the Validators contract.
type ValidatorsValidatorLeft struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorLeft is a free log retrieval operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) FilterValidatorLeft(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsValidatorLeftIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsValidatorLeftIterator{contract: _Validators.contract, event: "ValidatorLeft", logs: logs, sub: sub}, nil
}

// WatchValidatorLeft is a free log subscription operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) WatchValidatorLeft(opts *bind.WatchOpts, sink chan<- *ValidatorsValidatorLeft, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsValidatorLeft)
				if err := _Validators.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorLeft is a log parse operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) ParseValidatorLeft(log types.Log) (*ValidatorsValidatorLeft, error) {
	event := new(ValidatorsValidatorLeft)
	if err := _Validators.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsValidatorQueuedIterator is returned from FilterValidatorQueued and is used to iterate over the raw logs and unpacked data for ValidatorQueued events raised by the Validators contract.
type ValidatorsValidatorQueuedIterator struct {
	Event *ValidatorsValidatorQueued // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsValidatorQueuedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsValidatorQueued)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsValidatorQueued)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsValidatorQueuedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsValidatorQueuedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsValidatorQueued represents a ValidatorQueued event raised by the Validators contract.
type ValidatorsValidatorQueued struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorQueued is a free log retrieval operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) FilterValidatorQueued(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsValidatorQueuedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.FilterLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsValidatorQueuedIterator{contract: _Validators.contract, event: "ValidatorQueued", logs: logs, sub: sub}, nil
}

// WatchValidatorQueued is a free log subscription operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) WatchValidatorQueued(opts *bind.WatchOpts, sink chan<- *ValidatorsValidatorQueued, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _Validators.contract.WatchLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsValidatorQueued)
				if err := _Validators.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorQueued is a log parse operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_Validators *ValidatorsFilterer) ParseValidatorQueued(log types.Log) (*ValidatorsValidatorQueued, error) {
	event := new(ValidatorsValidatorQueued)
	if err := _Validators.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondABI is the input ABI used to generate the binding from.
const ValidatorsDiamondABI = "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]"

// ValidatorsDiamondBin is the compiled bytecode used for deploying new contracts.
var ValidatorsDiamondBin = "0x60806040526000604051610012906102f4565b604051809103906000f08015801561002e573d6000803e3d6000fd5b50905060006100456102b260201b61017b1760201c565b90508181600001600063e0cf48f960e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000016000633df8c1dc60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000016000631c8c8ba460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508181600001600063c1312f4d60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050610301565b60008060405180807f76616c696461746f72732e73746f7261676500000000000000000000000000008152506012019050604051809103902090508091505090565b6109a98061050383390190565b6101f3806103106000396000f3fe60806040523661000b57005b600061001561017b565b9050600081600001600080357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610155576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6e6f20666163657420666f722073656c6563746f72000000000000000000000081525060200191505060405180910390fd5b3660008037600080366000845af43d6000803e8060008114610176573d6000f35b3d6000fd5b60008060405180807f76616c696461746f72732e73746f726167650000000000000000000000000000815250601201905060405180910390209050809150509056fea264697066735822122098acc84300409e0e7f087bc588d3f51f90b9457c6f908102205930669fb496ef64736f6c63430006070033608060405234801561001057600080fd5b50610989806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631c8c8ba4146100675780633df8c1dc146100975780639be2f2df146100b3578063c1312f4d146100e4578063e0cf48f914610114578063ec11c82314610132575b600080fd5b610081600480360381019061007c9190610576565b610162565b60405161008e91906107bf565b60405180910390f35b6100b160048036038101906100ac91906105ca565b6101d3565b005b6100cd60048036038101906100c89190610535565b6101ec565b6040516100db929190610774565b60405180910390f35b6100fe60048036038101906100f99190610576565b6102d5565b60405161010b91906107da565b60405180910390f35b61011c610386565b60405161012991906107bf565b60405180910390f35b61014c60048036038101906101479190610535565b61039e565b604051610159919061079d565b60405180910390f35b600080601f830190505b828111156101a757600882901b84828151811061018557fe5b602001015160f81c60f81b60f81c60ff1617915080806001900391505061016c565b50600881901b8383815181106101b957fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b60006101dd610468565b90508181600101819055505050565b6101f4610488565b6101fc6104aa565b60606102078461039e565b9050610214816000610162565b8260016002811061022157fe5b602002018181525050610235816020610162565b8260006002811061024257fe5b602002018181525050610256816040610162565b8360036004811061026357fe5b602002018181525050610277816060610162565b8360026004811061028457fe5b602002018181525050610298816080610162565b836001600481106102a557fe5b6020020181815250506102b98160a0610162565b836000600481106102c657fe5b60200201818152505050915091565b60008260038301815181106102e657fe5b602001015160f81c60f81b60f81c60ff16905082600283018151811061030857fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082600183018151811061033657fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082828151811061036157fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600080610391610468565b9050806001015491505090565b6060815167ffffffffffffffff811180156103b857600080fd5b506040519080825280601f01601f1916602001820160405280156103eb5781602001600182028036833780820191505090505b50905060008090505b82518110156104625782818151811061040957fe5b602001015160f81c60f81b82600183865103038151811061042657fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506103f4565b50919050565b6000806040516104779061075f565b604051809103902090508091505090565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b600082601f8301126104dd57600080fd5b81356104f06104eb82610822565b6107f5565b9150808252602083016020830185838301111561050c57600080fd5b6105178382846108e9565b50505092915050565b60008135905061052f8161093c565b92915050565b60006020828403121561054757600080fd5b600082013567ffffffffffffffff81111561056157600080fd5b61056d848285016104cc565b91505092915050565b6000806040838503121561058957600080fd5b600083013567ffffffffffffffff8111156105a357600080fd5b6105af858286016104cc565b92505060206105c085828601610520565b9150509250929050565b6000602082840312156105dc57600080fd5b60006105ea84828501610520565b91505092915050565b60006105ff8383610732565b60208301905092915050565b61061481610862565b61061e818461089d565b92506106298261084e565b8060005b8381101561065a57815161064187826105f3565b965061064c83610883565b92505060018101905061062d565b505050505050565b61066b8161086d565b61067581846108a8565b925061068082610858565b8060005b838110156106b157815161069887826105f3565b96506106a383610890565b925050600181019050610684565b505050505050565b60006106c482610878565b6106ce81856108b3565b93506106de8185602086016108f8565b6106e78161092b565b840191505092915050565b60006106ff6010836108c4565b91507f736e617073686f742e73746f72616765000000000000000000000000000000006000830152601082019050919050565b61073b816108cf565b82525050565b61074a816108cf565b82525050565b610759816108d9565b82525050565b600061076a826106f2565b9150819050919050565b600060c0820190506107896000830185610662565b610796608083018461060b565b9392505050565b600060208201905081810360008301526107b781846106b9565b905092915050565b60006020820190506107d46000830184610741565b92915050565b60006020820190506107ef6000830184610750565b92915050565b6000604051905081810181811067ffffffffffffffff8211171561081857600080fd5b8060405250919050565b600067ffffffffffffffff82111561083957600080fd5b601f19601f8301169050602081019050919050565b6000819050919050565b6000819050919050565b600060029050919050565b600060049050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b600081905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b600063ffffffff82169050919050565b82818337600083830152505050565b60005b838110156109165780820151818401526020810190506108fb565b83811115610925576000848401525b50505050565b6000601f19601f8301169050919050565b610945816108cf565b811461095057600080fd5b5056fea2646970667358221220d3a42afcfb530ca38bf9c8eaa7444566e97bb61415216736c0338c52b1f9f94264736f6c63430006070033"

// DeployValidatorsDiamond deploys a new Ethereum contract, binding an instance of ValidatorsDiamond to it.
func DeployValidatorsDiamond(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsDiamond, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsDiamondABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsDiamondBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsDiamond{ValidatorsDiamondCaller: ValidatorsDiamondCaller{contract: contract}, ValidatorsDiamondTransactor: ValidatorsDiamondTransactor{contract: contract}, ValidatorsDiamondFilterer: ValidatorsDiamondFilterer{contract: contract}}, nil
}

// ValidatorsDiamond is an auto generated Go binding around an Ethereum contract.
type ValidatorsDiamond struct {
	ValidatorsDiamondCaller     // Read-only binding to the contract
	ValidatorsDiamondTransactor // Write-only binding to the contract
	ValidatorsDiamondFilterer   // Log filterer for contract events
}

// ValidatorsDiamondCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsDiamondCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsDiamondTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsDiamondFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsDiamondSession struct {
	Contract     *ValidatorsDiamond // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ValidatorsDiamondCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsDiamondCallerSession struct {
	Contract *ValidatorsDiamondCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// ValidatorsDiamondTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsDiamondTransactorSession struct {
	Contract     *ValidatorsDiamondTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// ValidatorsDiamondRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsDiamondRaw struct {
	Contract *ValidatorsDiamond // Generic contract binding to access the raw methods on
}

// ValidatorsDiamondCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsDiamondCallerRaw struct {
	Contract *ValidatorsDiamondCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsDiamondTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsDiamondTransactorRaw struct {
	Contract *ValidatorsDiamondTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsDiamond creates a new instance of ValidatorsDiamond, bound to a specific deployed contract.
func NewValidatorsDiamond(address common.Address, backend bind.ContractBackend) (*ValidatorsDiamond, error) {
	contract, err := bindValidatorsDiamond(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamond{ValidatorsDiamondCaller: ValidatorsDiamondCaller{contract: contract}, ValidatorsDiamondTransactor: ValidatorsDiamondTransactor{contract: contract}, ValidatorsDiamondFilterer: ValidatorsDiamondFilterer{contract: contract}}, nil
}

// NewValidatorsDiamondCaller creates a new read-only instance of ValidatorsDiamond, bound to a specific deployed contract.
func NewValidatorsDiamondCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsDiamondCaller, error) {
	contract, err := bindValidatorsDiamond(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondCaller{contract: contract}, nil
}

// NewValidatorsDiamondTransactor creates a new write-only instance of ValidatorsDiamond, bound to a specific deployed contract.
func NewValidatorsDiamondTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsDiamondTransactor, error) {
	contract, err := bindValidatorsDiamond(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTransactor{contract: contract}, nil
}

// NewValidatorsDiamondFilterer creates a new log filterer instance of ValidatorsDiamond, bound to a specific deployed contract.
func NewValidatorsDiamondFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsDiamondFilterer, error) {
	contract, err := bindValidatorsDiamond(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondFilterer{contract: contract}, nil
}

// bindValidatorsDiamond binds a generic wrapper to an already deployed contract.
func bindValidatorsDiamond(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsDiamondABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsDiamond *ValidatorsDiamondRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsDiamond.Contract.ValidatorsDiamondCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsDiamond *ValidatorsDiamondRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.ValidatorsDiamondTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsDiamond *ValidatorsDiamondRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.ValidatorsDiamondTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsDiamond *ValidatorsDiamondCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsDiamond.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsDiamond *ValidatorsDiamondTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsDiamond *ValidatorsDiamondTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.contract.Transact(opts, method, params...)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondTransactor) Fallback(opts *bind.TransactOpts, calldata []byte) (*types.Transaction, error) {
	return _ValidatorsDiamond.contract.RawTransact(opts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondSession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.Fallback(&_ValidatorsDiamond.TransactOpts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondTransactorSession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.Fallback(&_ValidatorsDiamond.TransactOpts, calldata)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamond.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondSession) Receive() (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.Receive(&_ValidatorsDiamond.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_ValidatorsDiamond *ValidatorsDiamondTransactorSession) Receive() (*types.Transaction, error) {
	return _ValidatorsDiamond.Contract.Receive(&_ValidatorsDiamond.TransactOpts)
}

// ValidatorsDiamondTestABI is the input ABI used to generate the binding from.
const ValidatorsDiamondTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint256\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint32\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFailNotFacet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testSetSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ValidatorsDiamondTestBin is the compiled bytecode used for deploying new contracts.
var ValidatorsDiamondTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b506117a78061003a6000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063835059691161005b57806383505969146100a0578063b78b20fe146100aa578063ba414fa6146100b4578063fa7626d4146100d65761007d565b80630a9254e4146100825780633e6fe2761461008c5780636edcfb9d14610096575b600080fd5b61008a6100f8565b005b6100946101c6565b005b61009e610336565b005b6100a86103e2565b005b6100b2610558565b005b6100bc610695565b604051808215151515815260200191505060405180910390f35b6100de6106a8565b604051808215151515815260200191505060405180910390f35b60405161010490610816565b604051809103906000f080158015610120573d6000803e3d6000fd5b50600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b60606040518060a00160405280608081526020016116f260809139905060007fd8d6b02811ca34cef0bcbc79cc5dfaf2dc6b8133ea46d552ebfc96f1c2b2d710905060008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631c8c8ba48460006040518363ffffffff1660e01b81526004018080602001838152602001828103825284818151815260200191508051906020019080838360005b8381101561029f578082015181840152602081019050610284565b50505050905090810190601f1680156102cc5780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b1580156102ea57600080fd5b505afa1580156102fe573d6000803e3d6000fd5b505050506040513d602081101561031457600080fd5b8101908080519060200190929190505050905061033181836106ba565b505050565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508073ffffffffffffffffffffffffffffffffffffffff16639fb69b436040518163ffffffff1660e01b815260040160206040518083038186803b1580156103a357600080fd5b505afa1580156103b7573d6000803e3d6000fd5b505050506040513d60208110156103cd57600080fd5b81019080805190602001909291905050505050565b60606040518060400160405280600481526020017f01020400000000000000000000000000000000000000000000000000000000008152509050600062040201905060008060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c1312f4d8460006040518363ffffffff1660e01b81526004018080602001838152602001828103825284818151815260200191508051906020019080838360005b838110156104bb5780820151818401526020810190506104a0565b50505050905090810190601f1680156104e85780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b15801561050657600080fd5b505afa15801561051a573d6000803e3d6000fd5b505050506040513d602081101561053057600080fd5b810190808051906020019092919050505090506105538163ffffffff16836106ba565b505050565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633df8c1dc600d6040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b1580156105ce57600080fd5b505af11580156105e2573d6000803e3d6000fd5b50505050610693600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e0cf48f96040518163ffffffff1660e01b815260040160206040518083038186803b15801561065157600080fd5b505afa158015610665573d6000803e3d6000fd5b505050506040513d602081101561067b57600080fd5b8101908080519060200190929190505050600d6106ba565b565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b8082146107f5577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040518080602001828103825260228152602001806116d06022913960400191505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88160405180806020018381526020018281038252600a8152602001807f20204578706563746564000000000000000000000000000000000000000000008152506020019250505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88260405180806020018381526020018281038252600a8152602001807f2020202041637475616c000000000000000000000000000000000000000000008152506020019250505060405180910390a16107f46107f9565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b610eac806108248339019056fe60806040526000604051610012906102f4565b604051809103906000f08015801561002e573d6000803e3d6000fd5b50905060006100456102b260201b61017b1760201c565b90508181600001600063e0cf48f960e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000016000633df8c1dc60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081816000016000631c8c8ba460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508181600001600063c1312f4d60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050610301565b60008060405180807f76616c696461746f72732e73746f7261676500000000000000000000000000008152506012019050604051809103902090508091505090565b6109a98061050383390190565b6101f3806103106000396000f3fe60806040523661000b57005b600061001561017b565b9050600081600001600080357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610155576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6e6f20666163657420666f722073656c6563746f72000000000000000000000081525060200191505060405180910390fd5b3660008037600080366000845af43d6000803e8060008114610176573d6000f35b3d6000fd5b60008060405180807f76616c696461746f72732e73746f726167650000000000000000000000000000815250601201905060405180910390209050809150509056fea264697066735822122098acc84300409e0e7f087bc588d3f51f90b9457c6f908102205930669fb496ef64736f6c63430006070033608060405234801561001057600080fd5b50610989806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631c8c8ba4146100675780633df8c1dc146100975780639be2f2df146100b3578063c1312f4d146100e4578063e0cf48f914610114578063ec11c82314610132575b600080fd5b610081600480360381019061007c9190610576565b610162565b60405161008e91906107bf565b60405180910390f35b6100b160048036038101906100ac91906105ca565b6101d3565b005b6100cd60048036038101906100c89190610535565b6101ec565b6040516100db929190610774565b60405180910390f35b6100fe60048036038101906100f99190610576565b6102d5565b60405161010b91906107da565b60405180910390f35b61011c610386565b60405161012991906107bf565b60405180910390f35b61014c60048036038101906101479190610535565b61039e565b604051610159919061079d565b60405180910390f35b600080601f830190505b828111156101a757600882901b84828151811061018557fe5b602001015160f81c60f81b60f81c60ff1617915080806001900391505061016c565b50600881901b8383815181106101b957fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b60006101dd610468565b90508181600101819055505050565b6101f4610488565b6101fc6104aa565b60606102078461039e565b9050610214816000610162565b8260016002811061022157fe5b602002018181525050610235816020610162565b8260006002811061024257fe5b602002018181525050610256816040610162565b8360036004811061026357fe5b602002018181525050610277816060610162565b8360026004811061028457fe5b602002018181525050610298816080610162565b836001600481106102a557fe5b6020020181815250506102b98160a0610162565b836000600481106102c657fe5b60200201818152505050915091565b60008260038301815181106102e657fe5b602001015160f81c60f81b60f81c60ff16905082600283018151811061030857fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082600183018151811061033657fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905082828151811061036157fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600080610391610468565b9050806001015491505090565b6060815167ffffffffffffffff811180156103b857600080fd5b506040519080825280601f01601f1916602001820160405280156103eb5781602001600182028036833780820191505090505b50905060008090505b82518110156104625782818151811061040957fe5b602001015160f81c60f81b82600183865103038151811061042657fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506103f4565b50919050565b6000806040516104779061075f565b604051809103902090508091505090565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b600082601f8301126104dd57600080fd5b81356104f06104eb82610822565b6107f5565b9150808252602083016020830185838301111561050c57600080fd5b6105178382846108e9565b50505092915050565b60008135905061052f8161093c565b92915050565b60006020828403121561054757600080fd5b600082013567ffffffffffffffff81111561056157600080fd5b61056d848285016104cc565b91505092915050565b6000806040838503121561058957600080fd5b600083013567ffffffffffffffff8111156105a357600080fd5b6105af858286016104cc565b92505060206105c085828601610520565b9150509250929050565b6000602082840312156105dc57600080fd5b60006105ea84828501610520565b91505092915050565b60006105ff8383610732565b60208301905092915050565b61061481610862565b61061e818461089d565b92506106298261084e565b8060005b8381101561065a57815161064187826105f3565b965061064c83610883565b92505060018101905061062d565b505050505050565b61066b8161086d565b61067581846108a8565b925061068082610858565b8060005b838110156106b157815161069887826105f3565b96506106a383610890565b925050600181019050610684565b505050505050565b60006106c482610878565b6106ce81856108b3565b93506106de8185602086016108f8565b6106e78161092b565b840191505092915050565b60006106ff6010836108c4565b91507f736e617073686f742e73746f72616765000000000000000000000000000000006000830152601082019050919050565b61073b816108cf565b82525050565b61074a816108cf565b82525050565b610759816108d9565b82525050565b600061076a826106f2565b9150819050919050565b600060c0820190506107896000830185610662565b610796608083018461060b565b9392505050565b600060208201905081810360008301526107b781846106b9565b905092915050565b60006020820190506107d46000830184610741565b92915050565b60006020820190506107ef6000830184610750565b92915050565b6000604051905081810181811067ffffffffffffffff8211171561081857600080fd5b8060405250919050565b600067ffffffffffffffff82111561083957600080fd5b601f19601f8301169050602081019050919050565b6000819050919050565b6000819050919050565b600060029050919050565b600060049050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b600081905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b600063ffffffff82169050919050565b82818337600083830152505050565b60005b838110156109165780820151818401526020810190506108fb565b83811115610925576000848401525b50505050565b6000601f19601f8301169050919050565b610945816108cf565b811461095057600080fd5b5056fea2646970667358221220d3a42afcfb530ca38bf9c8eaa7444566e97bb61415216736c0338c52b1f9f94264736f6c634300060700334572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e745d10d7b2c2f196fceb52d546ea33816bdcf2fa5dcc79bcbcf0ce34ca1128b0d6d82d8652a0c5193001a55c0c43b5e0450297d3824a039d924b08d46520b354251f105a55d55c282005a5813480b48ee1efd61046d06b6084bafcf3c10dac57584b0f0bb886f1f1e04bcfa575020e3f47cceb3c11cd5cba496e5aedddc3a04d5b5ca264697066735822122019a80ea24502ad74c45451040f5c592d1e067b6957b8f5286de63495052f0b1d64736f6c63430006070033"

// DeployValidatorsDiamondTest deploys a new Ethereum contract, binding an instance of ValidatorsDiamondTest to it.
func DeployValidatorsDiamondTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsDiamondTest, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsDiamondTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsDiamondTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsDiamondTest{ValidatorsDiamondTestCaller: ValidatorsDiamondTestCaller{contract: contract}, ValidatorsDiamondTestTransactor: ValidatorsDiamondTestTransactor{contract: contract}, ValidatorsDiamondTestFilterer: ValidatorsDiamondTestFilterer{contract: contract}}, nil
}

// ValidatorsDiamondTest is an auto generated Go binding around an Ethereum contract.
type ValidatorsDiamondTest struct {
	ValidatorsDiamondTestCaller     // Read-only binding to the contract
	ValidatorsDiamondTestTransactor // Write-only binding to the contract
	ValidatorsDiamondTestFilterer   // Log filterer for contract events
}

// ValidatorsDiamondTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsDiamondTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsDiamondTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsDiamondTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsDiamondTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsDiamondTestSession struct {
	Contract     *ValidatorsDiamondTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ValidatorsDiamondTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsDiamondTestCallerSession struct {
	Contract *ValidatorsDiamondTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// ValidatorsDiamondTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsDiamondTestTransactorSession struct {
	Contract     *ValidatorsDiamondTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// ValidatorsDiamondTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsDiamondTestRaw struct {
	Contract *ValidatorsDiamondTest // Generic contract binding to access the raw methods on
}

// ValidatorsDiamondTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsDiamondTestCallerRaw struct {
	Contract *ValidatorsDiamondTestCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsDiamondTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsDiamondTestTransactorRaw struct {
	Contract *ValidatorsDiamondTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsDiamondTest creates a new instance of ValidatorsDiamondTest, bound to a specific deployed contract.
func NewValidatorsDiamondTest(address common.Address, backend bind.ContractBackend) (*ValidatorsDiamondTest, error) {
	contract, err := bindValidatorsDiamondTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTest{ValidatorsDiamondTestCaller: ValidatorsDiamondTestCaller{contract: contract}, ValidatorsDiamondTestTransactor: ValidatorsDiamondTestTransactor{contract: contract}, ValidatorsDiamondTestFilterer: ValidatorsDiamondTestFilterer{contract: contract}}, nil
}

// NewValidatorsDiamondTestCaller creates a new read-only instance of ValidatorsDiamondTest, bound to a specific deployed contract.
func NewValidatorsDiamondTestCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsDiamondTestCaller, error) {
	contract, err := bindValidatorsDiamondTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestCaller{contract: contract}, nil
}

// NewValidatorsDiamondTestTransactor creates a new write-only instance of ValidatorsDiamondTest, bound to a specific deployed contract.
func NewValidatorsDiamondTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsDiamondTestTransactor, error) {
	contract, err := bindValidatorsDiamondTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestTransactor{contract: contract}, nil
}

// NewValidatorsDiamondTestFilterer creates a new log filterer instance of ValidatorsDiamondTest, bound to a specific deployed contract.
func NewValidatorsDiamondTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsDiamondTestFilterer, error) {
	contract, err := bindValidatorsDiamondTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestFilterer{contract: contract}, nil
}

// bindValidatorsDiamondTest binds a generic wrapper to an already deployed contract.
func bindValidatorsDiamondTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsDiamondTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsDiamondTest.Contract.ValidatorsDiamondTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.ValidatorsDiamondTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.ValidatorsDiamondTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsDiamondTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ValidatorsDiamondTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) ISTEST() (bool, error) {
	return _ValidatorsDiamondTest.Contract.ISTEST(&_ValidatorsDiamondTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestCallerSession) ISTEST() (bool, error) {
	return _ValidatorsDiamondTest.Contract.ISTEST(&_ValidatorsDiamondTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ValidatorsDiamondTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) Failed() (bool, error) {
	return _ValidatorsDiamondTest.Contract.Failed(&_ValidatorsDiamondTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestCallerSession) Failed() (bool, error) {
	return _ValidatorsDiamondTest.Contract.Failed(&_ValidatorsDiamondTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) SetUp() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.SetUp(&_ValidatorsDiamondTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.SetUp(&_ValidatorsDiamondTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactor) TestExtractUint256(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.contract.Transact(opts, "testExtractUint256")
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) TestExtractUint256() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestExtractUint256(&_ValidatorsDiamondTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorSession) TestExtractUint256() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestExtractUint256(&_ValidatorsDiamondTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactor) TestExtractUint32(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.contract.Transact(opts, "testExtractUint32")
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) TestExtractUint32() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestExtractUint32(&_ValidatorsDiamondTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorSession) TestExtractUint32() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestExtractUint32(&_ValidatorsDiamondTest.TransactOpts)
}

// TestFailNotFacet is a paid mutator transaction binding the contract method 0x6edcfb9d.
//
// Solidity: function testFailNotFacet() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactor) TestFailNotFacet(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.contract.Transact(opts, "testFailNotFacet")
}

// TestFailNotFacet is a paid mutator transaction binding the contract method 0x6edcfb9d.
//
// Solidity: function testFailNotFacet() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) TestFailNotFacet() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestFailNotFacet(&_ValidatorsDiamondTest.TransactOpts)
}

// TestFailNotFacet is a paid mutator transaction binding the contract method 0x6edcfb9d.
//
// Solidity: function testFailNotFacet() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorSession) TestFailNotFacet() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestFailNotFacet(&_ValidatorsDiamondTest.TransactOpts)
}

// TestSetSnapshot is a paid mutator transaction binding the contract method 0xb78b20fe.
//
// Solidity: function testSetSnapshot() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactor) TestSetSnapshot(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsDiamondTest.contract.Transact(opts, "testSetSnapshot")
}

// TestSetSnapshot is a paid mutator transaction binding the contract method 0xb78b20fe.
//
// Solidity: function testSetSnapshot() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestSession) TestSetSnapshot() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestSetSnapshot(&_ValidatorsDiamondTest.TransactOpts)
}

// TestSetSnapshot is a paid mutator transaction binding the contract method 0xb78b20fe.
//
// Solidity: function testSetSnapshot() returns()
func (_ValidatorsDiamondTest *ValidatorsDiamondTestTransactorSession) TestSetSnapshot() (*types.Transaction, error) {
	return _ValidatorsDiamondTest.Contract.TestSetSnapshot(&_ValidatorsDiamondTest.TransactOpts)
}

// ValidatorsDiamondTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogIterator struct {
	Event *ValidatorsDiamondTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLog represents a Log event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLog(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogIterator{contract: _ValidatorsDiamondTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLog) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLog)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLog(log types.Log) (*ValidatorsDiamondTestLog, error) {
	event := new(ValidatorsDiamondTestLog)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogAddressIterator struct {
	Event *ValidatorsDiamondTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogAddress represents a LogAddress event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogAddressIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogAddressIterator{contract: _ValidatorsDiamondTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogAddress)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogAddress(log types.Log) (*ValidatorsDiamondTestLogAddress, error) {
	event := new(ValidatorsDiamondTestLogAddress)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogBytesIterator struct {
	Event *ValidatorsDiamondTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogBytes represents a LogBytes event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogBytesIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogBytesIterator{contract: _ValidatorsDiamondTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogBytes)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogBytes(log types.Log) (*ValidatorsDiamondTestLogBytes, error) {
	event := new(ValidatorsDiamondTestLogBytes)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogBytes32Iterator struct {
	Event *ValidatorsDiamondTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogBytes32 represents a LogBytes32 event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogBytes32Iterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogBytes32Iterator{contract: _ValidatorsDiamondTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogBytes32)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogBytes32(log types.Log) (*ValidatorsDiamondTestLogBytes32, error) {
	event := new(ValidatorsDiamondTestLogBytes32)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogIntIterator struct {
	Event *ValidatorsDiamondTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogInt represents a LogInt event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogIntIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogIntIterator{contract: _ValidatorsDiamondTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogInt)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogInt(log types.Log) (*ValidatorsDiamondTestLogInt, error) {
	event := new(ValidatorsDiamondTestLogInt)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedAddressIterator struct {
	Event *ValidatorsDiamondTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedAddress represents a LogNamedAddress event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedAddressIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedAddressIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedAddress)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedAddress(log types.Log) (*ValidatorsDiamondTestLogNamedAddress, error) {
	event := new(ValidatorsDiamondTestLogNamedAddress)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedBytesIterator struct {
	Event *ValidatorsDiamondTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedBytes represents a LogNamedBytes event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedBytesIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedBytesIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedBytes)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedBytes(log types.Log) (*ValidatorsDiamondTestLogNamedBytes, error) {
	event := new(ValidatorsDiamondTestLogNamedBytes)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedBytes32Iterator struct {
	Event *ValidatorsDiamondTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedBytes32Iterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedBytes32)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedBytes32(log types.Log) (*ValidatorsDiamondTestLogNamedBytes32, error) {
	event := new(ValidatorsDiamondTestLogNamedBytes32)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedDecimalIntIterator struct {
	Event *ValidatorsDiamondTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedDecimalIntIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedDecimalInt)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ValidatorsDiamondTestLogNamedDecimalInt, error) {
	event := new(ValidatorsDiamondTestLogNamedDecimalInt)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedDecimalUintIterator struct {
	Event *ValidatorsDiamondTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedDecimalUintIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedDecimalUint)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ValidatorsDiamondTestLogNamedDecimalUint, error) {
	event := new(ValidatorsDiamondTestLogNamedDecimalUint)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedIntIterator struct {
	Event *ValidatorsDiamondTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedInt represents a LogNamedInt event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedIntIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedIntIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedInt)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedInt(log types.Log) (*ValidatorsDiamondTestLogNamedInt, error) {
	event := new(ValidatorsDiamondTestLogNamedInt)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedStringIterator struct {
	Event *ValidatorsDiamondTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedString represents a LogNamedString event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedStringIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedStringIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedString)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedString(log types.Log) (*ValidatorsDiamondTestLogNamedString, error) {
	event := new(ValidatorsDiamondTestLogNamedString)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedUintIterator struct {
	Event *ValidatorsDiamondTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogNamedUint represents a LogNamedUint event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogNamedUintIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogNamedUintIterator{contract: _ValidatorsDiamondTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogNamedUint)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogNamedUint(log types.Log) (*ValidatorsDiamondTestLogNamedUint, error) {
	event := new(ValidatorsDiamondTestLogNamedUint)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogStringIterator struct {
	Event *ValidatorsDiamondTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogString represents a LogString event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogStringIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogStringIterator{contract: _ValidatorsDiamondTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogString) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogString)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogString(log types.Log) (*ValidatorsDiamondTestLogString, error) {
	event := new(ValidatorsDiamondTestLogString)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogUintIterator struct {
	Event *ValidatorsDiamondTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogUint represents a LogUint event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogUintIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogUintIterator{contract: _ValidatorsDiamondTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogUint)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogUint(log types.Log) (*ValidatorsDiamondTestLogUint, error) {
	event := new(ValidatorsDiamondTestLogUint)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsDiamondTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogsIterator struct {
	Event *ValidatorsDiamondTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsDiamondTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsDiamondTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsDiamondTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsDiamondTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsDiamondTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsDiamondTestLogs represents a Logs event raised by the ValidatorsDiamondTest contract.
type ValidatorsDiamondTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ValidatorsDiamondTestLogsIterator, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ValidatorsDiamondTestLogsIterator{contract: _ValidatorsDiamondTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ValidatorsDiamondTestLogs) (event.Subscription, error) {

	logs, sub, err := _ValidatorsDiamondTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsDiamondTestLogs)
				if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsDiamondTest *ValidatorsDiamondTestFilterer) ParseLogs(log types.Log) (*ValidatorsDiamondTestLogs, error) {
	event := new(ValidatorsDiamondTestLogs)
	if err := _ValidatorsDiamondTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotABI is the input ABI used to generate the binding from.
const ValidatorsSnapshotABI = "[{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"startingETHDKG\",\"type\":\"bool\"}],\"name\":\"SnapshotTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorQueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"src\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"extractUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"src\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"extractUint32\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"val\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getChainIdFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getMadHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawBlockClaimsSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawSignatureSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"grantOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"majorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signatureGroup\",\"type\":\"bytes\"}],\"name\":\"parseSignatureGroup\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"publicKey\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"signature\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"orig\",\"type\":\"bytes\"}],\"name\":\"reverse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"reversed\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractDSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signatureGroup\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_bclaims\",\"type\":\"bytes\"}],\"name\":\"snapshot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorMaxCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ValidatorsSnapshotBin is the compiled bytecode used for deploying new contracts.
var ValidatorsSnapshotBin = "0x6080604052620000196200012f60201b620026a61760201c565b60056000820151816002015560208201518160030155505033600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a233600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555062000129600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166200015560201b60201c565b620002d9565b62000139620002bf565b6040518060400160405280600181526020016000815250905090565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620001fb5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000252576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062002a7e6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b604051806040016040528060008152602001600081525090565b61279580620002e96000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80638da5cb5b116100f9578063e348da1311610097578063ec5ffac211610071578063ec5ffac214610b1c578063f7b2a7be14610b3a578063fad8b32a14610b58578063fdf553cf14610b9c576101a9565b8063e348da1314610956578063e380b2281461099a578063ec11c823146109e8576101a9565b8063ad43d845116100d3578063ad43d845146107ff578063be9a65551461081d578063bf7e214f14610827578063c1312f4d14610871576101a9565b80638da5cb5b14610671578063900cf0cf146106bb5780639be2f2df146106d9576101a9565b80631c8c8ba4116101665780636372fe51116101405780636372fe51146105465780636d059126146105ed57806375f12b211461060b5780637a9e5e4b1461062d576101a9565b80631c8c8ba41461037857806335b6c632146104515780634f4ea614146104f8576101a9565b806307da68f5146101ae57806308ca1f25146101b857806309f0d45d1461029e5780630f43a677146102c257806313af4035146102e657806319f746691461032a575b600080fd5b6101b6610bba565b005b610284600480360360408110156101ce57600080fd5b81019080803590602001906401000000008111156101eb57600080fd5b8201836020820111156101fd57600080fd5b8035906020019184600183028401116401000000008311171561021f57600080fd5b90919293919293908035906020019064010000000081111561024057600080fd5b82018360208201111561025257600080fd5b8035906020019184600183028401116401000000008311171561027457600080fd5b9091929391929390505050610d33565b604051808215151515815260200191505060405180910390f35b6102a6611655565b604051808260ff1660ff16815260200191505060405180910390f35b6102ca611668565b604051808260ff1660ff16815260200191505060405180910390f35b610328600480360360208110156102fc57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061167b565b005b6103566004803603602081101561034057600080fd5b81019080803590602001909291905050506117c4565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b61043b6004803603604081101561038e57600080fd5b81019080803590602001906401000000008111156103ab57600080fd5b8201836020820111156103bd57600080fd5b803590602001918460018302840111640100000000831117156103df57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803590602001909291905050506117f4565b6040518082815260200191505060405180910390f35b61047d6004803603602081101561046757600080fd5b8101908080359060200190929190505050611865565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156104bd5780820151818401526020810190506104a2565b50505050905090810190601f1680156104ea5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105246004803603602081101561050e57600080fd5b810190808035906020019092919050505061191d565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6105726004803603602081101561055c57600080fd5b810190808035906020019092919050505061194d565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105b2578082015181840152602081019050610597565b50505050905090810190601f1680156105df5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105f5611a05565b6040518082815260200191505060405180910390f35b610613611a0b565b604051808215151515815260200191505060405180910390f35b61066f6004803603602081101561064357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611a1e565b005b610679611b65565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6106c3611b8b565b6040518082815260200191505060405180910390f35b610792600480360360208110156106ef57600080fd5b810190808035906020019064010000000081111561070c57600080fd5b82018360208201111561071e57600080fd5b8035906020019184600183028401116401000000008311171561074057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050611b91565b6040518083600460200280838360005b838110156107bd5780820151818401526020810190506107a2565b5050505090500182600260200280838360005b838110156107eb5780820151818401526020810190506107d0565b505050509050019250505060405180910390f35b610807611c7a565b6040518082815260200191505060405180910390f35b610825611c80565b005b61082f611dfa565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6109346004803603604081101561088757600080fd5b81019080803590602001906401000000008111156108a457600080fd5b8201836020820111156108b657600080fd5b803590602001918460018302840111640100000000831117156108d857600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050611e1f565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6109986004803603602081101561096c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611ed0565b005b6109c6600480360360208110156109b057600080fd5b8101908080359060200190929190505050612037565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b610aa1600480360360208110156109fe57600080fd5b8101908080359060200190640100000000811115610a1b57600080fd5b820183602082011115610a2d57600080fd5b80359060200191846001830284011164010000000083111715610a4f57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050612067565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610ae1578082015181840152602081019050610ac6565b50505050905090810190601f168015610b0e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610b24612131565b6040518082815260200191505060405180910390f35b610b42612137565b6040518082815260200191505060405180910390f35b610b9a60048036036020811015610b6e57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061213d565b005b610ba4612314565b6040518082815260200191505060405180910390f35b610be8336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b610c5a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60008060006004359250602435915034905060018060146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000600160149054906101000a900460ff1615610db8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b610dc0612573565b610dc8612595565b610e1587878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050611b91565b809250819350505060608585604051808383808284378083019250505092505050604051809103902060405160200180828152602001915050604051602081830303815290604052905060006060600960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16838587604051602401808060200184600260200280838360005b83811015610ed1578082015181840152602081019050610eb6565b5050505090500183600460200280838360005b83811015610eff578082015181840152602081019050610ee4565b50505050905001828103825285818151815260200191508051906020019080838360005b83811015610f3e578082015181840152602081019050610f23565b50505050905090810190601f168015610f6b5780820380516001836020036101000a031916815260200191505b509450505050506040516020818303038152906040527f06367587000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106110225780518252602082019150602081019050602083039250610fff565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114611084576040519150601f19603f3d011682016040523d82523d6000602084013e611089565b606091505b50809250819350505081611105576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f5369676e617475726520766572696669636174696f6e206661696c656400000081525060200191505060405180910390fd5b600061115689898080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506008611e1f565b905060006111a98a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050600c611e1f565b90506000601b60006013548152602001908152602001600020905060018160000160006101000a81548160ff0219169083151502179055508a8a8260010191906111f49291906125b7565b508c8c8260020191906112089291906125b7565b50438160030160006101000a81548163ffffffff021916908363ffffffff160217905550818160030160046101000a81548163ffffffff021916908363ffffffff160217905550828160000160016101000a81548163ffffffff021916908363ffffffff1602179055506001601354111561156b57611285612637565b601b600060016013540381526020019081526020016000206040518060c00160405290816000820160009054906101000a900460ff161515151581526020016000820160019054906101000a900463ffffffff1663ffffffff1663ffffffff168152602001600182018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156113825780601f1061135757610100808354040283529160200191611382565b820191906000526020600020905b81548152906001019060200180831161136557829003601f168201915b50505050508152602001600282018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156114245780601f106113f957610100808354040283529160200191611424565b820191906000526020600020905b81548152906001019060200180831161140757829003601f168201915b505050505081526020016003820160009054906101000a900463ffffffff1663ffffffff1663ffffffff1681526020016003820160049054906101000a900463ffffffff1663ffffffff1663ffffffff168152505090508060000151158061149a575061010081608001510163ffffffff164310155b6114ef576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001806126e56026913960400191505060405180910390fd5b8060000151158061151457506104008160a001510163ffffffff168363ffffffff1610155b611569576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602481526020018061270b6024913960400191505060405180910390fd5b505b6000601560009054906101000a900460ff161561158757600190505b6000601560006101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff166013547f6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a8686601560009054906101000a900460ff16604051808463ffffffff1663ffffffff1681526020018363ffffffff1663ffffffff16815260200182151515158152602001935050505060405180910390a360136000815480929190600101919050555060009950505050505050505050949350505050565b601260009054906101000a900460ff1681565b601a60009054906101000a900460ff1681565b6116a9336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b61171b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b6000601b600083815260200190815260200160002060000160019054906101000a900463ffffffff169050919050565b600080601f830190505b8281111561183957600882901b84828151811061181757fe5b602001015160f81c60f81b60f81c60ff161791508080600190039150506117fe565b50600881901b83838151811061184b57fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b6060601b60008381526020019081526020016000206002018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156119115780601f106118e657610100808354040283529160200191611911565b820191906000526020600020905b8154815290600101906020018083116118f457829003601f168201915b50505050509050919050565b6000601b600083815260200190815260200160002060030160049054906101000a900463ffffffff169050919050565b6060601b60008381526020019081526020016000206001018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156119f95780601f106119ce576101008083540402835291602001916119f9565b820191906000526020600020905b8154815290600101906020018083116119dc57829003601f168201915b50505050509050919050565b600f5481565b600160149054906101000a900460ff1681565b611a4c336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b611abe576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60135481565b611b99612573565b611ba1612595565b6060611bac84612067565b9050611bb98160006117f4565b82600160028110611bc657fe5b602002018181525050611bda8160206117f4565b82600060028110611be757fe5b602002018181525050611bfb8160406117f4565b83600360048110611c0857fe5b602002018181525050611c1c8160606117f4565b83600260048110611c2957fe5b602002018181525050611c3d8160806117f4565b83600160048110611c4a57fe5b602002018181525050611c5e8160a06117f4565b83600060048110611c6b57fe5b60200201818152505050915091565b600e5481565b611cae336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b611d20576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506000600160146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000826003830181518110611e3057fe5b602001015160f81c60f81b60f81c60ff169050826002830181518110611e5257fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b179050826001830181518110611e8057fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b179050828281518110611eab57fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611f755750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611fca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018061272f6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b6000601b600083815260200190815260200160002060030160009054906101000a900463ffffffff169050919050565b6060815167ffffffffffffffff8111801561208157600080fd5b506040519080825280601f01601f1916602001820160405280156120b45781602001600182028036833780820191505090505b50905060008090505b825181101561212b578281815181106120d257fe5b602001015160f81c60f81b8260018386510303815181106120ef57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506120bd565b50919050565b600d5481565b60105481565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806121e25750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018061272f6031913960400191505060405180910390fd5b6001600354116122af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556003600081548092919060019003919050555050565b60115481565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415612359576001905061256d565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156123b8576001905061256d565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415612417576000905061256d565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561252f57600080fd5b505afa158015612543573d6000803e3d6000fd5b505050506040513d602081101561255957600080fd5b810190808051906020019092919050505090505b92915050565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106125f857803560ff1916838001178555612626565b82800160010185558215612626579182015b8281111561262557823582559160200191906001019061260a565b5b5090506126339190612681565b5090565b6040518060c00160405280600015158152602001600063ffffffff1681526020016060815260200160608152602001600063ffffffff168152602001600063ffffffff1681525090565b6126a391905b8082111561269f576000816000905550600101612687565b5090565b90565b6126ae6126ca565b6040518060400160405280600181526020016000815250905090565b60405180604001604052806000815260200160008152509056fe736e617073686f74206865696768747320746f6f20636c6f736520696e20457468657265756d736e617073686f74206865696768747320746f6f20636c6f736520696e204d61644e657446756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea26469706673582212202119b852c9f69307219e34ab62f6ae1c5c5e6e0e3b56c45384a5732e558ffedc64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e"

// DeployValidatorsSnapshot deploys a new Ethereum contract, binding an instance of ValidatorsSnapshot to it.
func DeployValidatorsSnapshot(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsSnapshot, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsSnapshotABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsSnapshotBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsSnapshot{ValidatorsSnapshotCaller: ValidatorsSnapshotCaller{contract: contract}, ValidatorsSnapshotTransactor: ValidatorsSnapshotTransactor{contract: contract}, ValidatorsSnapshotFilterer: ValidatorsSnapshotFilterer{contract: contract}}, nil
}

// ValidatorsSnapshot is an auto generated Go binding around an Ethereum contract.
type ValidatorsSnapshot struct {
	ValidatorsSnapshotCaller     // Read-only binding to the contract
	ValidatorsSnapshotTransactor // Write-only binding to the contract
	ValidatorsSnapshotFilterer   // Log filterer for contract events
}

// ValidatorsSnapshotCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsSnapshotCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsSnapshotFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsSnapshotSession struct {
	Contract     *ValidatorsSnapshot // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ValidatorsSnapshotCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsSnapshotCallerSession struct {
	Contract *ValidatorsSnapshotCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ValidatorsSnapshotTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsSnapshotTransactorSession struct {
	Contract     *ValidatorsSnapshotTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ValidatorsSnapshotRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsSnapshotRaw struct {
	Contract *ValidatorsSnapshot // Generic contract binding to access the raw methods on
}

// ValidatorsSnapshotCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsSnapshotCallerRaw struct {
	Contract *ValidatorsSnapshotCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsSnapshotTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTransactorRaw struct {
	Contract *ValidatorsSnapshotTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsSnapshot creates a new instance of ValidatorsSnapshot, bound to a specific deployed contract.
func NewValidatorsSnapshot(address common.Address, backend bind.ContractBackend) (*ValidatorsSnapshot, error) {
	contract, err := bindValidatorsSnapshot(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshot{ValidatorsSnapshotCaller: ValidatorsSnapshotCaller{contract: contract}, ValidatorsSnapshotTransactor: ValidatorsSnapshotTransactor{contract: contract}, ValidatorsSnapshotFilterer: ValidatorsSnapshotFilterer{contract: contract}}, nil
}

// NewValidatorsSnapshotCaller creates a new read-only instance of ValidatorsSnapshot, bound to a specific deployed contract.
func NewValidatorsSnapshotCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsSnapshotCaller, error) {
	contract, err := bindValidatorsSnapshot(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotCaller{contract: contract}, nil
}

// NewValidatorsSnapshotTransactor creates a new write-only instance of ValidatorsSnapshot, bound to a specific deployed contract.
func NewValidatorsSnapshotTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsSnapshotTransactor, error) {
	contract, err := bindValidatorsSnapshot(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTransactor{contract: contract}, nil
}

// NewValidatorsSnapshotFilterer creates a new log filterer instance of ValidatorsSnapshot, bound to a specific deployed contract.
func NewValidatorsSnapshotFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsSnapshotFilterer, error) {
	contract, err := bindValidatorsSnapshot(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotFilterer{contract: contract}, nil
}

// bindValidatorsSnapshot binds a generic wrapper to an already deployed contract.
func bindValidatorsSnapshot(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsSnapshotABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsSnapshot *ValidatorsSnapshotRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsSnapshot.Contract.ValidatorsSnapshotCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsSnapshot *ValidatorsSnapshotRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.ValidatorsSnapshotTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsSnapshot *ValidatorsSnapshotRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.ValidatorsSnapshotTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsSnapshot.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.contract.Transact(opts, method, params...)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Authority() (common.Address, error) {
	return _ValidatorsSnapshot.Contract.Authority(&_ValidatorsSnapshot.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) Authority() (common.Address, error) {
	return _ValidatorsSnapshot.Contract.Authority(&_ValidatorsSnapshot.CallOpts)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) Epoch(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "epoch")
	return *ret0, err
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Epoch() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.Epoch(&_ValidatorsSnapshot.CallOpts)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) Epoch() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.Epoch(&_ValidatorsSnapshot.CallOpts)
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) ExtractUint256(opts *bind.CallOpts, src []byte, offset *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "extractUint256", src, offset)
	return *ret0, err
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) ExtractUint256(src []byte, offset *big.Int) (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.ExtractUint256(&_ValidatorsSnapshot.CallOpts, src, offset)
}

// ExtractUint256 is a free data retrieval call binding the contract method 0x1c8c8ba4.
//
// Solidity: function extractUint256(bytes src, uint256 offset) pure returns(uint256 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) ExtractUint256(src []byte, offset *big.Int) (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.ExtractUint256(&_ValidatorsSnapshot.CallOpts, src, offset)
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) ExtractUint32(opts *bind.CallOpts, src []byte, idx *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "extractUint32", src, idx)
	return *ret0, err
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) ExtractUint32(src []byte, idx *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.ExtractUint32(&_ValidatorsSnapshot.CallOpts, src, idx)
}

// ExtractUint32 is a free data retrieval call binding the contract method 0xc1312f4d.
//
// Solidity: function extractUint32(bytes src, uint256 idx) pure returns(uint32 val)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) ExtractUint32(src []byte, idx *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.ExtractUint32(&_ValidatorsSnapshot.CallOpts, src, idx)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) GetChainIdFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "getChainIdFromSnapshot", _epoch)
	return *ret0, err
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetChainIdFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetChainIdFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) GetHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "getHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetHeightFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetHeightFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) GetMadHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "getMadHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetMadHeightFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsSnapshot.Contract.GetMadHeightFromSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) GetRawBlockClaimsSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "getRawBlockClaimsSnapshot", _epoch)
	return *ret0, err
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.GetRawBlockClaimsSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.GetRawBlockClaimsSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) GetRawSignatureSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "getRawSignatureSnapshot", _epoch)
	return *ret0, err
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.GetRawSignatureSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.GetRawSignatureSnapshot(&_ValidatorsSnapshot.CallOpts, _epoch)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) MajorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "majorStakeFine")
	return *ret0, err
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) MajorStakeFine() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MajorStakeFine(&_ValidatorsSnapshot.CallOpts)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) MajorStakeFine() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MajorStakeFine(&_ValidatorsSnapshot.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) MinimumStake(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "minimumStake")
	return *ret0, err
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) MinimumStake() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MinimumStake(&_ValidatorsSnapshot.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) MinimumStake() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MinimumStake(&_ValidatorsSnapshot.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) MinorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "minorStakeFine")
	return *ret0, err
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) MinorStakeFine() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MinorStakeFine(&_ValidatorsSnapshot.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) MinorStakeFine() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.MinorStakeFine(&_ValidatorsSnapshot.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Owner() (common.Address, error) {
	return _ValidatorsSnapshot.Contract.Owner(&_ValidatorsSnapshot.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) Owner() (common.Address, error) {
	return _ValidatorsSnapshot.Contract.Owner(&_ValidatorsSnapshot.CallOpts)
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) ParseSignatureGroup(opts *bind.CallOpts, _signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	ret := new(struct {
		PublicKey [4]*big.Int
		Signature [2]*big.Int
	})
	out := ret
	err := _ValidatorsSnapshot.contract.Call(opts, out, "parseSignatureGroup", _signatureGroup)
	return *ret, err
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) ParseSignatureGroup(_signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	return _ValidatorsSnapshot.Contract.ParseSignatureGroup(&_ValidatorsSnapshot.CallOpts, _signatureGroup)
}

// ParseSignatureGroup is a free data retrieval call binding the contract method 0x9be2f2df.
//
// Solidity: function parseSignatureGroup(bytes _signatureGroup) pure returns(uint256[4] publicKey, uint256[2] signature)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) ParseSignatureGroup(_signatureGroup []byte) (struct {
	PublicKey [4]*big.Int
	Signature [2]*big.Int
}, error) {
	return _ValidatorsSnapshot.Contract.ParseSignatureGroup(&_ValidatorsSnapshot.CallOpts, _signatureGroup)
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) Reverse(opts *bind.CallOpts, orig []byte) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "reverse", orig)
	return *ret0, err
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Reverse(orig []byte) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.Reverse(&_ValidatorsSnapshot.CallOpts, orig)
}

// Reverse is a free data retrieval call binding the contract method 0xec11c823.
//
// Solidity: function reverse(bytes orig) pure returns(bytes reversed)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) Reverse(orig []byte) ([]byte, error) {
	return _ValidatorsSnapshot.Contract.Reverse(&_ValidatorsSnapshot.CallOpts, orig)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) RewardAmount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "rewardAmount")
	return *ret0, err
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) RewardAmount() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.RewardAmount(&_ValidatorsSnapshot.CallOpts)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) RewardAmount() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.RewardAmount(&_ValidatorsSnapshot.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) RewardBonus(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "rewardBonus")
	return *ret0, err
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) RewardBonus() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.RewardBonus(&_ValidatorsSnapshot.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) RewardBonus() (*big.Int, error) {
	return _ValidatorsSnapshot.Contract.RewardBonus(&_ValidatorsSnapshot.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Stopped() (bool, error) {
	return _ValidatorsSnapshot.Contract.Stopped(&_ValidatorsSnapshot.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() view returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) Stopped() (bool, error) {
	return _ValidatorsSnapshot.Contract.Stopped(&_ValidatorsSnapshot.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) ValidatorCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "validatorCount")
	return *ret0, err
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) ValidatorCount() (uint8, error) {
	return _ValidatorsSnapshot.Contract.ValidatorCount(&_ValidatorsSnapshot.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) ValidatorCount() (uint8, error) {
	return _ValidatorsSnapshot.Contract.ValidatorCount(&_ValidatorsSnapshot.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotCaller) ValidatorMaxCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ValidatorsSnapshot.contract.Call(opts, out, "validatorMaxCount")
	return *ret0, err
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) ValidatorMaxCount() (uint8, error) {
	return _ValidatorsSnapshot.Contract.ValidatorMaxCount(&_ValidatorsSnapshot.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsSnapshot *ValidatorsSnapshotCallerSession) ValidatorMaxCount() (uint8, error) {
	return _ValidatorsSnapshot.Contract.ValidatorMaxCount(&_ValidatorsSnapshot.CallOpts)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) GrantOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "grantOperator", _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.GrantOperator(&_ValidatorsSnapshot.TransactOpts, _operator)
}

// GrantOperator is a paid mutator transaction binding the contract method 0xe348da13.
//
// Solidity: function grantOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) GrantOperator(_operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.GrantOperator(&_ValidatorsSnapshot.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) RevokeOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "revokeOperator", _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.RevokeOperator(&_ValidatorsSnapshot.TransactOpts, _operator)
}

// RevokeOperator is a paid mutator transaction binding the contract method 0xfad8b32a.
//
// Solidity: function revokeOperator(address _operator) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) RevokeOperator(_operator common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.RevokeOperator(&_ValidatorsSnapshot.TransactOpts, _operator)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.SetAuthority(&_ValidatorsSnapshot.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.SetAuthority(&_ValidatorsSnapshot.TransactOpts, authority_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.SetOwner(&_ValidatorsSnapshot.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.SetOwner(&_ValidatorsSnapshot.TransactOpts, owner_)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) Snapshot(opts *bind.TransactOpts, _signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "snapshot", _signatureGroup, _bclaims)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Snapshot(_signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Snapshot(&_ValidatorsSnapshot.TransactOpts, _signatureGroup, _bclaims)
}

// Snapshot is a paid mutator transaction binding the contract method 0x08ca1f25.
//
// Solidity: function snapshot(bytes _signatureGroup, bytes _bclaims) returns(bool)
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) Snapshot(_signatureGroup []byte, _bclaims []byte) (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Snapshot(&_ValidatorsSnapshot.TransactOpts, _signatureGroup, _bclaims)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) Start(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "start")
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Start() (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Start(&_ValidatorsSnapshot.TransactOpts)
}

// Start is a paid mutator transaction binding the contract method 0xbe9a6555.
//
// Solidity: function start() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) Start() (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Start(&_ValidatorsSnapshot.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshot.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotSession) Stop() (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Stop(&_ValidatorsSnapshot.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_ValidatorsSnapshot *ValidatorsSnapshotTransactorSession) Stop() (*types.Transaction, error) {
	return _ValidatorsSnapshot.Contract.Stop(&_ValidatorsSnapshot.TransactOpts)
}

// ValidatorsSnapshotLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotLogSetAuthorityIterator struct {
	Event *ValidatorsSnapshotLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotLogSetAuthority represents a LogSetAuthority event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*ValidatorsSnapshotLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotLogSetAuthorityIterator{contract: _ValidatorsSnapshot.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotLogSetAuthority)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetAuthority is a log parse operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseLogSetAuthority(log types.Log) (*ValidatorsSnapshotLogSetAuthority, error) {
	event := new(ValidatorsSnapshotLogSetAuthority)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotLogSetOwnerIterator struct {
	Event *ValidatorsSnapshotLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotLogSetOwner represents a LogSetOwner event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*ValidatorsSnapshotLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotLogSetOwnerIterator{contract: _ValidatorsSnapshot.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotLogSetOwner)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogSetOwner is a log parse operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseLogSetOwner(log types.Log) (*ValidatorsSnapshotLogSetOwner, error) {
	event := new(ValidatorsSnapshotLogSetOwner)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotSnapshotTakenIterator is returned from FilterSnapshotTaken and is used to iterate over the raw logs and unpacked data for SnapshotTaken events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotSnapshotTakenIterator struct {
	Event *ValidatorsSnapshotSnapshotTaken // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotSnapshotTakenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotSnapshotTaken)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotSnapshotTaken)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotSnapshotTakenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotSnapshotTakenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotSnapshotTaken represents a SnapshotTaken event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotSnapshotTaken struct {
	ChainId        uint32
	Epoch          *big.Int
	Height         uint32
	Validator      common.Address
	StartingETHDKG bool
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterSnapshotTaken is a free log retrieval operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterSnapshotTaken(opts *bind.FilterOpts, epoch []*big.Int, validator []common.Address) (*ValidatorsSnapshotSnapshotTakenIterator, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotSnapshotTakenIterator{contract: _ValidatorsSnapshot.contract, event: "SnapshotTaken", logs: logs, sub: sub}, nil
}

// WatchSnapshotTaken is a free log subscription operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchSnapshotTaken(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotSnapshotTaken, epoch []*big.Int, validator []common.Address) (event.Subscription, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotSnapshotTaken)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSnapshotTaken is a log parse operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseSnapshotTaken(log types.Log) (*ValidatorsSnapshotSnapshotTaken, error) {
	event := new(ValidatorsSnapshotSnapshotTaken)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotValidatorCreatedIterator is returned from FilterValidatorCreated and is used to iterate over the raw logs and unpacked data for ValidatorCreated events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorCreatedIterator struct {
	Event *ValidatorsSnapshotValidatorCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotValidatorCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotValidatorCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotValidatorCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotValidatorCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotValidatorCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotValidatorCreated represents a ValidatorCreated event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorCreated struct {
	Validator common.Address
	Signer    common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorCreated is a free log retrieval operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterValidatorCreated(opts *bind.FilterOpts, validator []common.Address, signer []common.Address) (*ValidatorsSnapshotValidatorCreatedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotValidatorCreatedIterator{contract: _ValidatorsSnapshot.contract, event: "ValidatorCreated", logs: logs, sub: sub}, nil
}

// WatchValidatorCreated is a free log subscription operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchValidatorCreated(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotValidatorCreated, validator []common.Address, signer []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotValidatorCreated)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorCreated is a log parse operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseValidatorCreated(log types.Log) (*ValidatorsSnapshotValidatorCreated, error) {
	event := new(ValidatorsSnapshotValidatorCreated)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotValidatorJoinedIterator is returned from FilterValidatorJoined and is used to iterate over the raw logs and unpacked data for ValidatorJoined events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorJoinedIterator struct {
	Event *ValidatorsSnapshotValidatorJoined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotValidatorJoinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotValidatorJoined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotValidatorJoined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotValidatorJoinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotValidatorJoinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotValidatorJoined represents a ValidatorJoined event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorJoined struct {
	Validator common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorJoined is a free log retrieval operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterValidatorJoined(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsSnapshotValidatorJoinedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotValidatorJoinedIterator{contract: _ValidatorsSnapshot.contract, event: "ValidatorJoined", logs: logs, sub: sub}, nil
}

// WatchValidatorJoined is a free log subscription operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchValidatorJoined(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotValidatorJoined, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotValidatorJoined)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorJoined is a log parse operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseValidatorJoined(log types.Log) (*ValidatorsSnapshotValidatorJoined, error) {
	event := new(ValidatorsSnapshotValidatorJoined)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotValidatorLeftIterator is returned from FilterValidatorLeft and is used to iterate over the raw logs and unpacked data for ValidatorLeft events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorLeftIterator struct {
	Event *ValidatorsSnapshotValidatorLeft // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotValidatorLeftIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotValidatorLeft)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotValidatorLeft)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotValidatorLeftIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotValidatorLeftIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotValidatorLeft represents a ValidatorLeft event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorLeft struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorLeft is a free log retrieval operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterValidatorLeft(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsSnapshotValidatorLeftIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotValidatorLeftIterator{contract: _ValidatorsSnapshot.contract, event: "ValidatorLeft", logs: logs, sub: sub}, nil
}

// WatchValidatorLeft is a free log subscription operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchValidatorLeft(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotValidatorLeft, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotValidatorLeft)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorLeft is a log parse operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseValidatorLeft(log types.Log) (*ValidatorsSnapshotValidatorLeft, error) {
	event := new(ValidatorsSnapshotValidatorLeft)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotValidatorQueuedIterator is returned from FilterValidatorQueued and is used to iterate over the raw logs and unpacked data for ValidatorQueued events raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorQueuedIterator struct {
	Event *ValidatorsSnapshotValidatorQueued // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotValidatorQueuedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotValidatorQueued)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotValidatorQueued)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotValidatorQueuedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotValidatorQueuedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotValidatorQueued represents a ValidatorQueued event raised by the ValidatorsSnapshot contract.
type ValidatorsSnapshotValidatorQueued struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorQueued is a free log retrieval operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) FilterValidatorQueued(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsSnapshotValidatorQueuedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.FilterLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotValidatorQueuedIterator{contract: _ValidatorsSnapshot.contract, event: "ValidatorQueued", logs: logs, sub: sub}, nil
}

// WatchValidatorQueued is a free log subscription operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) WatchValidatorQueued(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotValidatorQueued, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsSnapshot.contract.WatchLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotValidatorQueued)
				if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorQueued is a log parse operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsSnapshot *ValidatorsSnapshotFilterer) ParseValidatorQueued(log types.Log) (*ValidatorsSnapshotValidatorQueued, error) {
	event := new(ValidatorsSnapshotValidatorQueued)
	if err := _ValidatorsSnapshot.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestABI is the input ABI used to generate the binding from.
const ValidatorsSnapshotTestABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint256\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testExtractUint32\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ValidatorsSnapshotTestBin is the compiled bytecode used for deploying new contracts.
var ValidatorsSnapshotTestBin = "0x608060405260016000806101000a81548160ff02191690831515021790555034801561002a57600080fd5b506131268061003a6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80630a9254e41461005c5780633e6fe276146100665780638350596914610070578063ba414fa61461007a578063fa7626d41461009c575b600080fd5b6100646100be565b005b61006e610129565b005b61007861029a565b005b610082610411565b604051808215151515815260200191505060405180910390f35b6100a4610424565b604051808215151515815260200191505060405180910390f35b6040516100ca90610592565b604051809103906000f0801580156100e6573d6000803e3d6000fd5b50600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b60606040518060a001604052806080815260200161307160809139905060007fd8d6b02811ca34cef0bcbc79cc5dfaf2dc6b8133ea46d552ebfc96f1c2b2d71090506000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631c8c8ba48460006040518363ffffffff1660e01b81526004018080602001838152602001828103825284818151815260200191508051906020019080838360005b838110156102035780820151818401526020810190506101e8565b50505050905090810190601f1680156102305780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b15801561024e57600080fd5b505afa158015610262573d6000803e3d6000fd5b505050506040513d602081101561027857600080fd5b810190808051906020019092919050505090506102958183610436565b505050565b60606040518060400160405280600481526020017f0102040000000000000000000000000000000000000000000000000000000000815250905060006204020190506000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c1312f4d8460006040518363ffffffff1660e01b81526004018080602001838152602001828103825284818151815260200191508051906020019080838360005b83811015610374578082015181840152602081019050610359565b50505050905090810190601f1680156103a15780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b1580156103bf57600080fd5b505afa1580156103d3573d6000803e3d6000fd5b505050506040513d60208110156103e957600080fd5b8101908080519060200190929190505050905061040c8163ffffffff1683610436565b505050565b600060019054906101000a900460ff1681565b6000809054906101000a900460ff1681565b808214610571577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405180806020018281038252602281526020018061304f6022913960400191505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88160405180806020018381526020018281038252600a8152602001807f20204578706563746564000000000000000000000000000000000000000000008152506020019250505060405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a88260405180806020018381526020018281038252600a8152602001807f2020202041637475616c000000000000000000000000000000000000000000008152506020019250505060405180910390a1610570610575565b5b5050565b6001600060016101000a81548160ff021916908315150217905550565b612aaf806105a08339019056fe6080604052620000196200012f60201b620026a61760201c565b60056000820151816002015560208201518160030155505033600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a233600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555062000129600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166200015560201b60201c565b620002d9565b62000139620002bf565b6040518060400160405280600181526020016000815250905090565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480620001fb5750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b62000252576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018062002a7e6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b604051806040016040528060008152602001600081525090565b61279580620002e96000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80638da5cb5b116100f9578063e348da1311610097578063ec5ffac211610071578063ec5ffac214610b1c578063f7b2a7be14610b3a578063fad8b32a14610b58578063fdf553cf14610b9c576101a9565b8063e348da1314610956578063e380b2281461099a578063ec11c823146109e8576101a9565b8063ad43d845116100d3578063ad43d845146107ff578063be9a65551461081d578063bf7e214f14610827578063c1312f4d14610871576101a9565b80638da5cb5b14610671578063900cf0cf146106bb5780639be2f2df146106d9576101a9565b80631c8c8ba4116101665780636372fe51116101405780636372fe51146105465780636d059126146105ed57806375f12b211461060b5780637a9e5e4b1461062d576101a9565b80631c8c8ba41461037857806335b6c632146104515780634f4ea614146104f8576101a9565b806307da68f5146101ae57806308ca1f25146101b857806309f0d45d1461029e5780630f43a677146102c257806313af4035146102e657806319f746691461032a575b600080fd5b6101b6610bba565b005b610284600480360360408110156101ce57600080fd5b81019080803590602001906401000000008111156101eb57600080fd5b8201836020820111156101fd57600080fd5b8035906020019184600183028401116401000000008311171561021f57600080fd5b90919293919293908035906020019064010000000081111561024057600080fd5b82018360208201111561025257600080fd5b8035906020019184600183028401116401000000008311171561027457600080fd5b9091929391929390505050610d33565b604051808215151515815260200191505060405180910390f35b6102a6611655565b604051808260ff1660ff16815260200191505060405180910390f35b6102ca611668565b604051808260ff1660ff16815260200191505060405180910390f35b610328600480360360208110156102fc57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061167b565b005b6103566004803603602081101561034057600080fd5b81019080803590602001909291905050506117c4565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b61043b6004803603604081101561038e57600080fd5b81019080803590602001906401000000008111156103ab57600080fd5b8201836020820111156103bd57600080fd5b803590602001918460018302840111640100000000831117156103df57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803590602001909291905050506117f4565b6040518082815260200191505060405180910390f35b61047d6004803603602081101561046757600080fd5b8101908080359060200190929190505050611865565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156104bd5780820151818401526020810190506104a2565b50505050905090810190601f1680156104ea5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105246004803603602081101561050e57600080fd5b810190808035906020019092919050505061191d565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6105726004803603602081101561055c57600080fd5b810190808035906020019092919050505061194d565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105b2578082015181840152602081019050610597565b50505050905090810190601f1680156105df5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105f5611a05565b6040518082815260200191505060405180910390f35b610613611a0b565b604051808215151515815260200191505060405180910390f35b61066f6004803603602081101561064357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611a1e565b005b610679611b65565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6106c3611b8b565b6040518082815260200191505060405180910390f35b610792600480360360208110156106ef57600080fd5b810190808035906020019064010000000081111561070c57600080fd5b82018360208201111561071e57600080fd5b8035906020019184600183028401116401000000008311171561074057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050611b91565b6040518083600460200280838360005b838110156107bd5780820151818401526020810190506107a2565b5050505090500182600260200280838360005b838110156107eb5780820151818401526020810190506107d0565b505050509050019250505060405180910390f35b610807611c7a565b6040518082815260200191505060405180910390f35b610825611c80565b005b61082f611dfa565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6109346004803603604081101561088757600080fd5b81019080803590602001906401000000008111156108a457600080fd5b8201836020820111156108b657600080fd5b803590602001918460018302840111640100000000831117156108d857600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050611e1f565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6109986004803603602081101561096c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611ed0565b005b6109c6600480360360208110156109b057600080fd5b8101908080359060200190929190505050612037565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b610aa1600480360360208110156109fe57600080fd5b8101908080359060200190640100000000811115610a1b57600080fd5b820183602082011115610a2d57600080fd5b80359060200191846001830284011164010000000083111715610a4f57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050612067565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610ae1578082015181840152602081019050610ac6565b50505050905090810190601f168015610b0e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610b24612131565b6040518082815260200191505060405180910390f35b610b42612137565b6040518082815260200191505060405180910390f35b610b9a60048036036020811015610b6e57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061213d565b005b610ba4612314565b6040518082815260200191505060405180910390f35b610be8336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b610c5a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b60008060006004359250602435915034905060018060146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000600160149054906101000a900460ff1615610db8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f64732d73746f702d69732d73746f70706564000000000000000000000000000081525060200191505060405180910390fd5b610dc0612573565b610dc8612595565b610e1587878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050611b91565b809250819350505060608585604051808383808284378083019250505092505050604051809103902060405160200180828152602001915050604051602081830303815290604052905060006060600960009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16838587604051602401808060200184600260200280838360005b83811015610ed1578082015181840152602081019050610eb6565b5050505090500183600460200280838360005b83811015610eff578082015181840152602081019050610ee4565b50505050905001828103825285818151815260200191508051906020019080838360005b83811015610f3e578082015181840152602081019050610f23565b50505050905090810190601f168015610f6b5780820380516001836020036101000a031916815260200191505b509450505050506040516020818303038152906040527f06367587000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106110225780518252602082019150602081019050602083039250610fff565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114611084576040519150601f19603f3d011682016040523d82523d6000602084013e611089565b606091505b50809250819350505081611105576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f5369676e617475726520766572696669636174696f6e206661696c656400000081525060200191505060405180910390fd5b600061115689898080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506008611e1f565b905060006111a98a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050600c611e1f565b90506000601b60006013548152602001908152602001600020905060018160000160006101000a81548160ff0219169083151502179055508a8a8260010191906111f49291906125b7565b508c8c8260020191906112089291906125b7565b50438160030160006101000a81548163ffffffff021916908363ffffffff160217905550818160030160046101000a81548163ffffffff021916908363ffffffff160217905550828160000160016101000a81548163ffffffff021916908363ffffffff1602179055506001601354111561156b57611285612637565b601b600060016013540381526020019081526020016000206040518060c00160405290816000820160009054906101000a900460ff161515151581526020016000820160019054906101000a900463ffffffff1663ffffffff1663ffffffff168152602001600182018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156113825780601f1061135757610100808354040283529160200191611382565b820191906000526020600020905b81548152906001019060200180831161136557829003601f168201915b50505050508152602001600282018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156114245780601f106113f957610100808354040283529160200191611424565b820191906000526020600020905b81548152906001019060200180831161140757829003601f168201915b505050505081526020016003820160009054906101000a900463ffffffff1663ffffffff1663ffffffff1681526020016003820160049054906101000a900463ffffffff1663ffffffff1663ffffffff168152505090508060000151158061149a575061010081608001510163ffffffff164310155b6114ef576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001806126e56026913960400191505060405180910390fd5b8060000151158061151457506104008160a001510163ffffffff168363ffffffff1610155b611569576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602481526020018061270b6024913960400191505060405180910390fd5b505b6000601560009054906101000a900460ff161561158757600190505b6000601560006101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff166013547f6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a8686601560009054906101000a900460ff16604051808463ffffffff1663ffffffff1681526020018363ffffffff1663ffffffff16815260200182151515158152602001935050505060405180910390a360136000815480929190600101919050555060009950505050505050505050949350505050565b601260009054906101000a900460ff1681565b601a60009054906101000a900460ff1681565b6116a9336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b61171b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b6000601b600083815260200190815260200160002060000160019054906101000a900463ffffffff169050919050565b600080601f830190505b8281111561183957600882901b84828151811061181757fe5b602001015160f81c60f81b60f81c60ff161791508080600190039150506117fe565b50600881901b83838151811061184b57fe5b602001015160f81c60f81b60f81c60ff1617905092915050565b6060601b60008381526020019081526020016000206002018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156119115780601f106118e657610100808354040283529160200191611911565b820191906000526020600020905b8154815290600101906020018083116118f457829003601f168201915b50505050509050919050565b6000601b600083815260200190815260200160002060030160049054906101000a900463ffffffff169050919050565b6060601b60008381526020019081526020016000206001018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156119f95780601f106119ce576101008083540402835291602001916119f9565b820191906000526020600020905b8154815290600101906020018083116119dc57829003601f168201915b50505050509050919050565b600f5481565b600160149054906101000a900460ff1681565b611a4c336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b611abe576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60135481565b611b99612573565b611ba1612595565b6060611bac84612067565b9050611bb98160006117f4565b82600160028110611bc657fe5b602002018181525050611bda8160206117f4565b82600060028110611be757fe5b602002018181525050611bfb8160406117f4565b83600360048110611c0857fe5b602002018181525050611c1c8160606117f4565b83600260048110611c2957fe5b602002018181525050611c3d8160806117f4565b83600160048110611c4a57fe5b602002018181525050611c5e8160a06117f4565b83600060048110611c6b57fe5b60200201818152505050915091565b600e5481565b611cae336000357fffffffff000000000000000000000000000000000000000000000000000000001661231a565b611d20576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d617574682d756e617574686f72697a656400000000000000000000000081525060200191505060405180910390fd5b6000806000600435925060243591503490506000600160146101000a81548160ff02191690831515021790555081833373ffffffffffffffffffffffffffffffffffffffff166000357fffffffff00000000000000000000000000000000000000000000000000000000167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168460003660405180848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505094505050505060405180910390a4505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000826003830181518110611e3057fe5b602001015160f81c60f81b60f81c60ff169050826002830181518110611e5257fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b179050826001830181518110611e8057fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b179050828281518110611eab57fe5b602001015160f81c60f81b60f81c60ff1660088263ffffffff16901b17905092915050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611f755750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b611fca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018061272f6031913960400191505060405180910390fd5b6001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555060036000815480929190600101919050555050565b6000601b600083815260200190815260200160002060030160009054906101000a900463ffffffff169050919050565b6060815167ffffffffffffffff8111801561208157600080fd5b506040519080825280601f01601f1916602001820160405280156120b45781602001600182028036833780820191505090505b50905060008090505b825181101561212b578281815181106120d257fe5b602001015160f81c60f81b8260018386510303815181106120ef57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506120bd565b50919050565b600d5481565b60105481565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806121e25750600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b612237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603181526020018061272f6031913960400191505060405180910390fd5b6001600354116122af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f43616e27742072656d6f766520616c6c206f70657261746f727300000000000081525060200191505060405180910390fd5b600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556003600081548092919060019003919050555050565b60115481565b60003073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415612359576001905061256d565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156123b8576001905061256d565b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415612417576000905061256d565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b70096138430856040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001935050505060206040518083038186803b15801561252f57600080fd5b505afa158015612543573d6000803e3d6000fd5b505050506040513d602081101561255957600080fd5b810190808051906020019092919050505090505b92915050565b6040518060800160405280600490602082028036833780820191505090505090565b6040518060400160405280600290602082028036833780820191505090505090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106125f857803560ff1916838001178555612626565b82800160010185558215612626579182015b8281111561262557823582559160200191906001019061260a565b5b5090506126339190612681565b5090565b6040518060c00160405280600015158152602001600063ffffffff1681526020016060815260200160608152602001600063ffffffff168152602001600063ffffffff1681525090565b6126a391905b8082111561269f576000816000905550600101612687565b5090565b90565b6126ae6126ca565b6040518060400160405280600181526020016000815250905090565b60405180604001604052806000815260200160008152509056fe736e617073686f74206865696768747320746f6f20636c6f736520696e20457468657265756d736e617073686f74206865696768747320746f6f20636c6f736520696e204d61644e657446756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732ea26469706673582212202119b852c9f69307219e34ab62f6ae1c5c5e6e0e3b56c45384a5732e558ffedc64736f6c6343000607003346756e6374696f6e616c697479207265737472696374656420746f20617574686f72697a6564206f70657261746f72732e4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e745d10d7b2c2f196fceb52d546ea33816bdcf2fa5dcc79bcbcf0ce34ca1128b0d6d82d8652a0c5193001a55c0c43b5e0450297d3824a039d924b08d46520b354251f105a55d55c282005a5813480b48ee1efd61046d06b6084bafcf3c10dac57584b0f0bb886f1f1e04bcfa575020e3f47cceb3c11cd5cba496e5aedddc3a04d5b5ca26469706673582212201d95a1a6c128c9bcb8391bd5a9829d1ccbba2ee2a421fc5a5040d7c46ace141764736f6c63430006070033"

// DeployValidatorsSnapshotTest deploys a new Ethereum contract, binding an instance of ValidatorsSnapshotTest to it.
func DeployValidatorsSnapshotTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsSnapshotTest, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsSnapshotTestABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsSnapshotTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsSnapshotTest{ValidatorsSnapshotTestCaller: ValidatorsSnapshotTestCaller{contract: contract}, ValidatorsSnapshotTestTransactor: ValidatorsSnapshotTestTransactor{contract: contract}, ValidatorsSnapshotTestFilterer: ValidatorsSnapshotTestFilterer{contract: contract}}, nil
}

// ValidatorsSnapshotTest is an auto generated Go binding around an Ethereum contract.
type ValidatorsSnapshotTest struct {
	ValidatorsSnapshotTestCaller     // Read-only binding to the contract
	ValidatorsSnapshotTestTransactor // Write-only binding to the contract
	ValidatorsSnapshotTestFilterer   // Log filterer for contract events
}

// ValidatorsSnapshotTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsSnapshotTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsSnapshotTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsSnapshotTestSession struct {
	Contract     *ValidatorsSnapshotTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts           // Call options to use throughout this session
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ValidatorsSnapshotTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsSnapshotTestCallerSession struct {
	Contract *ValidatorsSnapshotTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                 // Call options to use throughout this session
}

// ValidatorsSnapshotTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsSnapshotTestTransactorSession struct {
	Contract     *ValidatorsSnapshotTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                 // Transaction auth options to use throughout this session
}

// ValidatorsSnapshotTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsSnapshotTestRaw struct {
	Contract *ValidatorsSnapshotTest // Generic contract binding to access the raw methods on
}

// ValidatorsSnapshotTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTestCallerRaw struct {
	Contract *ValidatorsSnapshotTestCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsSnapshotTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsSnapshotTestTransactorRaw struct {
	Contract *ValidatorsSnapshotTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsSnapshotTest creates a new instance of ValidatorsSnapshotTest, bound to a specific deployed contract.
func NewValidatorsSnapshotTest(address common.Address, backend bind.ContractBackend) (*ValidatorsSnapshotTest, error) {
	contract, err := bindValidatorsSnapshotTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTest{ValidatorsSnapshotTestCaller: ValidatorsSnapshotTestCaller{contract: contract}, ValidatorsSnapshotTestTransactor: ValidatorsSnapshotTestTransactor{contract: contract}, ValidatorsSnapshotTestFilterer: ValidatorsSnapshotTestFilterer{contract: contract}}, nil
}

// NewValidatorsSnapshotTestCaller creates a new read-only instance of ValidatorsSnapshotTest, bound to a specific deployed contract.
func NewValidatorsSnapshotTestCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsSnapshotTestCaller, error) {
	contract, err := bindValidatorsSnapshotTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestCaller{contract: contract}, nil
}

// NewValidatorsSnapshotTestTransactor creates a new write-only instance of ValidatorsSnapshotTest, bound to a specific deployed contract.
func NewValidatorsSnapshotTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsSnapshotTestTransactor, error) {
	contract, err := bindValidatorsSnapshotTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestTransactor{contract: contract}, nil
}

// NewValidatorsSnapshotTestFilterer creates a new log filterer instance of ValidatorsSnapshotTest, bound to a specific deployed contract.
func NewValidatorsSnapshotTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsSnapshotTestFilterer, error) {
	contract, err := bindValidatorsSnapshotTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestFilterer{contract: contract}, nil
}

// bindValidatorsSnapshotTest binds a generic wrapper to an already deployed contract.
func bindValidatorsSnapshotTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsSnapshotTestABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsSnapshotTest.Contract.ValidatorsSnapshotTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.ValidatorsSnapshotTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.ValidatorsSnapshotTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsSnapshotTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ValidatorsSnapshotTest.contract.Call(opts, out, "IS_TEST")
	return *ret0, err
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestSession) ISTEST() (bool, error) {
	return _ValidatorsSnapshotTest.Contract.ISTEST(&_ValidatorsSnapshotTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestCallerSession) ISTEST() (bool, error) {
	return _ValidatorsSnapshotTest.Contract.ISTEST(&_ValidatorsSnapshotTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestCaller) Failed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ValidatorsSnapshotTest.contract.Call(opts, out, "failed")
	return *ret0, err
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestSession) Failed() (bool, error) {
	return _ValidatorsSnapshotTest.Contract.Failed(&_ValidatorsSnapshotTest.CallOpts)
}

// Failed is a free data retrieval call binding the contract method 0xba414fa6.
//
// Solidity: function failed() view returns(bool)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestCallerSession) Failed() (bool, error) {
	return _ValidatorsSnapshotTest.Contract.Failed(&_ValidatorsSnapshotTest.CallOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestSession) SetUp() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.SetUp(&_ValidatorsSnapshotTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.SetUp(&_ValidatorsSnapshotTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactor) TestExtractUint256(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.contract.Transact(opts, "testExtractUint256")
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestSession) TestExtractUint256() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.TestExtractUint256(&_ValidatorsSnapshotTest.TransactOpts)
}

// TestExtractUint256 is a paid mutator transaction binding the contract method 0x3e6fe276.
//
// Solidity: function testExtractUint256() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactorSession) TestExtractUint256() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.TestExtractUint256(&_ValidatorsSnapshotTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactor) TestExtractUint32(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.contract.Transact(opts, "testExtractUint32")
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestSession) TestExtractUint32() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.TestExtractUint32(&_ValidatorsSnapshotTest.TransactOpts)
}

// TestExtractUint32 is a paid mutator transaction binding the contract method 0x83505969.
//
// Solidity: function testExtractUint32() returns()
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestTransactorSession) TestExtractUint32() (*types.Transaction, error) {
	return _ValidatorsSnapshotTest.Contract.TestExtractUint32(&_ValidatorsSnapshotTest.TransactOpts)
}

// ValidatorsSnapshotTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogIterator struct {
	Event *ValidatorsSnapshotTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLog represents a Log event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLog(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogIterator{contract: _ValidatorsSnapshotTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLog) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLog)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLog(log types.Log) (*ValidatorsSnapshotTestLog, error) {
	event := new(ValidatorsSnapshotTestLog)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogAddressIterator struct {
	Event *ValidatorsSnapshotTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogAddress represents a LogAddress event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogAddressIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogAddressIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogAddress)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogAddress(log types.Log) (*ValidatorsSnapshotTestLogAddress, error) {
	event := new(ValidatorsSnapshotTestLogAddress)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogBytesIterator struct {
	Event *ValidatorsSnapshotTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogBytes represents a LogBytes event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogBytesIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogBytesIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogBytes)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogBytes(log types.Log) (*ValidatorsSnapshotTestLogBytes, error) {
	event := new(ValidatorsSnapshotTestLogBytes)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogBytes32Iterator struct {
	Event *ValidatorsSnapshotTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogBytes32 represents a LogBytes32 event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogBytes32Iterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogBytes32Iterator{contract: _ValidatorsSnapshotTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogBytes32)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogBytes32(log types.Log) (*ValidatorsSnapshotTestLogBytes32, error) {
	event := new(ValidatorsSnapshotTestLogBytes32)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogIntIterator struct {
	Event *ValidatorsSnapshotTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogInt represents a LogInt event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogIntIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogIntIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogInt)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogInt(log types.Log) (*ValidatorsSnapshotTestLogInt, error) {
	event := new(ValidatorsSnapshotTestLogInt)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedAddressIterator struct {
	Event *ValidatorsSnapshotTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedAddress represents a LogNamedAddress event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedAddressIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedAddressIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedAddress)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedAddress(log types.Log) (*ValidatorsSnapshotTestLogNamedAddress, error) {
	event := new(ValidatorsSnapshotTestLogNamedAddress)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedBytesIterator struct {
	Event *ValidatorsSnapshotTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedBytes represents a LogNamedBytes event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedBytesIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedBytesIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedBytes)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedBytes(log types.Log) (*ValidatorsSnapshotTestLogNamedBytes, error) {
	event := new(ValidatorsSnapshotTestLogNamedBytes)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedBytes32Iterator struct {
	Event *ValidatorsSnapshotTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedBytes32Iterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedBytes32)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedBytes32(log types.Log) (*ValidatorsSnapshotTestLogNamedBytes32, error) {
	event := new(ValidatorsSnapshotTestLogNamedBytes32)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedDecimalIntIterator struct {
	Event *ValidatorsSnapshotTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedDecimalIntIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedDecimalInt)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ValidatorsSnapshotTestLogNamedDecimalInt, error) {
	event := new(ValidatorsSnapshotTestLogNamedDecimalInt)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedDecimalUintIterator struct {
	Event *ValidatorsSnapshotTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedDecimalUintIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedDecimalUint)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ValidatorsSnapshotTestLogNamedDecimalUint, error) {
	event := new(ValidatorsSnapshotTestLogNamedDecimalUint)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedIntIterator struct {
	Event *ValidatorsSnapshotTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedInt represents a LogNamedInt event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedIntIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedIntIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedInt)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedInt(log types.Log) (*ValidatorsSnapshotTestLogNamedInt, error) {
	event := new(ValidatorsSnapshotTestLogNamedInt)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedStringIterator struct {
	Event *ValidatorsSnapshotTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedString represents a LogNamedString event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedStringIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedStringIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedString)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedString(log types.Log) (*ValidatorsSnapshotTestLogNamedString, error) {
	event := new(ValidatorsSnapshotTestLogNamedString)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedUintIterator struct {
	Event *ValidatorsSnapshotTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogNamedUint represents a LogNamedUint event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogNamedUintIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogNamedUintIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogNamedUint)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogNamedUint(log types.Log) (*ValidatorsSnapshotTestLogNamedUint, error) {
	event := new(ValidatorsSnapshotTestLogNamedUint)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogStringIterator struct {
	Event *ValidatorsSnapshotTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogString represents a LogString event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogStringIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogStringIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogString) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogString)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogString(log types.Log) (*ValidatorsSnapshotTestLogString, error) {
	event := new(ValidatorsSnapshotTestLogString)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogUintIterator struct {
	Event *ValidatorsSnapshotTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogUint represents a LogUint event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogUintIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogUintIterator{contract: _ValidatorsSnapshotTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogUint)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogUint(log types.Log) (*ValidatorsSnapshotTestLogUint, error) {
	event := new(ValidatorsSnapshotTestLogUint)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsSnapshotTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogsIterator struct {
	Event *ValidatorsSnapshotTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsSnapshotTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsSnapshotTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsSnapshotTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsSnapshotTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsSnapshotTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsSnapshotTestLogs represents a Logs event raised by the ValidatorsSnapshotTest contract.
type ValidatorsSnapshotTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ValidatorsSnapshotTestLogsIterator, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ValidatorsSnapshotTestLogsIterator{contract: _ValidatorsSnapshotTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ValidatorsSnapshotTestLogs) (event.Subscription, error) {

	logs, sub, err := _ValidatorsSnapshotTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsSnapshotTestLogs)
				if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ValidatorsSnapshotTest *ValidatorsSnapshotTestFilterer) ParseLogs(log types.Log) (*ValidatorsSnapshotTestLogs, error) {
	event := new(ValidatorsSnapshotTestLogs)
	if err := _ValidatorsSnapshotTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageABI is the input ABI used to generate the binding from.
const ValidatorsStorageABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"startingETHDKG\",\"type\":\"bool\"}],\"name\":\"SnapshotTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"madID\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"pkHash\",\"type\":\"uint256[2]\"}],\"name\":\"ValidatorQueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getChainIdFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getMadHeightFromSnapshot\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawBlockClaimsSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getRawSignatureSnapshot\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"majorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minorStakeFine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorMaxCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ValidatorsStorageBin is the compiled bytecode used for deploying new contracts.
var ValidatorsStorageBin = "0x608060405261001661003f60201b6106521760201c565b600080820151816002015560208201518160030155505034801561003957600080fd5b5061007d565b610047610063565b6040518060400160405280600181526020016000815250905090565b604051806040016040528060008152602001600081525090565b6106c68061008c6000396000f3fe608060405234801561001057600080fd5b50600436106100cf5760003560e01c80636d0591261161008c578063e380b22811610066578063e380b22814610360578063ec5ffac2146103ae578063f7b2a7be146103cc578063fdf553cf146103ea576100cf565b80636d05912614610306578063900cf0cf14610324578063ad43d84514610342576100cf565b806309f0d45d146100d45780630f43a677146100f857806319f746691461011c57806335b6c6321461016a5780634f4ea614146102115780636372fe511461025f575b600080fd5b6100dc610408565b604051808260ff1660ff16815260200191505060405180910390f35b61010061041b565b604051808260ff1660ff16815260200191505060405180910390f35b6101486004803603602081101561013257600080fd5b810190808035906020019092919050505061042e565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6101966004803603602081101561018057600080fd5b810190808035906020019092919050505061045e565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101d65780820151818401526020810190506101bb565b50505050905090810190601f1680156102035780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61023d6004803603602081101561022757600080fd5b8101908080359060200190929190505050610516565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b61028b6004803603602081101561027557600080fd5b8101908080359060200190929190505050610546565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156102cb5780820151818401526020810190506102b0565b50505050905090810190601f1680156102f85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61030e6105fe565b6040518082815260200191505060405180910390f35b61032c610604565b6040518082815260200191505060405180910390f35b61034a61060a565b6040518082815260200191505060405180910390f35b61038c6004803603602081101561037657600080fd5b8101908080359060200190929190505050610610565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6103b6610640565b6040518082815260200191505060405180910390f35b6103d4610646565b6040518082815260200191505060405180910390f35b6103f261064c565b6040518082815260200191505060405180910390f35b600d60009054906101000a900460ff1681565b601560009054906101000a900460ff1681565b60006016600083815260200190815260200160002060000160019054906101000a900463ffffffff169050919050565b6060601660008381526020019081526020016000206002018054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561050a5780601f106104df5761010080835404028352916020019161050a565b820191906000526020600020905b8154815290600101906020018083116104ed57829003601f168201915b50505050509050919050565b60006016600083815260200190815260200160002060030160049054906101000a900463ffffffff169050919050565b6060601660008381526020019081526020016000206001018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105f25780601f106105c7576101008083540402835291602001916105f2565b820191906000526020600020905b8154815290600101906020018083116105d557829003601f168201915b50505050509050919050565b600a5481565b600e5481565b60095481565b60006016600083815260200190815260200160002060030160009054906101000a900463ffffffff169050919050565b60085481565b600b5481565b600c5481565b61065a610676565b6040518060400160405280600181526020016000815250905090565b60405180604001604052806000815260200160008152509056fea264697066735822122043974041fb65bd6112a65f45535f7587db234c5731392219d96fc9b9790d97a964736f6c63430006070033"

// DeployValidatorsStorage deploys a new Ethereum contract, binding an instance of ValidatorsStorage to it.
func DeployValidatorsStorage(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsStorage, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsStorageABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsStorageBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsStorage{ValidatorsStorageCaller: ValidatorsStorageCaller{contract: contract}, ValidatorsStorageTransactor: ValidatorsStorageTransactor{contract: contract}, ValidatorsStorageFilterer: ValidatorsStorageFilterer{contract: contract}}, nil
}

// ValidatorsStorage is an auto generated Go binding around an Ethereum contract.
type ValidatorsStorage struct {
	ValidatorsStorageCaller     // Read-only binding to the contract
	ValidatorsStorageTransactor // Write-only binding to the contract
	ValidatorsStorageFilterer   // Log filterer for contract events
}

// ValidatorsStorageCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsStorageCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsStorageTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsStorageFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsStorageSession struct {
	Contract     *ValidatorsStorage // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ValidatorsStorageCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsStorageCallerSession struct {
	Contract *ValidatorsStorageCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// ValidatorsStorageTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsStorageTransactorSession struct {
	Contract     *ValidatorsStorageTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// ValidatorsStorageRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsStorageRaw struct {
	Contract *ValidatorsStorage // Generic contract binding to access the raw methods on
}

// ValidatorsStorageCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsStorageCallerRaw struct {
	Contract *ValidatorsStorageCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsStorageTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsStorageTransactorRaw struct {
	Contract *ValidatorsStorageTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsStorage creates a new instance of ValidatorsStorage, bound to a specific deployed contract.
func NewValidatorsStorage(address common.Address, backend bind.ContractBackend) (*ValidatorsStorage, error) {
	contract, err := bindValidatorsStorage(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorage{ValidatorsStorageCaller: ValidatorsStorageCaller{contract: contract}, ValidatorsStorageTransactor: ValidatorsStorageTransactor{contract: contract}, ValidatorsStorageFilterer: ValidatorsStorageFilterer{contract: contract}}, nil
}

// NewValidatorsStorageCaller creates a new read-only instance of ValidatorsStorage, bound to a specific deployed contract.
func NewValidatorsStorageCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsStorageCaller, error) {
	contract, err := bindValidatorsStorage(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageCaller{contract: contract}, nil
}

// NewValidatorsStorageTransactor creates a new write-only instance of ValidatorsStorage, bound to a specific deployed contract.
func NewValidatorsStorageTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsStorageTransactor, error) {
	contract, err := bindValidatorsStorage(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageTransactor{contract: contract}, nil
}

// NewValidatorsStorageFilterer creates a new log filterer instance of ValidatorsStorage, bound to a specific deployed contract.
func NewValidatorsStorageFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsStorageFilterer, error) {
	contract, err := bindValidatorsStorage(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageFilterer{contract: contract}, nil
}

// bindValidatorsStorage binds a generic wrapper to an already deployed contract.
func bindValidatorsStorage(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsStorageABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsStorage *ValidatorsStorageRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsStorage.Contract.ValidatorsStorageCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsStorage *ValidatorsStorageRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsStorage.Contract.ValidatorsStorageTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsStorage *ValidatorsStorageRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsStorage.Contract.ValidatorsStorageTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsStorage *ValidatorsStorageCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsStorage.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsStorage *ValidatorsStorageTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsStorage.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsStorage *ValidatorsStorageTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsStorage.Contract.contract.Transact(opts, method, params...)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) Epoch(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "epoch")
	return *ret0, err
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) Epoch() (*big.Int, error) {
	return _ValidatorsStorage.Contract.Epoch(&_ValidatorsStorage.CallOpts)
}

// Epoch is a free data retrieval call binding the contract method 0x900cf0cf.
//
// Solidity: function epoch() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) Epoch() (*big.Int, error) {
	return _ValidatorsStorage.Contract.Epoch(&_ValidatorsStorage.CallOpts)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCaller) GetChainIdFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "getChainIdFromSnapshot", _epoch)
	return *ret0, err
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetChainIdFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetChainIdFromSnapshot is a free data retrieval call binding the contract method 0x19f74669.
//
// Solidity: function getChainIdFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) GetChainIdFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetChainIdFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCaller) GetHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "getHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetHeightFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetHeightFromSnapshot is a free data retrieval call binding the contract method 0xe380b228.
//
// Solidity: function getHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) GetHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetHeightFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCaller) GetMadHeightFromSnapshot(opts *bind.CallOpts, _epoch *big.Int) (uint32, error) {
	var (
		ret0 = new(uint32)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "getMadHeightFromSnapshot", _epoch)
	return *ret0, err
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetMadHeightFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetMadHeightFromSnapshot is a free data retrieval call binding the contract method 0x4f4ea614.
//
// Solidity: function getMadHeightFromSnapshot(uint256 _epoch) view returns(uint32)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) GetMadHeightFromSnapshot(_epoch *big.Int) (uint32, error) {
	return _ValidatorsStorage.Contract.GetMadHeightFromSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageCaller) GetRawBlockClaimsSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "getRawBlockClaimsSnapshot", _epoch)
	return *ret0, err
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsStorage.Contract.GetRawBlockClaimsSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetRawBlockClaimsSnapshot is a free data retrieval call binding the contract method 0x6372fe51.
//
// Solidity: function getRawBlockClaimsSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) GetRawBlockClaimsSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsStorage.Contract.GetRawBlockClaimsSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageCaller) GetRawSignatureSnapshot(opts *bind.CallOpts, _epoch *big.Int) ([]byte, error) {
	var (
		ret0 = new([]byte)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "getRawSignatureSnapshot", _epoch)
	return *ret0, err
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsStorage.Contract.GetRawSignatureSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// GetRawSignatureSnapshot is a free data retrieval call binding the contract method 0x35b6c632.
//
// Solidity: function getRawSignatureSnapshot(uint256 _epoch) view returns(bytes)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) GetRawSignatureSnapshot(_epoch *big.Int) ([]byte, error) {
	return _ValidatorsStorage.Contract.GetRawSignatureSnapshot(&_ValidatorsStorage.CallOpts, _epoch)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) MajorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "majorStakeFine")
	return *ret0, err
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) MajorStakeFine() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MajorStakeFine(&_ValidatorsStorage.CallOpts)
}

// MajorStakeFine is a free data retrieval call binding the contract method 0xad43d845.
//
// Solidity: function majorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) MajorStakeFine() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MajorStakeFine(&_ValidatorsStorage.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) MinimumStake(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "minimumStake")
	return *ret0, err
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) MinimumStake() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MinimumStake(&_ValidatorsStorage.CallOpts)
}

// MinimumStake is a free data retrieval call binding the contract method 0xec5ffac2.
//
// Solidity: function minimumStake() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) MinimumStake() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MinimumStake(&_ValidatorsStorage.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) MinorStakeFine(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "minorStakeFine")
	return *ret0, err
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) MinorStakeFine() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MinorStakeFine(&_ValidatorsStorage.CallOpts)
}

// MinorStakeFine is a free data retrieval call binding the contract method 0x6d059126.
//
// Solidity: function minorStakeFine() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) MinorStakeFine() (*big.Int, error) {
	return _ValidatorsStorage.Contract.MinorStakeFine(&_ValidatorsStorage.CallOpts)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) RewardAmount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "rewardAmount")
	return *ret0, err
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) RewardAmount() (*big.Int, error) {
	return _ValidatorsStorage.Contract.RewardAmount(&_ValidatorsStorage.CallOpts)
}

// RewardAmount is a free data retrieval call binding the contract method 0xf7b2a7be.
//
// Solidity: function rewardAmount() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) RewardAmount() (*big.Int, error) {
	return _ValidatorsStorage.Contract.RewardAmount(&_ValidatorsStorage.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCaller) RewardBonus(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "rewardBonus")
	return *ret0, err
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageSession) RewardBonus() (*big.Int, error) {
	return _ValidatorsStorage.Contract.RewardBonus(&_ValidatorsStorage.CallOpts)
}

// RewardBonus is a free data retrieval call binding the contract method 0xfdf553cf.
//
// Solidity: function rewardBonus() view returns(uint256)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) RewardBonus() (*big.Int, error) {
	return _ValidatorsStorage.Contract.RewardBonus(&_ValidatorsStorage.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageCaller) ValidatorCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "validatorCount")
	return *ret0, err
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageSession) ValidatorCount() (uint8, error) {
	return _ValidatorsStorage.Contract.ValidatorCount(&_ValidatorsStorage.CallOpts)
}

// ValidatorCount is a free data retrieval call binding the contract method 0x0f43a677.
//
// Solidity: function validatorCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) ValidatorCount() (uint8, error) {
	return _ValidatorsStorage.Contract.ValidatorCount(&_ValidatorsStorage.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageCaller) ValidatorMaxCount(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ValidatorsStorage.contract.Call(opts, out, "validatorMaxCount")
	return *ret0, err
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageSession) ValidatorMaxCount() (uint8, error) {
	return _ValidatorsStorage.Contract.ValidatorMaxCount(&_ValidatorsStorage.CallOpts)
}

// ValidatorMaxCount is a free data retrieval call binding the contract method 0x09f0d45d.
//
// Solidity: function validatorMaxCount() view returns(uint8)
func (_ValidatorsStorage *ValidatorsStorageCallerSession) ValidatorMaxCount() (uint8, error) {
	return _ValidatorsStorage.Contract.ValidatorMaxCount(&_ValidatorsStorage.CallOpts)
}

// ValidatorsStorageSnapshotTakenIterator is returned from FilterSnapshotTaken and is used to iterate over the raw logs and unpacked data for SnapshotTaken events raised by the ValidatorsStorage contract.
type ValidatorsStorageSnapshotTakenIterator struct {
	Event *ValidatorsStorageSnapshotTaken // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsStorageSnapshotTakenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsStorageSnapshotTaken)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsStorageSnapshotTaken)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsStorageSnapshotTakenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsStorageSnapshotTakenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsStorageSnapshotTaken represents a SnapshotTaken event raised by the ValidatorsStorage contract.
type ValidatorsStorageSnapshotTaken struct {
	ChainId        uint32
	Epoch          *big.Int
	Height         uint32
	Validator      common.Address
	StartingETHDKG bool
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterSnapshotTaken is a free log retrieval operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsStorage *ValidatorsStorageFilterer) FilterSnapshotTaken(opts *bind.FilterOpts, epoch []*big.Int, validator []common.Address) (*ValidatorsStorageSnapshotTakenIterator, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.FilterLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageSnapshotTakenIterator{contract: _ValidatorsStorage.contract, event: "SnapshotTaken", logs: logs, sub: sub}, nil
}

// WatchSnapshotTaken is a free log subscription operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsStorage *ValidatorsStorageFilterer) WatchSnapshotTaken(opts *bind.WatchOpts, sink chan<- *ValidatorsStorageSnapshotTaken, epoch []*big.Int, validator []common.Address) (event.Subscription, error) {

	var epochRule []interface{}
	for _, epochItem := range epoch {
		epochRule = append(epochRule, epochItem)
	}

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.WatchLogs(opts, "SnapshotTaken", epochRule, validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsStorageSnapshotTaken)
				if err := _ValidatorsStorage.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSnapshotTaken is a log parse operation binding the contract event 0x6d438b6b835d16cdae6efdc0259fdfba17e6aa32dae81863a2467866f85f724a.
//
// Solidity: event SnapshotTaken(uint32 chainId, uint256 indexed epoch, uint32 height, address indexed validator, bool startingETHDKG)
func (_ValidatorsStorage *ValidatorsStorageFilterer) ParseSnapshotTaken(log types.Log) (*ValidatorsStorageSnapshotTaken, error) {
	event := new(ValidatorsStorageSnapshotTaken)
	if err := _ValidatorsStorage.contract.UnpackLog(event, "SnapshotTaken", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageValidatorCreatedIterator is returned from FilterValidatorCreated and is used to iterate over the raw logs and unpacked data for ValidatorCreated events raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorCreatedIterator struct {
	Event *ValidatorsStorageValidatorCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsStorageValidatorCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsStorageValidatorCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsStorageValidatorCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsStorageValidatorCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsStorageValidatorCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsStorageValidatorCreated represents a ValidatorCreated event raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorCreated struct {
	Validator common.Address
	Signer    common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorCreated is a free log retrieval operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) FilterValidatorCreated(opts *bind.FilterOpts, validator []common.Address, signer []common.Address) (*ValidatorsStorageValidatorCreatedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.FilterLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageValidatorCreatedIterator{contract: _ValidatorsStorage.contract, event: "ValidatorCreated", logs: logs, sub: sub}, nil
}

// WatchValidatorCreated is a free log subscription operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) WatchValidatorCreated(opts *bind.WatchOpts, sink chan<- *ValidatorsStorageValidatorCreated, validator []common.Address, signer []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}
	var signerRule []interface{}
	for _, signerItem := range signer {
		signerRule = append(signerRule, signerItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.WatchLogs(opts, "ValidatorCreated", validatorRule, signerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsStorageValidatorCreated)
				if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorCreated is a log parse operation binding the contract event 0xef5e89a9416c26e0a0a37c1f630958c8c88d9efad59f553f94cff0bed0a268d3.
//
// Solidity: event ValidatorCreated(address indexed validator, address indexed signer, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) ParseValidatorCreated(log types.Log) (*ValidatorsStorageValidatorCreated, error) {
	event := new(ValidatorsStorageValidatorCreated)
	if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageValidatorJoinedIterator is returned from FilterValidatorJoined and is used to iterate over the raw logs and unpacked data for ValidatorJoined events raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorJoinedIterator struct {
	Event *ValidatorsStorageValidatorJoined // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsStorageValidatorJoinedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsStorageValidatorJoined)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsStorageValidatorJoined)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsStorageValidatorJoinedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsStorageValidatorJoinedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsStorageValidatorJoined represents a ValidatorJoined event raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorJoined struct {
	Validator common.Address
	MadID     [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorJoined is a free log retrieval operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) FilterValidatorJoined(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsStorageValidatorJoinedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.FilterLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageValidatorJoinedIterator{contract: _ValidatorsStorage.contract, event: "ValidatorJoined", logs: logs, sub: sub}, nil
}

// WatchValidatorJoined is a free log subscription operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) WatchValidatorJoined(opts *bind.WatchOpts, sink chan<- *ValidatorsStorageValidatorJoined, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.WatchLogs(opts, "ValidatorJoined", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsStorageValidatorJoined)
				if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorJoined is a log parse operation binding the contract event 0x8c25e214c5693ebaf8008875bacedeb9e0aafd393864a314ed1801b2a4e13dd9.
//
// Solidity: event ValidatorJoined(address indexed validator, uint256[2] madID)
func (_ValidatorsStorage *ValidatorsStorageFilterer) ParseValidatorJoined(log types.Log) (*ValidatorsStorageValidatorJoined, error) {
	event := new(ValidatorsStorageValidatorJoined)
	if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorJoined", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageValidatorLeftIterator is returned from FilterValidatorLeft and is used to iterate over the raw logs and unpacked data for ValidatorLeft events raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorLeftIterator struct {
	Event *ValidatorsStorageValidatorLeft // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsStorageValidatorLeftIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsStorageValidatorLeft)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsStorageValidatorLeft)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsStorageValidatorLeftIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsStorageValidatorLeftIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsStorageValidatorLeft represents a ValidatorLeft event raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorLeft struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorLeft is a free log retrieval operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) FilterValidatorLeft(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsStorageValidatorLeftIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.FilterLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageValidatorLeftIterator{contract: _ValidatorsStorage.contract, event: "ValidatorLeft", logs: logs, sub: sub}, nil
}

// WatchValidatorLeft is a free log subscription operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) WatchValidatorLeft(opts *bind.WatchOpts, sink chan<- *ValidatorsStorageValidatorLeft, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.WatchLogs(opts, "ValidatorLeft", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsStorageValidatorLeft)
				if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorLeft is a log parse operation binding the contract event 0x319bbadb03b94aedc69babb34a28675536a9cb30f4bbde343e1d0018c44ebd94.
//
// Solidity: event ValidatorLeft(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) ParseValidatorLeft(log types.Log) (*ValidatorsStorageValidatorLeft, error) {
	event := new(ValidatorsStorageValidatorLeft)
	if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorLeft", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageValidatorQueuedIterator is returned from FilterValidatorQueued and is used to iterate over the raw logs and unpacked data for ValidatorQueued events raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorQueuedIterator struct {
	Event *ValidatorsStorageValidatorQueued // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ValidatorsStorageValidatorQueuedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ValidatorsStorageValidatorQueued)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ValidatorsStorageValidatorQueued)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ValidatorsStorageValidatorQueuedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ValidatorsStorageValidatorQueuedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ValidatorsStorageValidatorQueued represents a ValidatorQueued event raised by the ValidatorsStorage contract.
type ValidatorsStorageValidatorQueued struct {
	Validator common.Address
	PkHash    [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterValidatorQueued is a free log retrieval operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) FilterValidatorQueued(opts *bind.FilterOpts, validator []common.Address) (*ValidatorsStorageValidatorQueuedIterator, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.FilterLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageValidatorQueuedIterator{contract: _ValidatorsStorage.contract, event: "ValidatorQueued", logs: logs, sub: sub}, nil
}

// WatchValidatorQueued is a free log subscription operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) WatchValidatorQueued(opts *bind.WatchOpts, sink chan<- *ValidatorsStorageValidatorQueued, validator []common.Address) (event.Subscription, error) {

	var validatorRule []interface{}
	for _, validatorItem := range validator {
		validatorRule = append(validatorRule, validatorItem)
	}

	logs, sub, err := _ValidatorsStorage.contract.WatchLogs(opts, "ValidatorQueued", validatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ValidatorsStorageValidatorQueued)
				if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorQueued is a log parse operation binding the contract event 0xb4389eb1c66b46169245bc8c147e4b13a2b88adcaa44d001b0fadf25890b773d.
//
// Solidity: event ValidatorQueued(address indexed validator, uint256[2] pkHash)
func (_ValidatorsStorage *ValidatorsStorageFilterer) ParseValidatorQueued(log types.Log) (*ValidatorsStorageValidatorQueued, error) {
	event := new(ValidatorsStorageValidatorQueued)
	if err := _ValidatorsStorage.contract.UnpackLog(event, "ValidatorQueued", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ValidatorsStorageLibraryABI is the input ABI used to generate the binding from.
const ValidatorsStorageLibraryABI = "[]"

// ValidatorsStorageLibraryBin is the compiled bytecode used for deploying new contracts.
var ValidatorsStorageLibraryBin = "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122059e10a9aad5a507160b51d5e3717f4fc28c22beab28995c4106693c241f96c0864736f6c63430006070033"

// DeployValidatorsStorageLibrary deploys a new Ethereum contract, binding an instance of ValidatorsStorageLibrary to it.
func DeployValidatorsStorageLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsStorageLibrary, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsStorageLibraryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsStorageLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsStorageLibrary{ValidatorsStorageLibraryCaller: ValidatorsStorageLibraryCaller{contract: contract}, ValidatorsStorageLibraryTransactor: ValidatorsStorageLibraryTransactor{contract: contract}, ValidatorsStorageLibraryFilterer: ValidatorsStorageLibraryFilterer{contract: contract}}, nil
}

// ValidatorsStorageLibrary is an auto generated Go binding around an Ethereum contract.
type ValidatorsStorageLibrary struct {
	ValidatorsStorageLibraryCaller     // Read-only binding to the contract
	ValidatorsStorageLibraryTransactor // Write-only binding to the contract
	ValidatorsStorageLibraryFilterer   // Log filterer for contract events
}

// ValidatorsStorageLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsStorageLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsStorageLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsStorageLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsStorageLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsStorageLibrarySession struct {
	Contract     *ValidatorsStorageLibrary // Generic contract binding to set the session for
	CallOpts     bind.CallOpts             // Call options to use throughout this session
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ValidatorsStorageLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsStorageLibraryCallerSession struct {
	Contract *ValidatorsStorageLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                   // Call options to use throughout this session
}

// ValidatorsStorageLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsStorageLibraryTransactorSession struct {
	Contract     *ValidatorsStorageLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                   // Transaction auth options to use throughout this session
}

// ValidatorsStorageLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsStorageLibraryRaw struct {
	Contract *ValidatorsStorageLibrary // Generic contract binding to access the raw methods on
}

// ValidatorsStorageLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsStorageLibraryCallerRaw struct {
	Contract *ValidatorsStorageLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsStorageLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsStorageLibraryTransactorRaw struct {
	Contract *ValidatorsStorageLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsStorageLibrary creates a new instance of ValidatorsStorageLibrary, bound to a specific deployed contract.
func NewValidatorsStorageLibrary(address common.Address, backend bind.ContractBackend) (*ValidatorsStorageLibrary, error) {
	contract, err := bindValidatorsStorageLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageLibrary{ValidatorsStorageLibraryCaller: ValidatorsStorageLibraryCaller{contract: contract}, ValidatorsStorageLibraryTransactor: ValidatorsStorageLibraryTransactor{contract: contract}, ValidatorsStorageLibraryFilterer: ValidatorsStorageLibraryFilterer{contract: contract}}, nil
}

// NewValidatorsStorageLibraryCaller creates a new read-only instance of ValidatorsStorageLibrary, bound to a specific deployed contract.
func NewValidatorsStorageLibraryCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsStorageLibraryCaller, error) {
	contract, err := bindValidatorsStorageLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageLibraryCaller{contract: contract}, nil
}

// NewValidatorsStorageLibraryTransactor creates a new write-only instance of ValidatorsStorageLibrary, bound to a specific deployed contract.
func NewValidatorsStorageLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsStorageLibraryTransactor, error) {
	contract, err := bindValidatorsStorageLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageLibraryTransactor{contract: contract}, nil
}

// NewValidatorsStorageLibraryFilterer creates a new log filterer instance of ValidatorsStorageLibrary, bound to a specific deployed contract.
func NewValidatorsStorageLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsStorageLibraryFilterer, error) {
	contract, err := bindValidatorsStorageLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsStorageLibraryFilterer{contract: contract}, nil
}

// bindValidatorsStorageLibrary binds a generic wrapper to an already deployed contract.
func bindValidatorsStorageLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsStorageLibraryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsStorageLibrary.Contract.ValidatorsStorageLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsStorageLibrary.Contract.ValidatorsStorageLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsStorageLibrary.Contract.ValidatorsStorageLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsStorageLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsStorageLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsStorageLibrary *ValidatorsStorageLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsStorageLibrary.Contract.contract.Transact(opts, method, params...)
}

// ValidatorsUpdateFacetABI is the input ABI used to generate the binding from.
const ValidatorsUpdateFacetABI = "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"addFacet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"removeFacet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"replaceFacet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ValidatorsUpdateFacetBin is the compiled bytecode used for deploying new contracts.
var ValidatorsUpdateFacetBin = "0x608060405234801561001057600080fd5b506107b0806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063208865cc14610046578063ca5a0fae14610062578063de380fbf1461007e575b600080fd5b610060600480360381019061005b9190610581565b61009a565b005b61007c60048036038101906100779190610558565b61021f565b005b61009860048036038101906100939190610581565b610388565b005b60006100a461050e565b9050600073ffffffffffffffffffffffffffffffffffffffff16816000016000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610188576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017f90610692565b60405180910390fd5b81816000016000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050565b600061022961050e565b9050600073ffffffffffffffffffffffffffffffffffffffff16816000016000847bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141561030e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610305906106b2565b60405180910390fd5b806000016000837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690555050565b600061039261050e565b9050600073ffffffffffffffffffffffffffffffffffffffff16816000016000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415610477576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161046e906106b2565b60405180910390fd5b81816000016000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050565b60008060405161051d9061067d565b604051809103902090508091505090565b60008135905061053d8161074c565b92915050565b60008135905061055281610763565b92915050565b60006020828403121561056a57600080fd5b600061057884828501610543565b91505092915050565b6000806040838503121561059457600080fd5b60006105a285828601610543565b92505060206105b38582860161052e565b9150509250929050565b60006105ca6017836106d2565b91507f73656c6563746f7220616c7265616479206578697374730000000000000000006000830152602082019050919050565b600061060a6017836106d2565b91507f73656c6563746f7220646f6573206e6f742065786973740000000000000000006000830152602082019050919050565b600061064a6012836106e3565b91507f76616c696461746f72732e73746f7261676500000000000000000000000000006000830152601282019050919050565b60006106888261063d565b9150819050919050565b600060208201905081810360008301526106ab816105bd565b9050919050565b600060208201905081810360008301526106cb816105fd565b9050919050565b600082825260208201905092915050565b600081905092915050565b60006106f98261072c565b9050919050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b610755816106ee565b811461076057600080fd5b50565b61076c81610700565b811461077757600080fd5b5056fea2646970667358221220d67183431b0f3cc4faaf8f66005f63045225d0b456ec5153bc38ab9c8ba110a764736f6c63430006070033"

// DeployValidatorsUpdateFacet deploys a new Ethereum contract, binding an instance of ValidatorsUpdateFacet to it.
func DeployValidatorsUpdateFacet(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorsUpdateFacet, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsUpdateFacetABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValidatorsUpdateFacetBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorsUpdateFacet{ValidatorsUpdateFacetCaller: ValidatorsUpdateFacetCaller{contract: contract}, ValidatorsUpdateFacetTransactor: ValidatorsUpdateFacetTransactor{contract: contract}, ValidatorsUpdateFacetFilterer: ValidatorsUpdateFacetFilterer{contract: contract}}, nil
}

// ValidatorsUpdateFacet is an auto generated Go binding around an Ethereum contract.
type ValidatorsUpdateFacet struct {
	ValidatorsUpdateFacetCaller     // Read-only binding to the contract
	ValidatorsUpdateFacetTransactor // Write-only binding to the contract
	ValidatorsUpdateFacetFilterer   // Log filterer for contract events
}

// ValidatorsUpdateFacetCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorsUpdateFacetCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsUpdateFacetTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorsUpdateFacetTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsUpdateFacetFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorsUpdateFacetFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorsUpdateFacetSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorsUpdateFacetSession struct {
	Contract     *ValidatorsUpdateFacet // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ValidatorsUpdateFacetCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorsUpdateFacetCallerSession struct {
	Contract *ValidatorsUpdateFacetCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// ValidatorsUpdateFacetTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorsUpdateFacetTransactorSession struct {
	Contract     *ValidatorsUpdateFacetTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// ValidatorsUpdateFacetRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorsUpdateFacetRaw struct {
	Contract *ValidatorsUpdateFacet // Generic contract binding to access the raw methods on
}

// ValidatorsUpdateFacetCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorsUpdateFacetCallerRaw struct {
	Contract *ValidatorsUpdateFacetCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorsUpdateFacetTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorsUpdateFacetTransactorRaw struct {
	Contract *ValidatorsUpdateFacetTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorsUpdateFacet creates a new instance of ValidatorsUpdateFacet, bound to a specific deployed contract.
func NewValidatorsUpdateFacet(address common.Address, backend bind.ContractBackend) (*ValidatorsUpdateFacet, error) {
	contract, err := bindValidatorsUpdateFacet(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorsUpdateFacet{ValidatorsUpdateFacetCaller: ValidatorsUpdateFacetCaller{contract: contract}, ValidatorsUpdateFacetTransactor: ValidatorsUpdateFacetTransactor{contract: contract}, ValidatorsUpdateFacetFilterer: ValidatorsUpdateFacetFilterer{contract: contract}}, nil
}

// NewValidatorsUpdateFacetCaller creates a new read-only instance of ValidatorsUpdateFacet, bound to a specific deployed contract.
func NewValidatorsUpdateFacetCaller(address common.Address, caller bind.ContractCaller) (*ValidatorsUpdateFacetCaller, error) {
	contract, err := bindValidatorsUpdateFacet(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsUpdateFacetCaller{contract: contract}, nil
}

// NewValidatorsUpdateFacetTransactor creates a new write-only instance of ValidatorsUpdateFacet, bound to a specific deployed contract.
func NewValidatorsUpdateFacetTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorsUpdateFacetTransactor, error) {
	contract, err := bindValidatorsUpdateFacet(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorsUpdateFacetTransactor{contract: contract}, nil
}

// NewValidatorsUpdateFacetFilterer creates a new log filterer instance of ValidatorsUpdateFacet, bound to a specific deployed contract.
func NewValidatorsUpdateFacetFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorsUpdateFacetFilterer, error) {
	contract, err := bindValidatorsUpdateFacet(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorsUpdateFacetFilterer{contract: contract}, nil
}

// bindValidatorsUpdateFacet binds a generic wrapper to an already deployed contract.
func bindValidatorsUpdateFacet(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorsUpdateFacetABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsUpdateFacet.Contract.ValidatorsUpdateFacetCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.ValidatorsUpdateFacetTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.ValidatorsUpdateFacetTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ValidatorsUpdateFacet.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.contract.Transact(opts, method, params...)
}

// AddFacet is a paid mutator transaction binding the contract method 0x208865cc.
//
// Solidity: function addFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactor) AddFacet(opts *bind.TransactOpts, selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.contract.Transact(opts, "addFacet", selector, facet)
}

// AddFacet is a paid mutator transaction binding the contract method 0x208865cc.
//
// Solidity: function addFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetSession) AddFacet(selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.AddFacet(&_ValidatorsUpdateFacet.TransactOpts, selector, facet)
}

// AddFacet is a paid mutator transaction binding the contract method 0x208865cc.
//
// Solidity: function addFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactorSession) AddFacet(selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.AddFacet(&_ValidatorsUpdateFacet.TransactOpts, selector, facet)
}

// RemoveFacet is a paid mutator transaction binding the contract method 0xca5a0fae.
//
// Solidity: function removeFacet(bytes4 selector) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactor) RemoveFacet(opts *bind.TransactOpts, selector [4]byte) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.contract.Transact(opts, "removeFacet", selector)
}

// RemoveFacet is a paid mutator transaction binding the contract method 0xca5a0fae.
//
// Solidity: function removeFacet(bytes4 selector) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetSession) RemoveFacet(selector [4]byte) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.RemoveFacet(&_ValidatorsUpdateFacet.TransactOpts, selector)
}

// RemoveFacet is a paid mutator transaction binding the contract method 0xca5a0fae.
//
// Solidity: function removeFacet(bytes4 selector) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactorSession) RemoveFacet(selector [4]byte) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.RemoveFacet(&_ValidatorsUpdateFacet.TransactOpts, selector)
}

// ReplaceFacet is a paid mutator transaction binding the contract method 0xde380fbf.
//
// Solidity: function replaceFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactor) ReplaceFacet(opts *bind.TransactOpts, selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.contract.Transact(opts, "replaceFacet", selector, facet)
}

// ReplaceFacet is a paid mutator transaction binding the contract method 0xde380fbf.
//
// Solidity: function replaceFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetSession) ReplaceFacet(selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.ReplaceFacet(&_ValidatorsUpdateFacet.TransactOpts, selector, facet)
}

// ReplaceFacet is a paid mutator transaction binding the contract method 0xde380fbf.
//
// Solidity: function replaceFacet(bytes4 selector, address facet) returns()
func (_ValidatorsUpdateFacet *ValidatorsUpdateFacetTransactorSession) ReplaceFacet(selector [4]byte, facet common.Address) (*types.Transaction, error) {
	return _ValidatorsUpdateFacet.Contract.ReplaceFacet(&_ValidatorsUpdateFacet.TransactOpts, selector, facet)
}
